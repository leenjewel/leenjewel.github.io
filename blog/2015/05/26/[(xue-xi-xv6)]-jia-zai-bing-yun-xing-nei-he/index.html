
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>【学习Xv6】加载并运行内核 - leenjewel Blog</title>
	<meta name="author" content="leenjewel">

	
	<meta name="description" content="前情提要 学习 xv6 系列的上一篇《【学习xv6】从实模式到保护模式》讲到我们的系统已经将计算机的 CPU 从实模式切换到保护模式状态下了，接下来我们可以暂时告别晦涩难懂的汇编语言来到 C 语言环境中了，引导的工作快要接近尾声，内核即将被载入运行。 预备知识 从硬盘读取数据 在《【学习xv6】 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="leenjewel Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=52606582" charset="UTF-8"></script>
<script type="text/javascript" charset="UTF-8" src="http://lurongkai.github.io/anti-baidu/js/anti-baidu-latest.min.js"></script>

</head>


<body>
	<header id="header" class="inner"><nav id="title-nav">
<h1><a href="/">leenjewel Blog</a></h1>

<h2>Anything about code.</h2>

</nav>
<nav id="main-nav"><ul class="main">
	<li><a href="/">首页</a></li>
	<li><a href="/blog/archives">全部日志</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">首页</a></li>
	<li><a href="/blog/archives">全部日志</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:leenjewel.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		<a class="github" href="https://github.com/leenjewel" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:leenjewel.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">【学习Xv6】加载并运行内核</h2>
	<div class="entry-content"><h2>前情提要</h2>

<p>学习 xv6 系列的上一篇<a href="http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">《【学习xv6】从实模式到保护模式》</a>讲到我们的系统已经将计算机的 CPU 从实模式切换到保护模式状态下了，接下来我们可以暂时告别晦涩难懂的汇编语言来到 C 语言环境中了，引导的工作快要接近尾声，内核即将被载入运行。</p>

<h2>预备知识</h2>

<h3>从硬盘读取数据</h3>

<p>在<a href="http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">《【学习xv6】从实模式到保护模式》</a>中我们已经讲到了如何通过向 804x 键盘控制器端口发送信号来打开 A20 gate 了，同样道理，我们向硬盘控制器的指定端口发送信号就可以操作硬盘，从硬盘读取或向硬盘写入数据。IDE 标准定义了 8 个寄存器来操作硬盘。PC 体系结构将第一个硬盘控制器映射到端口 1F0-1F7 处，而第二个硬盘控制器则被映射到端口 170-177 处。这几个寄存器的描述如下（以第一个控制器为例）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1F0        - 数据寄存器。读写数据都必须通过这个寄存器
</span><span class='line'>
</span><span class='line'>1F1        - 错误寄存器，每一位代表一类错误。全零表示操作成功。
</span><span class='line'>
</span><span class='line'>1F2        - 扇区计数。这里面存放你要操作的扇区数量
</span><span class='line'>
</span><span class='line'>1F3        - 扇区LBA地址的0-7位
</span><span class='line'>
</span><span class='line'>1F4        - 扇区LBA地址的8-15位
</span><span class='line'>
</span><span class='line'>1F5        - 扇区LBA地址的16-23位
</span><span class='line'>
</span><span class='line'>1F6 (低4位) - 扇区LBA地址的24-27位
</span><span class='line'>
</span><span class='line'>1F6 (第4位) - 0表示选择主盘，1表示选择从盘
</span><span class='line'>
</span><span class='line'>1F6 (5-7位) - 必须为1
</span><span class='line'>
</span><span class='line'>1F7 (写)    - 命令寄存器
</span><span class='line'>
</span><span class='line'>1F7 (读)    - 状态寄存器
</span><span class='line'>
</span><span class='line'>              bit 7 = 1  控制器忙
</span><span class='line'>              bit 6 = 1  驱动器就绪
</span><span class='line'>              bit 5 = 1  设备错误
</span><span class='line'>              bit 4        N/A
</span><span class='line'>              bit 3 = 1  扇区缓冲区错误
</span><span class='line'>              bit 2 = 1  磁盘已被读校验
</span><span class='line'>              bit 1        N/A
</span><span class='line'>              bit 0 = 1  上一次命令执行失败</span></code></pre></td></tr></table></div></figure>


<p>稍后讲到从硬盘加载内核到内存时我们再通过 xv6 的实际代码来看看硬盘操作的具体实现。</p>

<h3>ELF文件格式</h3>

<p>在<a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format"> Wiki 百科上有 ELF 文件格式的详细解释</a>，简单的说 ELF 文件格式是 Linux 下可执行文件的标准格式。就好像 Windows 操作系统里的可执行文件 .exe 一样（当然，Windows 里的可执行文件的标准格式叫 PE 文件格式），Linux 操作系统里的可执行文件也有它自己的格式。只有按照文件标准格式组织好的可执行文件操作系统才知道如何加载运行它。我们并使使用 C 语言按照教科书写出的 HelloWorld 代码在 Linux 环境下最终通过编译器（gcc等）编译出的可以运行的程序就是 ELF 文件格式的。</p>

<p>那么 ELF 文件格式具体的结构是怎样的呢？ 大概是下面这个样子的。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center"> ELF 头部 ( ELF Header ) </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> 程序头表 (Program Header Table) </td>
</tr>
<tr>
<td></td>
<td align="center">.text</td>
</tr>
<tr>
<td></td>
<td align="center">.rodata</td>
</tr>
<tr>
<td></td>
<td align="center">&hellip;&hellip;</td>
</tr>
<tr>
<td></td>
<td align="center">节头表 (Section Header Table)</td>
</tr>
</tbody>
</table>


<p>这里我们暂时只关心 ELF 文件结构的前两个部分：ELF 头部和程序头表，xv6 源代码的 elf.h 文件中有其详细的定义，我们来看一下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define ELF_MAGIC 0x464C457FU  </span><span class="c1">// &quot;\x7FELF&quot; in little endian</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ELF 文件格式的头部</span>
</span><span class='line'><span class="k">struct</span> <span class="n">elfhdr</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">magic</span><span class="p">;</span>       <span class="c1">// 4 字节，为 0x464C457FU（大端模式）或 0x7felf（小端模式）</span>
</span><span class='line'>                      <span class="c1">// 表明该文件是个 ELF 格式文件</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uchar</span> <span class="n">elf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>    <span class="c1">// 12 字节，每字节对应意义如下：</span>
</span><span class='line'>                    <span class="c1">//     0 : 1 = 32 位程序；2 = 64 位程序</span>
</span><span class='line'>                    <span class="c1">//     1 : 数据编码方式，0 = 无效；1 = 小端模式；2 = 大端模式</span>
</span><span class='line'>                    <span class="c1">//     2 : 只是版本，固定为 0x1</span>
</span><span class='line'>                    <span class="c1">//     3 : 目标操作系统架构</span>
</span><span class='line'>                    <span class="c1">//     4 : 目标操作系统版本</span>
</span><span class='line'>                    <span class="c1">//     5 ~ 11 : 固定为 0</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">type</span><span class="p">;</span>      <span class="c1">// 2 字节，表明该文件类型，意义如下：</span>
</span><span class='line'>                    <span class="c1">//     0x0 : 未知目标文件格式</span>
</span><span class='line'>                    <span class="c1">//     0x1 : 可重定位文件</span>
</span><span class='line'>                    <span class="c1">//     0x2 : 可执行文件</span>
</span><span class='line'>                    <span class="c1">//     0x3 : 共享目标文件</span>
</span><span class='line'>                    <span class="c1">//     0x4 : 转储文件</span>
</span><span class='line'>                    <span class="c1">//     0xff00 : 特定处理器文件</span>
</span><span class='line'>                    <span class="c1">//     0xffff : 特定处理器文件</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">machine</span><span class="p">;</span>   <span class="c1">// 2 字节，表明运行该程序需要的计算机体系架构，</span>
</span><span class='line'>                    <span class="c1">// 这里我们只需要知道 0x0 为未指定；0x3 为 x86 架构</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uint</span> <span class="n">version</span><span class="p">;</span>     <span class="c1">// 4 字节，表示该文件的版本号</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uint</span> <span class="n">entry</span><span class="p">;</span>       <span class="c1">// 4 字节，该文件的入口地址，没有入口（非可执行文件）则为 0</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uint</span> <span class="n">phoff</span><span class="p">;</span>       <span class="c1">// 4 字节，表示该文件的“程序头部表”相对于文件的位置，单位是字节</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uint</span> <span class="n">shoff</span><span class="p">;</span>       <span class="c1">// 4 字节，表示该文件的“节区头部表”相对于文件的位置，单位是字节</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>       <span class="c1">// 4 字节，特定处理器标志</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">ehsize</span><span class="p">;</span>    <span class="c1">// 2 字节，ELF文件头部的大小，单位是字节</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">phentsize</span><span class="p">;</span> <span class="c1">// 2 字节，表示程序头部表中一个入口的大小，单位是字节</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">phnum</span><span class="p">;</span>     <span class="c1">// 2 字节，表示程序头部表的入口个数，</span>
</span><span class='line'>                    <span class="c1">// phnum * phentsize = 程序头部表大小（单位是字节）</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">shentsize</span><span class="p">;</span> <span class="c1">// 2 字节，节区头部表入口大小，单位是字节</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">shnum</span><span class="p">;</span>     <span class="c1">// 2 字节，节区头部表入口个数，</span>
</span><span class='line'>                    <span class="c1">// shnum * shentsize = 节区头部表大小（单位是字节）</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">shstrndx</span><span class="p">;</span>  <span class="c1">// 2 字节，表示字符表相关入口的节区头部表索引</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 程序头表</span>
</span><span class='line'><span class="k">struct</span> <span class="n">proghdr</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">type</span><span class="p">;</span>        <span class="c1">// 4 字节， 段类型</span>
</span><span class='line'>                    <span class="c1">//         1 PT_LOAD : 可载入的段</span>
</span><span class='line'>                    <span class="c1">//         2 PT_DYNAMIC : 动态链接信息</span>
</span><span class='line'>                    <span class="c1">//         3 PT_INTERP : 指定要作为解释程序调用的以空字符结尾的路径名的位置和大小</span>
</span><span class='line'>                    <span class="c1">//         4 PT_NOTE : 指定辅助信息的位置和大小</span>
</span><span class='line'>                    <span class="c1">//         5 PT_SHLIB : 保留类型，但具有未指定的语义</span>
</span><span class='line'>                    <span class="c1">//         6 PT_PHDR : 指定程序头表在文件及程序内存映像中的位置和大小</span>
</span><span class='line'>                    <span class="c1">//         7 PT_TLS : 指定线程局部存储模板</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">off</span><span class="p">;</span>         <span class="c1">// 4 字节， 段的第一个字节在文件中的偏移</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">vaddr</span><span class="p">;</span>       <span class="c1">// 4 字节， 段的第一个字节在内存中的虚拟地址</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">paddr</span><span class="p">;</span>       <span class="c1">// 4 字节， 段的第一个字节在内存中的物理地址(适用于物理内存定位型的系统)</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">filesz</span><span class="p">;</span>      <span class="c1">// 4 字节， 段在文件中的长度</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">memsz</span><span class="p">;</span>       <span class="c1">// 4 字节， 段在内存中的长度</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>       <span class="c1">// 4 字节， 段标志</span>
</span><span class='line'>                    <span class="c1">//         1 : 可执行</span>
</span><span class='line'>                    <span class="c1">//         2 : 可写入</span>
</span><span class='line'>                    <span class="c1">//         4 : 可读取</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">align</span><span class="p">;</span>       <span class="c1">// 4 字节， 段在文件及内存中如何对齐</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ELF文件的加载与运行</h3>

<p>既然 ELF 标准文件格式是可执行文件（当然不仅仅用于可执行文件，还可以用于动态链接库文件等）使用的文件格式，那么它一定是可以被加载并运行的。学习 xv6 系列的上一篇<a href="http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">《【学习xv6】从实模式到保护模式》</a>的预备知识中我们讲到</p>

<blockquote><p>程序的组成我们可以简单的理解为：数据加上指令就是程序。</p></blockquote>

<p>我们写好的程序代码经过编译器的编译成为机器码，而机器码根据其自身的作用不同被分为不同的段，其中最主要的就是<strong>代码段</strong>和<strong>数据段</strong>。</p>

<p>而一个可执行程序又是有很多个这样的段组成的，一个可执行程序可以有好几个代码段和好几个数据段和其他不同的段。当一个程序准备运行的时候，操作系统会将程序的这些段载入到内从中，再通知 CPU 程序代码段的位置已经开始执行指令的点即入口点。</p>

<p>既然一个可执行程序有多个代码段、多个数据段和其他段，操作系统在加载这些段的时候为了更好的组织利用内存，希望将一些列作用相同的段放在一起加载（比如多个代码段就可以一并加载），编译器为了方便操作系统加载这些作用相同的段，在编译的时候会刻意将作用相同的段安排在一起。而这些作用相同的段在程序中（ELF文件）中是如何组织的，这些组织信息就被记录在 ELF 文件的程序头表中。</p>

<p>所以一个 ELF 文件格式的可执行程序的加载运行过程是这样的：</p>

<ul>
<li>通过读取 ELF 头表中的信息了解该可执行程序是否可以运行（版本号，适用的计算机架构等等）</li>
<li>通过 ELF 头表中的信息找到程序头表</li>
<li>通过读取 ELF 文件中程序头表的信息了解可执行文件中各个段的位置以及加载方式</li>
<li>将可执行文件中需要加载的段加载到内存中，并通知 CPU 从指定的入口点开始执行</li>
</ul>


<h2>从 bootmain 开始</h2>

<p>学习 xv6 系列的上一篇<a href="http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">《【学习xv6】从实模式到保护模式》</a>的最后我们写到</p>

<blockquote><p>通过这个跳转实际上 CPU 就会跳转到 bootasm.S 文件的 start32 标识符处继续执行了</p></blockquote>

<p>我们打开 bootasm.S 文件看看对应的 start32 位置处的代码做了什么事情。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="nl">start32:</span>
</span><span class='line'>  <span class="err">#</span> <span class="n">Set</span> <span class="n">up</span> <span class="n">the</span> <span class="n">protected</span><span class="o">-</span><span class="n">mode</span> <span class="n">data</span> <span class="n">segment</span> <span class="n">registers</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">像上面讲</span> <span class="n">ljmp</span> <span class="err">时所说的，这时候已经在保护模式下了</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">数据段在</span> <span class="n">GDT</span> <span class="err">中的下标是</span> <span class="mi">2</span><span class="err">，所以这里数据段的段选择子是</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span> <span class="o">=</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0001</span> <span class="mo">0000</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">这</span> <span class="mi">16</span> <span class="err">位的段选择子中的前</span> <span class="mi">13</span> <span class="err">位是</span> <span class="n">GDT</span> <span class="err">段表下标，这里前</span> <span class="mi">13</span> <span class="err">位的值是</span> <span class="mi">2</span> <span class="err">代表选择了数据段</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">这里将</span> <span class="mi">3</span> <span class="err">个数据段寄存器都赋值成数据段段选择子的值</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="err">$</span><span class="p">(</span><span class="n">SEG_KDATA</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span> <span class="o">%</span><span class="n">ax</span>    <span class="err">#</span> <span class="n">Our</span> <span class="n">data</span> <span class="n">segment</span> <span class="n">selector</span>  <span class="err">段选择子赋值给</span> <span class="n">ax</span> <span class="err">寄存器</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">ds</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="n">DS</span><span class="o">:</span> <span class="n">Data</span> <span class="n">Segment</span>        <span class="err">初始化数据段寄存器</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">es</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="n">ES</span><span class="o">:</span> <span class="n">Extra</span> <span class="n">Segment</span>       <span class="err">初始化扩展段寄存器</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">ss</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="n">SS</span><span class="o">:</span> <span class="n">Stack</span> <span class="n">Segment</span>       <span class="err">初始化堆栈段寄存器</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="n">ax</span>                 <span class="err">#</span> <span class="n">Zero</span> <span class="n">segments</span> <span class="n">not</span> <span class="n">ready</span> <span class="k">for</span> <span class="n">use</span>  <span class="n">ax</span> <span class="err">寄存器清零</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">fs</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="n">FS</span>                      <span class="err">辅助寄存器清零</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">gs</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="n">GS</span>                      <span class="err">辅助寄存器清零</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">#</span> <span class="n">Set</span> <span class="n">up</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span> <span class="n">and</span> <span class="n">call</span> <span class="n">into</span> <span class="n">C</span><span class="p">.</span>
</span><span class='line'>  <span class="n">movl</span>    <span class="err">$</span><span class="n">start</span><span class="p">,</span> <span class="o">%</span><span class="n">esp</span>
</span><span class='line'>  <span class="n">call</span>    <span class="n">bootmain</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里在初始化了一些寄存器后直接调用了一个叫做 <code>bootmain</code> 的函数，而这个函数是写在 bootmain.c 文件中的，终于我们暂时告别了汇编来到了 C 的世界了。来看看 bootmain 函数在做什么事情。</p>

<h2>载入内核</h2>

<p>bootmain.c 这个文件很小，代码很少，它其实是引导工作的最后部分（引导的大部分工作都在 bootasm.S 中实现），它负责将内核从硬盘上加载到内存中，然后开始执行内核中的程序。我们来看代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define SECTSIZE  512  </span><span class="c1">// 硬盘扇区大小 512 字节</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">bootmain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">uchar</span><span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从 0xa0000 到 0xfffff 的物理地址范围属于设备空间，</span>
</span><span class='line'>  <span class="c1">// 所以内核放置在 0x10000 处开始</span>
</span><span class='line'>  <span class="n">elf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="o">*</span><span class="p">)</span><span class="mh">0x10000</span><span class="p">;</span>  <span class="c1">// scratch space</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从内核所在硬盘位置读取一内存页 4kb 数据</span>
</span><span class='line'>  <span class="n">readseg</span><span class="p">((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 判断是否为 ELF 文件格式</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">ELF_MAGIC</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>  <span class="c1">// let bootasm.S handle error</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 加载 ELF 文件中的程序段 (ignores ph flags).</span>
</span><span class='line'>  <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proghdr</span><span class="o">*</span><span class="p">)((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span> <span class="o">+</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">phoff</span><span class="p">);</span>
</span><span class='line'>  <span class="n">eph</span> <span class="o">=</span> <span class="n">ph</span> <span class="o">+</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">phnum</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">;</span>
</span><span class='line'>    <span class="n">readseg</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">off</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">memsz</span> <span class="o">&gt;</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">)</span>
</span><span class='line'>      <span class="n">stosb</span><span class="p">(</span><span class="n">pa</span> <span class="o">+</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">memsz</span> <span class="o">-</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Call the entry point from the ELF header.</span>
</span><span class='line'>  <span class="c1">// Does not return!</span>
</span><span class='line'>  <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
</span><span class='line'>  <span class="n">entry</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里将内核（一个 ELF 格式文件）从硬盘读取到内存 <code>0x10000</code> 处的关键方法是 <code>readseg(uchar*, uint, uint)</code> 我们再来看看这个函数的具体实现代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">readseg</span><span class="p">(</span><span class="n">uchar</span><span class="o">*</span> <span class="n">pa</span><span class="p">,</span> <span class="n">uint</span> <span class="n">count</span><span class="p">,</span> <span class="n">uint</span> <span class="n">offset</span><span class="p">)</span>  <span class="c1">// 0x10000, 4096(0x1000), 0</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">uchar</span><span class="o">*</span> <span class="n">epa</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">epa</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>  <span class="c1">// 0x11000</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 根据扇区大小 512 字节做对齐</span>
</span><span class='line'>  <span class="n">pa</span> <span class="o">-=</span> <span class="n">offset</span> <span class="o">%</span> <span class="n">SECTSIZE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// bootblock 引导区在第一扇区（下标为 0），内核在第二个扇区（下标为 1）</span>
</span><span class='line'>  <span class="c1">// 这里做 +1 操作是统一略过引导区</span>
</span><span class='line'>  <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">/</span> <span class="n">SECTSIZE</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// If this is too slow, we could read lots of sectors at a time.</span>
</span><span class='line'>  <span class="c1">// We&#39;d write more to memory than asked, but it doesn&#39;t matter --</span>
</span><span class='line'>  <span class="c1">// we load in increasing order.</span>
</span><span class='line'>  <span class="c1">// 一次读取一个扇区 512 字节的数据</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(;</span> <span class="n">pa</span> <span class="o">&lt;</span> <span class="n">epa</span><span class="p">;</span> <span class="n">pa</span> <span class="o">+=</span> <span class="n">SECTSIZE</span><span class="p">,</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="n">readsect</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们来看看为什么说内核在磁盘的第二扇区，引导区在磁盘的第一扇区。在 xv6 系列文章的第一篇<a href="http://leenjewel.github.io/blog/2014/07/24/%5B%28xue-xi-xv6-%29%5D-zai-mac-osx-xia-yun-xing-xv6/">《【学习 Xv6 】在 Mac OSX 下运行 Xv6》</a>里讲到过</p>

<blockquote><p>编译成功后我们会得到 xv6.img 和 fs.img 两个文件。</p>

<p>在 Hardware 配置页的 Hard disk 里把 xv6.img 载入进去。</p>

<p>在 Advanced 配置页的 Hard disk 2 里把 fs.img 载入进去。</p></blockquote>

<p>由此我们可以猜测内核应该在 xv6.img 这个镜像文件中。下面我们通过 Makefile 来印证这一点，我们看一下 xv6 的 Makefile 文件关于 xv6.img 构建过程的说明</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">xv6</span><span class="p">.</span><span class="n">img</span><span class="o">:</span> <span class="n">bootblock</span> <span class="n">kernel</span> <span class="n">fs</span><span class="p">.</span><span class="n">img</span>
</span><span class='line'>  <span class="n">dd</span> <span class="k">if</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">zero</span> <span class="n">of</span><span class="o">=</span><span class="n">xv6</span><span class="p">.</span><span class="n">img</span> <span class="n">count</span><span class="o">=</span><span class="mi">10000</span>
</span><span class='line'>  <span class="n">dd</span> <span class="k">if</span><span class="o">=</span><span class="n">bootblock</span> <span class="n">of</span><span class="o">=</span><span class="n">xv6</span><span class="p">.</span><span class="n">img</span> <span class="n">conv</span><span class="o">=</span><span class="n">notrunc</span>
</span><span class='line'>  <span class="n">dd</span> <span class="k">if</span><span class="o">=</span><span class="n">kernel</span> <span class="n">of</span><span class="o">=</span><span class="n">xv6</span><span class="p">.</span><span class="n">img</span> <span class="n">seek</span><span class="o">=</span><span class="mi">1</span> <span class="n">conv</span><span class="o">=</span><span class="n">notrunc</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出 xv6.img 是一个由 10000 个扇区组成的（512b x 10000 = 5 MB），而里面包含的只有 <code>bootblock</code> 和 <code>kernel</code> 两个块，通过名字我们不难看出 <code>bootblock</code> 就是引导区，它的大小正好是 512 字节即一个磁盘扇区大小（可以通过文件浏览器看到），所以根据它们写入 xv6.img 的顺序我们证实了猜测，在 xv6 系统中引导区占一个磁盘扇区大小，放置在磁盘的第一扇区，紧随其后的是内核文件（ELF 文件格式）。我们用一个十六进制编辑器打开 kernel 文件看看，可以看到开头的数据内如如下</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">magic</th>
<th align="center">elf[12]</th>
<th align="center">type</th>
<th align="center">machine</th>
<th align="center">version</th>
<th align="center">entry</th>
<th align="center">phoff</th>
<th align="center">shoff</th>
<th align="center">flags</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">7F 45 4C 46</td>
<td align="center">01 01 01 00 00 00 00 00 00 00 00 00</td>
<td align="center">02 00</td>
<td align="center">03 00</td>
<td align="center">01 00 00 00</td>
<td align="center">0C 00 10 00</td>
<td align="center">34 00 00 00</td>
<td align="center">00 F6 01 00</td>
<td align="center">00 00 00 00|</td>
</tr>
<tr>
<td></td>
<td align="center">ehsize</td>
<td align="center">phentsize</td>
<td align="center">phnum</td>
<td align="center">shentsize</td>
<td align="center">shnum</td>
<td align="center">shstrndx</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="center">34 00</td>
<td align="center">20 00</td>
<td align="center">02 00</td>
<td align="center">28 00</td>
<td align="center">12 00</td>
<td align="center">0F 00</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>


<p>而内核文件的前 4 字节正式 ELF 文件头的模数 <code>ELF_MAGIC 0x464C457F</code> 这也说明了内核文件确实是一个 ELF 格式的文件。如果我们按照 ELF 文件结构重拍上面的机器码会是这样</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">字段名称</th>
<th align="center">大小</th>
<th align="center">数值</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">magic</td>
<td align="center">4字节</td>
<td align="center">7F 45 4C 46</td>
<td align="center">ELF 格式文件|</td>
</tr>
<tr>
<td></td>
<td align="center">elf</td>
<td align="center">12字节</td>
<td align="center">01 01 01 00 00 00 00 00 00 00 00 00</td>
<td align="center"> 32 位小端模式，目标操作系统为 System V</td>
</tr>
<tr>
<td></td>
<td align="center">type</td>
<td align="center">2字节</td>
<td align="center">02 00</td>
<td align="center">可执行文件|</td>
</tr>
<tr>
<td></td>
<td align="center">machine</td>
<td align="center">2字节</td>
<td align="center">03 00</td>
<td align="center">指定计算机体系架构为 x86|</td>
</tr>
<tr>
<td></td>
<td align="center">version</td>
<td align="center">4字节</td>
<td align="center">01 00 00 00</td>
<td align="center">版本号为 1|</td>
</tr>
<tr>
<td></td>
<td align="center">entry</td>
<td align="center">4字节</td>
<td align="center">0C 00 10 00</td>
<td align="center">该可执行文件入口地址|</td>
</tr>
<tr>
<td></td>
<td align="center">phoff</td>
<td align="center">4字节</td>
<td align="center">34 00 00 00</td>
<td align="center">程序头表相对于文件的起始位置是 52 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">shoff</td>
<td align="center">4字节</td>
<td align="center">00 F6 01 00</td>
<td align="center">节区头表相对于文件的起始位置是 128512 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">flags</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">无特定处理器标志|</td>
</tr>
<tr>
<td></td>
<td align="center">ehsize</td>
<td align="center">2字节</td>
<td align="center">34 00</td>
<td align="center">ELF 头大小为 52 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">phentsize</td>
<td align="center">2字节</td>
<td align="center">20 00</td>
<td align="center">程序头表一个入口的大小是 32 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">phnum</td>
<td align="center">2字节</td>
<td align="center">02 00</td>
<td align="center">程序头表入口个数是 2 个|</td>
</tr>
<tr>
<td></td>
<td align="center">shentsize</td>
<td align="center">2字节</td>
<td align="center">28 00</td>
<td align="center">节区头表入口大小是 40 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">shnum</td>
<td align="center">2字节</td>
<td align="center">12 00</td>
<td align="center">节区头表入口个数是 18 个|</td>
</tr>
<tr>
<td></td>
<td align="center">shstrndx</td>
<td align="center">2字节</td>
<td align="center">0F 00</td>
<td align="center">字符表入口在节区头表的索引是 15|</td>
</tr>
</tbody>
</table>


<p>通过十六进制编辑器逐个字节的去分析内核文件的 ELF 头部是希望大家能有个更直观的认识，当然了 Linux 也为我们提供了方便的工具 <code>readelf</code> 命令来检查 ELF 文件的相关信息。我们再通过 <code>readelf</code> 命令验证一下我们刚刚通过十六进制编辑器分析的结果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>readelf -h kernel
</span><span class='line'>ELF Header:
</span><span class='line'>  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
</span><span class='line'>  Class:                             ELF32
</span><span class='line'>  Data:                              2<span class="err">&#39;</span>s complement, little endian
</span><span class='line'>  Version:                           1 <span class="o">(</span>current<span class="o">)</span>
</span><span class='line'>  OS/ABI:                            UNIX - System V
</span><span class='line'>  ABI Version:                       0
</span><span class='line'>  Type:                              EXEC <span class="o">(</span>Executable file<span class="o">)</span>
</span><span class='line'>  Machine:                           Intel 80386
</span><span class='line'>  Version:                           0x1
</span><span class='line'>  Entry point address:               0x10000c
</span><span class='line'>  Start of program headers:          52 <span class="o">(</span>bytes into file<span class="o">)</span>
</span><span class='line'>  Start of section headers:          128512 <span class="o">(</span>bytes into file<span class="o">)</span>
</span><span class='line'>  Flags:                             0x0
</span><span class='line'>  Size of this header:               52 <span class="o">(</span>bytes<span class="o">)</span>
</span><span class='line'>  Size of program headers:           32 <span class="o">(</span>bytes<span class="o">)</span>
</span><span class='line'>  Number of program headers:         2
</span><span class='line'>  Size of section headers:           40 <span class="o">(</span>bytes<span class="o">)</span>
</span><span class='line'>  Number of section headers:         18
</span><span class='line'>  Section header string table index: 15
</span></code></pre></td></tr></table></div></figure>


<p>最后我们看一下从磁盘读取内核到内存的方法实现，看看是怎样通过向特定端口发送数据来达到操作磁盘目的的。具体的说明请看代码附带的注释。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// Read a single sector at offset into dst.</span>
</span><span class='line'><span class="c1">// 这里使用的是 LBA 磁盘寻址模式</span>
</span><span class='line'><span class="c1">// LBA是非常单纯的一种寻址模式﹔从0开始编号来定位区块，</span>
</span><span class='line'><span class="c1">// 第一区块LBA=0，第二区块LBA=1，依此类推</span>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">readsect</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">uint</span> <span class="n">offset</span><span class="p">)</span>      <span class="c1">// 0x10000, 1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// Issue command.</span>
</span><span class='line'>  <span class="n">waitdisk</span><span class="p">();</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>                     <span class="c1">// 要读取的扇区数量 count = 1</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F3</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>                <span class="c1">// 扇区 LBA 地址的 0-7 位</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F4</span><span class="p">,</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>           <span class="c1">// 扇区 LBA 地址的 8-15 位</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F5</span><span class="p">,</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>          <span class="c1">// 扇区 LBA 地址的 16-23 位</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F6</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xE0</span><span class="p">);</span> <span class="c1">// offset | 11100000 保证高三位恒为 1</span>
</span><span class='line'>                                      <span class="c1">//         第7位     恒为1</span>
</span><span class='line'>                                      <span class="c1">//         第6位     LBA模式的开关，置1为LBA模式</span>
</span><span class='line'>                                      <span class="c1">//         第5位     恒为1</span>
</span><span class='line'>                                      <span class="c1">//         第4位     为0代表主硬盘、为1代表从硬盘</span>
</span><span class='line'>                                      <span class="c1">//         第3~0位   扇区 LBA 地址的 24-27 位</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F7</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>                  <span class="c1">// 20h为读，30h为写</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Read data.</span>
</span><span class='line'>  <span class="n">waitdisk</span><span class="p">();</span>
</span><span class='line'>  <span class="n">insl</span><span class="p">(</span><span class="mh">0x1F0</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">SECTSIZE</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>运行内核</h2>

<p>内核从磁盘上载入到内存中后 <code>bootmain</code> 函数接下来就准备运行内核中的方法了。我们还是回到 <code>bootmain</code> 函数上来，请注意看我加上的注释说明。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">bootmain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">uchar</span><span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从 0xa0000 到 0xfffff 的物理地址范围属于设备空间，</span>
</span><span class='line'>  <span class="c1">// 所以内核放置在 0x10000 处开始</span>
</span><span class='line'>  <span class="n">elf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="o">*</span><span class="p">)</span><span class="mh">0x10000</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从内核所在硬盘位置读取一内存页 4kb 数据</span>
</span><span class='line'>  <span class="n">readseg</span><span class="p">((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 判断是否为 ELF 文件格式</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">ELF_MAGIC</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>  <span class="c1">// let bootasm.S handle error</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 加载 ELF 文件中的程序段 (ignores ph flags).</span>
</span><span class='line'>  <span class="c1">// 找到内核 ELF 文件的程序头表</span>
</span><span class='line'>  <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proghdr</span><span class="o">*</span><span class="p">)((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span> <span class="o">+</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">phoff</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// 内核 ELF 文件程序头表的结束位置</span>
</span><span class='line'>  <span class="n">eph</span> <span class="o">=</span> <span class="n">ph</span> <span class="o">+</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">phnum</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// 开始将内核 ELF 文件程序头表载入内存</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">;</span>
</span><span class='line'>    <span class="n">readseg</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">off</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// 如果内存大小大于文件大小，用 0 补齐内存空位</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">memsz</span> <span class="o">&gt;</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">)</span>
</span><span class='line'>      <span class="n">stosb</span><span class="p">(</span><span class="n">pa</span> <span class="o">+</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">memsz</span> <span class="o">-</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Call the entry point from the ELF header.</span>
</span><span class='line'>  <span class="c1">// Does not return!</span>
</span><span class='line'>  <span class="c1">// 从内核 ELF 文件入口点开始执行内核</span>
</span><span class='line'>  <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
</span><span class='line'>  <span class="n">entry</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>载入内核后根据 ELF 头表的说明，<code>bootmain</code>函数开始将内核 ELF 文件的程序头表从磁盘载入内存，为运行内核代码做着最后的准备工作。根据上一节的分析我们知道内核的 ELF 文件的程序头表紧跟在 ELF 头表后面，程序头表一共 2 个，每个 32 字节大小，一共是 64 字节，我们继续用十六进制编辑器打开 <code>kernel</code> 内核二进制文件看看程序头表的内容。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">type</th>
<th align="center">off</th>
<th align="center">vaddr</th>
<th align="center">paddr</th>
<th align="center">filesz</th>
<th align="center">memsz</th>
<th align="center">flags</th>
<th align="center">align</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">01 00 00 00</td>
<td align="center">00 10 00 00</td>
<td align="center">00 00 10 80</td>
<td align="center">00 00 10 00</td>
<td align="center">96 B5 00 00</td>
<td align="center">FC 26 01 00</td>
<td align="center">07 00 00 00</td>
<td align="center">00 10 00 00|</td>
</tr>
<tr>
<td></td>
<td align="center">type</td>
<td align="center">off</td>
<td align="center">vaddr</td>
<td align="center">paddr</td>
<td align="center">filesz</td>
<td align="center">memsz</td>
<td align="center">flags</td>
<td align="center">align|</td>
</tr>
<tr>
<td></td>
<td align="center">51 E5 74 64</td>
<td align="center">00 00 00 00</td>
<td align="center">00 00 00 00</td>
<td align="center">00 00 00 00</td>
<td align="center">00 00 00 00</td>
<td align="center">00 00 00 00</td>
<td align="center">07 00 00 00</td>
<td align="center">04 00 00 00|</td>
</tr>
</tbody>
</table>


<ul>
<li>程序头表 1</li>
</ul>


<table>
<thead>
<tr>
<th></th>
<th align="center">字段名称</th>
<th align="center">大小</th>
<th align="center">数值</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">type</td>
<td align="center">4字节</td>
<td align="center">01 00 00 00</td>
<td align="center">可载入的段|</td>
</tr>
<tr>
<td></td>
<td align="center">off</td>
<td align="center">4字节</td>
<td align="center">00 10 00 00</td>
<td align="center">段在文件中的偏移是 4096 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">vaddr</td>
<td align="center">4字节</td>
<td align="center">00 00 10 80</td>
<td align="center">段在内存中的虚拟地址|</td>
</tr>
<tr>
<td></td>
<td align="center">paddr</td>
<td align="center">4字节</td>
<td align="center">00 10 00 00</td>
<td align="center">同段在文件中的偏移量|</td>
</tr>
<tr>
<td></td>
<td align="center">filesz</td>
<td align="center">4字节</td>
<td align="center">96 B5 00 00</td>
<td align="center">段在文件中的大小是 46486 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">memsz</td>
<td align="center">4字节</td>
<td align="center">FC 26 01 00</td>
<td align="center">段在内存中的大小是 75516 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">flags</td>
<td align="center">4字节</td>
<td align="center">07 00 00 00</td>
<td align="center">段的权限是可写、可读、可执行|</td>
</tr>
<tr>
<td></td>
<td align="center">align</td>
<td align="center">4字节</td>
<td align="center">00 10 00 00</td>
<td align="center">段的对齐方式是 4096 字节，即4kb|</td>
</tr>
</tbody>
</table>


<ul>
<li>程序头表 2</li>
</ul>


<table>
<thead>
<tr>
<th></th>
<th align="center">字段名称</th>
<th align="center">大小</th>
<th align="center">数值</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">type</td>
<td align="center">4字节</td>
<td align="center">51 E5 74 64</td>
<td align="center"> PT_GNU_STACK 段|</td>
</tr>
<tr>
<td></td>
<td align="center">off</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">段在文件中的偏移是 0 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">vaddr</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">段在内存中的虚拟地址|</td>
</tr>
<tr>
<td></td>
<td align="center">paddr</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">同段在文件中的偏移量|</td>
</tr>
<tr>
<td></td>
<td align="center">filesz</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">段在文件中的大小是 0 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">memsz</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">段在内存中的大小是 0 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">flags</td>
<td align="center">4字节</td>
<td align="center">07 00 00 00</td>
<td align="center">段的权限是可写、可读、可执行|</td>
</tr>
<tr>
<td></td>
<td align="center">align</td>
<td align="center">4字节</td>
<td align="center">04 00 00 00</td>
<td align="center">段的对齐方式是 4 字节|</td>
</tr>
</tbody>
</table>


<p>同样我们再通过 <code>readelf</code> 命令来验证我们通过十六进制编辑器对内核 ELF 文件的程序头表的分析结果十分正确。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>readelf -l kernel
</span><span class='line'>
</span><span class='line'>Elf file <span class="nb">type </span>is EXEC <span class="o">(</span>Executable file<span class="o">)</span>
</span><span class='line'>Entry point 0x10000c
</span><span class='line'>There are 2 program headers, starting at offset 52
</span><span class='line'>
</span><span class='line'>Program Headers:
</span><span class='line'>  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
</span><span class='line'>  LOAD           0x001000 0x80100000 0x00100000 0x0b596 0x126fc RWE 0x1000
</span><span class='line'>  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4
</span><span class='line'>
</span><span class='line'> Section to Segment mapping:
</span><span class='line'>  Segment Sections...
</span><span class='line'>   00     .text .rodata .stab .stabstr .data .bss
</span><span class='line'>   01
</span></code></pre></td></tr></table></div></figure>


<p>在预备知识里我们讲到 ELF 文件的程序头表描述了程序各个段的情况，所以我们再通过<code>readelf</code>命令看看内核文件都有那些段</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>readelf -S kernel
</span><span class='line'>There are 18 section headers, starting at offset 0x1f600:
</span><span class='line'>
</span><span class='line'>Section Headers:
</span><span class='line'>  <span class="o">[</span>Nr<span class="o">]</span> Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
</span><span class='line'>  <span class="o">[</span> 0<span class="o">]</span>                   NULL            00000000 000000 000000 00      0   0  0
</span><span class='line'>  <span class="o">[</span> 1<span class="o">]</span> .text             PROGBITS        80100000 001000 008111 00  AX  0   0  4
</span><span class='line'>  <span class="o">[</span> 2<span class="o">]</span> .rodata           PROGBITS        80108114 009114 000672 00   A  0   0  4
</span><span class='line'>  <span class="o">[</span> 3<span class="o">]</span> .stab             PROGBITS        80108786 009786 000001 0c  WA  4   0  1
</span><span class='line'>  <span class="o">[</span> 4<span class="o">]</span> .stabstr          STRTAB          80108787 009787 000001 00  WA  0   0  1
</span><span class='line'>  <span class="o">[</span> 5<span class="o">]</span> .data             PROGBITS        80109000 00a000 002596 00  WA  0   0 4096
</span><span class='line'>  <span class="o">[</span> 6<span class="o">]</span> .bss              NOBITS          8010b5a0 00c596 00715c 00  WA  0   0 32
</span><span class='line'>  <span class="o">[</span> 7<span class="o">]</span> .debug_line       PROGBITS        00000000 00c596 001f8c 00      0   0  1
</span><span class='line'>  <span class="o">[</span> 8<span class="o">]</span> .debug_info       PROGBITS        00000000 00e522 00a965 00      0   0  1
</span><span class='line'>  <span class="o">[</span> 9<span class="o">]</span> .debug_abbrev     PROGBITS        00000000 018e87 0026ed 00      0   0  1
</span><span class='line'>  <span class="o">[</span>10<span class="o">]</span> .debug_aranges    PROGBITS        00000000 01b578 0003a0 00      0   0  8
</span><span class='line'>  <span class="o">[</span>11<span class="o">]</span> .debug_loc        PROGBITS        00000000 01b918 002f30 00      0   0  1
</span><span class='line'>  <span class="o">[</span>12<span class="o">]</span> .debug_str        PROGBITS        00000000 01e848 000cdc 01  MS  0   0  1
</span><span class='line'>  <span class="o">[</span>13<span class="o">]</span> .comment          PROGBITS        00000000 01f524 00001c 01  MS  0   0  1
</span><span class='line'>  <span class="o">[</span>14<span class="o">]</span> .debug_ranges     PROGBITS        00000000 01f540 000018 00      0   0  1
</span><span class='line'>  <span class="o">[</span>15<span class="o">]</span> .shstrtab         STRTAB          00000000 01f558 0000a5 00      0   0  1
</span><span class='line'>  <span class="o">[</span>16<span class="o">]</span> .symtab           SYMTAB          00000000 01f8d0 0023d0 10     17 138  4
</span><span class='line'>  <span class="o">[</span>17<span class="o">]</span> .strtab           STRTAB          00000000 021ca0 0012d0 00      0   0  1
</span><span class='line'>Key to Flags:
</span><span class='line'>  W <span class="o">(</span>write<span class="o">)</span>, A <span class="o">(</span>alloc<span class="o">)</span>, X <span class="o">(</span>execute<span class="o">)</span>, M <span class="o">(</span>merge<span class="o">)</span>, S <span class="o">(</span>strings<span class="o">)</span>
</span><span class='line'>  I <span class="o">(</span>info<span class="o">)</span>, L <span class="o">(</span>link order<span class="o">)</span>, G <span class="o">(</span>group<span class="o">)</span>, T <span class="o">(</span>TLS<span class="o">)</span>, E <span class="o">(</span>exclude<span class="o">)</span>, x <span class="o">(</span>unknown<span class="o">)</span>
</span><span class='line'>  O <span class="o">(</span>extra OS processing required<span class="o">)</span> o <span class="o">(</span>OS specific<span class="o">)</span>, p <span class="o">(</span>processor specific<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>结合这两次 <code>readelf</code> 命令的输出我们不难看出，内核文件的 ELF 程序头表中只有第一个是需要被加载的，而这个程序头表指出的加载位置 <code>0x80100000</code> 和内核程序的代码段 <code>.text</code> 的位置是一样的。</p>

<p>而要加载的段是 <code>.text .rodata .stab .stabstr .data .bss</code> ，这些段在内存中的大小总和是<del><code>0x008111 + 0x000672 + 0x000001 + 0x000001 + 0x002596 + 0x00715c = 0x73335</code> 按照对齐要求 <code>0x1000</code> 对齐后为 <code>0x75516</code> 和 ELF 程序头表中的内存大小信息一致</del>（这里特别感谢<a href="https://xuzhenglun.github.io/">@徐正伦同学的指正</a>）<code>0x008111 + 0x000672 + 0x000001 + 0x000001 + 0x002596 + 0x00715c = 73335 即 0x11e77</code> 按照对齐要求 <code>0x1000</code> 对齐后为 <code>75516 即 0x000126fc（注意大小端转换，FC 26 01 00 是按照小端排列的，转换成正常的十六进制数为 0x000126fc）</code> 和 ELF 程序头表中的内存大小信息一致。</p>

<p>我们再算算这些段在文件中的大小，由于这些段在文件中是顺序排列的，所以用 <code>.bss段</code> 的文件偏移量减去 <code>.text段</code> 的文件偏移量 <code>0x00c596 - 0x001000 = 46486</code> 这也是和 ELF 程序头表中段在文件中大小的信息一致。</p>

<h2>内核加载后的系统内存布局</h2>

<p>至此内核已经被载入内存并准备投入运行了。在结束这一篇前我们再看一眼目前状态下系统整体的内存布局，对即将运行的内核环境有一个大致的了解。我们来看几个关键点</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// bootmain.c</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">bootmain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">uchar</span><span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从 0xa0000 到 0xfffff 的物理地址范围属于设备空间，</span>
</span><span class='line'>  <span class="c1">// 所以内核放置在 0x10000 处开始</span>
</span><span class='line'>  <span class="n">elf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="o">*</span><span class="p">)</span><span class="mh">0x10000</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从内核所在硬盘位置读取一内存页 4kb 数据</span>
</span><span class='line'>  <span class="n">readseg</span><span class="p">((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 省略后面的代码......</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由此可知内核被放置在 0x10000 处开始。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='nasm'><span class='line'><span class="err">#</span> <span class="nf">bootasm.S</span>
</span><span class='line'>
</span><span class='line'><span class="nf">.code32</span>  <span class="err">#</span> <span class="nv">Tell</span> <span class="nv">assembler</span> <span class="nv">to</span> <span class="nv">generate</span> <span class="mi">32</span><span class="o">-</span><span class="nv">bit</span> <span class="nv">code</span> <span class="nv">now.</span>
</span><span class='line'><span class="nl">start32:</span>
</span><span class='line'>  <span class="err">#</span> <span class="nf">Set</span> <span class="nv">up</span> <span class="nv">the</span> <span class="nv">protected</span><span class="o">-</span><span class="nv">mode</span> <span class="nv">data</span> <span class="ow">seg</span><span class="nv">ment</span> <span class="nv">registers</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">像上面讲</span> <span class="nf">ljmp</span> <span class="err">时所说的，这时候已经在保护模式下了</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">数据段在</span> <span class="nf">GDT</span> <span class="err">中的下标是</span> <span class="mi">2</span><span class="err">，所以这里数据段的段选择子是</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span> <span class="err">=</span> <span class="mi">0000</span> <span class="mi">0000</span> <span class="mi">0001</span> <span class="mi">0000</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">这</span> <span class="err">16</span> <span class="err">位的段选择子中的前</span> <span class="err">13</span> <span class="err">位是</span> <span class="nf">GDT</span> <span class="err">段表下标，这里前</span> <span class="mi">13</span> <span class="err">位的值是</span> <span class="mi">2</span> <span class="err">代表选择了数据段</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">这里将</span> <span class="err">3</span> <span class="err">个数据段寄存器都赋值成数据段段选择子的值</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="kc">$</span><span class="p">(</span><span class="ow">SEG</span><span class="nv">_KDATA</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span> <span class="o">%</span><span class="nb">ax</span>    <span class="err">#</span> <span class="nv">Our</span> <span class="nv">data</span> <span class="ow">seg</span><span class="nv">ment</span> <span class="nv">selector</span>  <span class="err">段选择子赋值给</span> <span class="nb">ax</span> <span class="err">寄存器</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="o">%</span><span class="nb">ax</span><span class="p">,</span> <span class="o">%</span><span class="nb">ds</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="nb">DS</span><span class="p">:</span> <span class="nv">Data</span> <span class="ow">Seg</span><span class="nv">ment</span>        <span class="err">初始化数据段寄存器</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="o">%</span><span class="nb">ax</span><span class="p">,</span> <span class="o">%</span><span class="nb">es</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="nb">ES</span><span class="p">:</span> <span class="nv">Extra</span> <span class="ow">Seg</span><span class="nv">ment</span>       <span class="err">初始化扩展段寄存器</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="o">%</span><span class="nb">ax</span><span class="p">,</span> <span class="o">%</span><span class="nb">ss</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="nb">SS</span><span class="p">:</span> <span class="nv">Stack</span> <span class="ow">Seg</span><span class="nv">ment</span>       <span class="err">初始化堆栈段寄存器</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="nb">ax</span>                 <span class="err">#</span> <span class="nv">Zero</span> <span class="ow">seg</span><span class="nv">ments</span> <span class="nv">not</span> <span class="nv">ready</span> <span class="nv">for</span> <span class="nv">use</span>  <span class="nb">ax</span> <span class="err">寄存器清零</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="o">%</span><span class="nb">ax</span><span class="p">,</span> <span class="o">%</span><span class="nb">fs</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="nb">FS</span>                      <span class="err">辅助寄存器清零</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="o">%</span><span class="nb">ax</span><span class="p">,</span> <span class="o">%</span><span class="nb">gs</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="nb">GS</span>                      <span class="err">辅助寄存器清零</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">#</span> <span class="nf">Set</span> <span class="nv">up</span> <span class="nv">the</span> <span class="nv">stack</span> <span class="nv">pointer</span> <span class="nv">and</span> <span class="nv">call</span> <span class="nv">into</span> <span class="nv">C.</span>
</span><span class='line'>  <span class="nf">movl</span>    <span class="kc">$</span><span class="nv">start</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>            <span class="err">#</span> <span class="err">栈顶被放置在</span> <span class="mh">0x7C00</span> <span class="err">处，即</span> <span class="kc">$</span><span class="nv">start</span>
</span><span class='line'>  <span class="nf">call</span>    <span class="nv">bootmain</span>
</span></code></pre></td></tr></table></div></figure>


<p>由此可知在执行 <code>bootmain.c</code> 之前 <code>bootasm.S</code> 汇编代码已经将栈的栈顶设置在了 <code>0x7C00</code> 处。之前我们了解过 x86 架构计算机的启动过程，BIOS 会将引导扇区的引导程序加载到 <code>0x7C00</code> 处并引导 CPU 从此处开始运行，故栈顶即被设置在了和引导程序一致的内存位置上。我们知道栈是自栈顶开始向下增长的，所以这里栈会逐渐远离引导程序，所以这里这样安置栈顶的位置并无什么问题。</p>

<p>最后放一张简单的内存布局示意图</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='nasm'><span class='line'><span class="err">0</span><span class="nf">x00000000</span>
</span><span class='line'><span class="err">+------------------------------------------------------------------------—+</span>
</span><span class='line'><span class="err">|</span>        <span class="err">0</span><span class="nf">x7c00</span>      <span class="mh">0x7d00</span>         <span class="mh">0x10000</span>                               <span class="o">|</span>
</span><span class='line'><span class="err">|</span>    <span class="err">栈</span>    <span class="err">|</span>  <span class="err">引导程序</span>  <span class="err">|</span>                <span class="err">|</span>    <span class="err">内核</span>                          <span class="err">|</span>
</span><span class='line'><span class="err">+-------------------------------------------------------------------------+</span>
</span><span class='line'>                                                                 <span class="err">0</span><span class="nf">xffffffff</span>
</span></code></pre></td></tr></table></div></figure>

</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-05-26T14:03:28+08:00" pubdate data-updated="true">2015年5月26日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/cao-zuo-xi-tong/'>操作系统</a>


</div>
	
	<div class="comments"><a href="#disqus_thread">Comments</a></div>
	
	<div>
		<br/>
		
    	<!-- 添加捐赠图标 -->
    <div class ="post-donate">
        <div id="donate_board" class="donate_bar">
            <a id="btn_donate" href="#" title="Donate 打赏"></a>
            <br>
            <span class="donate_txt">如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</span>
            <br>
        </div>  
  
        <div id="donate_guide" class="donate_bar hidden">
            <!-- 支付宝打赏图案 -->
            <img src="http://7rfk33.com1.z0.glb.clouddn.com/my_alipay_pay.JPG" class="mlr5" title="支付宝打赏" >
            <!-- 微信打赏图案 -->
            <img src="http://7rfk33.com1.z0.glb.clouddn.com/my_weixin_pay.JPG" class="mlr5" title="微信打赏">
        </div>
  
        <script type="text/javascript">
        document.getElementById('btn_donate').onclick = function(){
            $('#donate_board').addClass('hidden');
            $('#donate_guide').removeClass('hidden');
        }
        document.getElementById('donate_guide').onclick = function(){
            $('#donate_board').removeClass('hidden');
            $('#donate_guide').addClass('hidden');
        }
        </script>
    </div>
<!-- 添加捐赠图标 -->

  		
	</div>
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		
		
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2017

    leenjewel

<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256882796'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256882796%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'leenjewelgithubio';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://leenjewel.github.io/blog/2015/05/26/%5B%28xue-xi-xv6%29%5D-jia-zai-bing-yun-xing-nei-he/';
        var disqus_url = 'http://leenjewel.github.io/blog/2015/05/26/%5B%28xue-xi-xv6%29%5D-jia-zai-bing-yun-xing-nei-he/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-52061917-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- leenjewel.github.io -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-7743616000257723"
     data-ad-slot="4032598696"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</body>
</html>

<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>leenjewel Blog</title>
	<meta name="author" content="leenjewel">

	
	<meta name="description" content="第一块树莓派的板子还是 2012 年 10 月份入手的，那时候还是 Mod B，700 MHz 的 CPU 和 512 MB 内存。现在已经是树莓派 3 了，时间如白驹过隙啊。当时入手了一块，后来有个朋友想要在家里搞 NAS，忽悠他用树莓派搞，他也买了一块，后来他放弃了， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="leenjewel Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=52606582" charset="UTF-8"></script>
<script type="text/javascript" charset="UTF-8" src="http://lurongkai.github.io/anti-baidu/js/anti-baidu-latest.min.js"></script>

</head>


<body>
	<header id="header" class="inner"><nav id="title-nav">
<h1><a href="/">leenjewel Blog</a></h1>

<h2>Anything about code.</h2>

</nav>
<nav id="main-nav"><ul class="main">
	<li><a href="/">首页</a></li>
	<li><a href="/blog/archives">全部日志</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">首页</a></li>
	<li><a href="/blog/archives">全部日志</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:leenjewel.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		<a class="github" href="https://github.com/leenjewel" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:leenjewel.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/04/11/raspberry-pi-ru-men/">
		
			Raspberry Pi 入门</a>
	</h2>
	<div class="entry-content">
		<p>第一块树莓派的板子还是 2012 年 10 月份入手的，那时候还是 Mod B，700 MHz 的 CPU 和 512 MB 内存。现在已经是树莓派 3 了，时间如白驹过隙啊。当时入手了一块，后来有个朋友想要在家里搞 NAS，忽悠他用树莓派搞，他也买了一块，后来他放弃了，把手里的那块树莓派送给我了，于是我就有了两块树莓派的板子。</p>

<p>其实我也等于是半放弃的状态。用树莓派刷过 <a href="https://kodi.tv/">XBMC</a>(才发现这货也改名叫 Kodi 了，时间如白驹过隙啊) 来当电视盒子玩耍，后来还是买了小米盒子。再后来刷上 Raspbian 系统链接上硬盘准备做远程 BT 下载机，后来买了极路由发现这货就可以满足需求。再再后来闺女出生，拿树莓派接上罗技的摄像头来玩远程监控，然后，就没有然后了，放在书柜里开始吃灰了。</p>

<p>最近想做一些 Web 相关的开发，又把树莓派从书柜里拿了出来，上电后发现能用，于是又折腾起来。也是很久没关注树莓派的发展了，去官网一看，变化还挺大的。晚上花了两三个小时从重新刷系统到布置好整个的运行环境，准备把折腾过程简单总结一下，做个入门教程。</p>

<h2>可能不大适合纯小白入门</h2>

<p>如果你是一名刚刚才接触树莓派的新手，那么这个教程可能并不适合你，主要原因是我不需要图形界面，只通过 SSH + 命令行的方式进行操作。而如果你已经是树莓派圈子的“小鸟”、“老鸟”、“大牛”那么这篇你读来可能也没什么意思，呵呵。</p>

<h2>刷入 Raspbain 系统</h2>

<p>安装方式都有些变化了，有个叫做 <a href="https://www.raspberrypi.org/help/noobs-setup/">NOOBS</a> 的东东成了最佳的安装配置工具。大概了解了一下，主要是图形化安装，集成了众多可以用于树莓派的操作系统，操作简便。不过这个完全不复合我的需求，我不需要图形界面，所以我还是用了传统的镜像刷入方式来弄。</p>

<p>系统选择了最官方的 <a href="https://www.raspberrypi.org/downloads/raspbian/">Raspbian</a> 不过用的是 Lite 版本，还是因为不需要图形界面嘛，所以就不要桌面支持了。下载的是个 ZIP 包，解压之后是个 img 镜像，我是 Mac OS X ，直接用 diskutil + dd 命令将系统刷入 SD 卡，这一步<a href="https://www.raspberrypi.org/documentation/installation/installing-images/mac.md">树莓派官方网站的文档</a>写的很清楚，操作也简单。</p>

<ul>
<li><p>1、将 SD 卡插入电脑，运行 <code>diskutil list</code> 显示出目前已挂在的磁盘。这里假设你的 SD 卡的磁盘 ID 是 <code>disk4</code> 即 <code>/dev/disk4</code></p></li>
<li><p>2、用 <code>diskutil unmountDisk</code> 命令卸载掉已挂载的 SD 卡，例如你的 SD 卡的磁盘 ID 是 <code>disk4</code> 那么就运行：</p></li>
<li><p>&#8220;`
diskutil unmountDisk /dev/disk4</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- 3、用 `dd` 命令将 Raspbian 系统镜像刷入 SD 卡。例如你的 SD 卡的磁盘 ID 是 `disk4` 那么就运行：
</span><span class='line'>
</span><span class='line'>- ```
</span><span class='line'>sudo dd bs=1M if=2016-03-18-raspbian-jessie.img of=/dev/rdisk4</span></code></pre></td></tr></table></div></figure>


<p>稍等片刻 Raspbian 系统就成功刷入 SD 卡了。接下来插上网线，上电开机。</p>

<h2>配置 Raspbain 系统</h2>

<p>我家里的路由器是<a href="http://www.hiwifi.com/j3-view">极路由</a>，其实大多路由器都可以，登录到你的路由器管理界面找到接入到网络的树莓派的内网 IP 地址，然后就可以通过 SSH 来登录了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh pi@192.168.xxx.xxx</span></code></pre></td></tr></table></div></figure>


<p>默认密码是 <code>raspberry</code>。如果你成功登录了树莓派那么就可以开始进行配置了，配置操作也方便的很，一个命令搞定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo raspi-config</span></code></pre></td></tr></table></div></figure>


<p>这个命令会显示一个配置菜单，有不少项目需要配置，我一个一个说。</p>

<h3>1. Expand Filesystem</h3>

<p>这个选项可以让你刚刚刷入的 Raspbian 系统使用 SD 卡上的全部空间。第一步要做这个是因为这个操作需要重启后才能生效。做完后重启树莓派然后通过 SSH 重新登录。如果你的路由器支持，最好设置一下 <a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE">DHCP</a> 给树莓派分配一个固定的 IP 地址。</p>

<h3>2. Change User Password</h3>

<p>修改当前用户 pi 的密码，这个你现在做也可以，之后用命令 <code>password pi</code> 来做也成，总之建议还是改一下密码，毕竟默认密码 <code>raspberry</code> 是众所周知的。</p>

<h3>3. Boot Options</h3>

<p>启动选项，说白了就是开机后是默认进入图形桌面还是进入命令行，我是没有图形桌面的，所以确认选择：</p>

<blockquote><p>B1 Console    Text console, requiring user to login</p></blockquote>

<h3>4. Internationalisation Optins</h3>

<p>这个选项下面需要修改两个子项，<code>locale</code> 和 <code>timezone</code>。</p>

<p><code>locale</code> 我选择了</p>

<blockquote><p><code>en_GB.UTF-8 UTF-8</code></p>

<p><code>en_US ISO-8859-1</code></p>

<p><code>en_US.UTF-8 UTF-8</code></p>

<p><code>zh_CN.UTF-8 UTF-8</code></p>

<p><code>zh_CN GB2312</code></p>

<p><code>zh_CN.GB18030 GB18030</code></p></blockquote>

<p>默认本地化选项我选择了 <code>en_US.UTF-8</code></p>

<p>本地化选项你也完全可以通过编辑 <code>/etc/locale.gen</code> 文件来配置，就是将文件中上述本地化项目的注释去掉即可。如果你通过 <code>/etc/locale.gen</code> 来修改的话，修改完毕后要记得使用命令来更新本地化设置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo locale-gen</span></code></pre></td></tr></table></div></figure>


<p>另外在通过 SSH 登录后你很有可能收到这样的警告：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
</span><span class='line'>-bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
</span><span class='line'>-bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)</span></code></pre></td></tr></table></div></figure>


<p>不要着急，编辑 <code>/etc/locale.conf</code> 文件，做如下设置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LANG=en_US.UTF-8
</span><span class='line'>LC_ALL=en_US.UTF-8</span></code></pre></td></tr></table></div></figure>


<p><code>timezone</code> 时区设置没什么可说的，根据你所在地区做出选择，我选择的是 <code>Asia/Shanghai</code></p>

<h3>5. Add to Rastrack</h3>

<p>这个挺有意思。如果你对隐私什么的没有额外的洁癖，可以打开这个选项。它会将你的树莓派的地理位置和其他全世界使用树莓派的小伙伴们标记在 Google Map 上面，并可以通过 <a href="http://rastrack.co.uk/">rastrack.co.uk</a> 这个网站查看。</p>

<h2>使用无线网卡</h2>

<p>网线大大限制了树莓派的便捷性，给树莓派配上个 USB 的无线网卡就舒服多了。对于无线网卡的选择建议你千万不要盲目，看一下树莓派的<a href="http://elinux.org/RPi_VerifiedPeripherals#USB_Wi-Fi_Adapters">硬件兼容列表</a>再下单也不迟，否则买到不兼容的硬件就呵呵了（我第一次给树莓派购买的 SD 卡就因为不兼容而呵呵了）。我使用的是 <a href="http://item.jd.com/509932.html">EDUP EP-N8508GS黄金版 迷你USB无线网卡</a></p>

<p>插上你购买的 USB 无线网卡，通过运行命令 <code>sudo lsusb</code> 来查看，如果你看到</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Bus 001 Device 004: ID 0bda:8176 Realtek Semiconductor Corp. RTL8188CUS 802.11n WLAN Adapter
</span><span class='line'>Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter
</span><span class='line'>Bus 001 Device 002: ID 0424:9512 Standard Microsystems Corp. LAN9500 Ethernet 10/100 Adapter / SMSC9512/9514 Hub
</span><span class='line'>Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span></code></pre></td></tr></table></div></figure>


<p>能找到标有 <code>802.11n WLAN Adapter</code> 字样，或者运行命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ifconfig -a</span></code></pre></td></tr></table></div></figure>


<p>能看到标有 <code>wlan0</code> 字样，那么恭喜你，说明你的 USB 无线网卡是可用的了。下面我们在做配置。首先是 <code>/etc/network/interfaces</code> 文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>auto lo
</span><span class='line'>iface lo inet loopback
</span><span class='line'>
</span><span class='line'>auto eth0
</span><span class='line'>iface eth0 inet dhcp
</span><span class='line'>
</span><span class='line'>auto wlan0
</span><span class='line'>allow-hotplug wlan0
</span><span class='line'>iface wlan0 inet dhcp
</span><span class='line'>wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf
</span><span class='line'>iface default inet dhcp</span></code></pre></td></tr></table></div></figure>


<p>由于我的设备的内网 IP 都是路由器通过 DHCP 分配的，如果你的不是，那么配置文件的内容是有所不同的。接下来是 <code>/etc/wpa_supplicant/wpa_supplicant.conf</code> 文件，这个文件主要是配置要接入的 wifi 的帐号密码。如果你不确定你要接入的 wifi 的 ssid ，可以使用下面这个命令叫无线网卡扫描一下身边的 wifi 热点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo iwlist wlan0 scan</span></code></pre></td></tr></table></div></figure>


<p>然后配置你的 wifi 接入帐号配置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
</span><span class='line'>update_config=1
</span><span class='line'>
</span><span class='line'>network={
</span><span class='line'>  ssid="wifi-001"
</span><span class='line'>  key_mgmt=WPA-PSK
</span><span class='line'>  psk="wifi-001-password"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>network={
</span><span class='line'>  ssid="wifi-002"
</span><span class='line'>  key_mgmt=WPA-PSK
</span><span class='line'>  psk="wifi-002-password"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上述 wifi 使用的是 WPA/WPA2 加密，这里有几点需要注意的</p>

<ul>
<li><ol>
<li>如果你的 wifi 没有密码，那么 <code>key_mgmt=NONE</code> 并去掉 <code>psk</code></li>
</ol>
</li>
<li><ol>
<li>如果你的 wifi 是 WEP 加密，那么 <code>key_mgmt=NONE</code> 并去掉 <code>psk</code> 加上 <code>wep_key0="wifi-wep-password"</code></li>
</ol>
</li>
</ul>


<p>然后执行下面的命令启动无线网卡</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo ifup wlan0</span></code></pre></td></tr></table></div></figure>


<p>如果命令执行没有报错，那么再进入你的路由器管理后台，如果能看到你的树莓派的无线网卡也已经接入到网络了，那么恭喜你，你可以拔掉网线了，你的树莓派已经拜托了网线的束缚。</p>

<h2>关闭无线网卡的休眠功能</h2>

<p>在使用的过程中我发现经常出现 SSH 无法链接到树莓派，过一会儿又可以链接；树莓派的 HTTP 80 端口经常莫名其妙的就无法访问，然后过一会儿就可以访问。一开始我以为是树莓派不稳定，可是每次无法链接时我去查看路由器后台发现树莓派的网络接入都是正常的，直到后来我才明白，无线网卡默认是可以休眠的。通过下面的命令检查你的无线网卡是否也是自动休眠的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat /sys/module/8192cu/parameters/rtw_power_mgnt</span></code></pre></td></tr></table></div></figure>


<p>如果命令返回值为 <code>1</code> 那么你的无线网卡也是自动休眠的，如果返回的是 <code>0</code> 则没有开启休眠功能。如果是 <code>1</code> 那么你需要手动关闭无线网卡的休眠功能，具体方式是编辑文件 <code>/etc/modprobe.d/8192cu.conf</code>（如果文件不存在则新建）加入如下配置项目</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Disable power saving
</span><span class='line'>options 8192cu rtw_power_mgnt=0</span></code></pre></td></tr></table></div></figure>


<p>重启一下树莓派，然后再次运行 <code>cat /sys/module/8192cu/parameters/rtw_power_mgnt</code> 命令，如果返回值变为了 <code>0</code> 那么你的无线网网卡的休眠功能就被关闭了。这下树莓派的链接就稳定了。</p>

<h2>路由器的端口转发和动态域名解析</h2>

<p>如果你不安于只在内网环境下摆弄树莓派，想要像我一样把树莓派放在家里，到了公司照样可以愉快的玩耍你的树莓派，那么你就需要做端口转发和动态域名解析。当然要能做到这两点，你需要满足</p>

<ul>
<li><p>1、 你的树莓派接入的网络有公网 IP</p></li>
<li><p>2、 你的树莓派接入的路由器支持端口转发，当然能支持动态域名解析就更完美了。</p></li>
</ul>


<p>一般的一级宽带运营商都可以满足第一条，但是有些小的第三方宽带运营商是不行的。像端口转发这种功能一般高级一点儿的路由器都是可以的，或是像小米路由、极路由这种性价比比较不错的路由器也是有的。具体的操作看自己路由器的支持和设置了，这里就不详述了。</p>

<p>到此树莓派的运行环境基本就搭建完毕了，至于接下来要怎么折腾，怎么玩耍，那就看大家的脑洞有多大了，最后祝大家玩的愉快。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-04-11T15:12:41+08:00" pubdate data-updated="true">2016年4月11日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/linux/'>Linux</a>


</div>
	
	<div class="comments"><a href="/blog/2016/04/11/raspberry-pi-ru-men/#disqus_thread">Comments</a></div>
	
	<div>
		<br/><div>如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</div>
		<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="post" target="_blank" accept-charset="GBK" id="alipayForm">
			<input name="optEmail" type="hidden" value="leenjewel@gmail.com" />
			<input name="payAmount" type="hidden" value="1.00" />
			<input id="title" name="title" type="hidden" value="捐赠给 leenjewel.github.io" />
			<input name="memo" type="hidden" value="文章写的不错，我来捐赠鼓励的！" />
			<input name="pay" type="image" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" width="150" height="40">
		</form>
	</div>
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/12/02/ye-shuo-android-apk-da-bao/">
		
			也说 Android Apk 打包</a>
	</h2>
	<div class="entry-content">
		<p>我们在开发 Android 应用程序的时候一般都只需要使用 Eclipse 或是 Android Studio 这样的 IDE 编写好业务逻辑，最终由这些开发工具来协助我们将代码打包生成最终可以在设备上运行的 APK 包。正因为有这些集成度很高的开发工具，我们很少能够接触到 Android APK 包生成的具体流程。</p>

<p>其实如果你 Google 一下“Android apk 打包流程”或者“手动打包 Android apk”，能找到很多介绍 Android APK 打包流程的内容，而我为什么又要再多写一篇呢？是因为这些内容大多只介绍了一个标准的 Android 工程是如何一步步变成 apk 包的，而很少有写一个标准 Android 工程附带依赖几个 Android Library 的情况又是怎样的。要知道在国内的 Android 开发环境下你的产品不接入几个第三方 SDK 你都不好意思出门跟人家到招呼！而往往一个产品根据发放的渠道不同，又要接入不同的第三方 SDK。所以我想从这些方面入手来写这一篇。另外，网上大多数文章都已经有些过时了，例如大多数最后都提到用 <code>apkbuilder</code> 这个脚本来生成最终的 apk 包，而实际上目前最新的 Android SDK 早就已经移除了这个脚本，更改了最终生成 apk 包的方式。</p>

<h2>概述</h2>

<p>一个 Android 工程最后变成 apk 包大概要做这么几件事儿：</p>

<ul>
<li>1、生成 <code>R.java</code> 文件</li>
<li>2、将 <code>.java</code> 文件编译成 <code>.class</code> 文件</li>
<li>3、将 <code>.class</code> 文件打包成 <code>.jar</code> 文件</li>
<li>4、将所有 <code>.jar</code> 文件（包括依赖库）编译成 <code>classes.dex</code> 文件</li>
<li>5、将 <code>assets</code> 和 <code>res</code> 文件夹中所有的资源文件打包成一个 <code>apk</code> 包</li>
<li>6、将 <code>classes.dex</code> 文件添加进 <code>apk</code> 包</li>
<li>7、如果有使用 <code>NDK</code> 技术的话，将生成的 <code>.so</code> 文件添加进 <code>apk</code> 包</li>
<li>8、对 <code>apk</code> 包进行签名</li>
</ul>


<p>说白了一个 apk 包就是由<strong>代码</strong>和<strong>资源</strong>组成的。代码的处理基本上就是编译，这个没什么可说的。我们主要说说资源打包。我们通过亲手实践来理解 apk 生成中的资源处理过程。</p>

<h2>建立试验环境</h2>

<p>找一个空白目录，建立一个标准的 Android 工程，再建立两个标准的 Android Library 工程。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$android</span> create project --activity MainActivity --package com.leenjewel.test --path ./AndroidTestProject -t android-21
</span><span class='line'>
</span><span class='line'><span class="nv">$android</span> create lib-project --package com.leenjewel.test.liba --path ./AndroidLibProjectA -t android-21
</span><span class='line'>
</span><span class='line'><span class="nv">$android</span> create lib-project --package com.leenjewel.test.libb --path ./AndroidLibProjectB -t android-21
</span></code></pre></td></tr></table></div></figure>


<p>怎么样？是不是有些同学连命令行手工建立 Android 工程都是头一次看到啊？可以去刚刚新建好的三个工程的目录看看，其实 Android 的标准工程和 Library 工程并没有什么太大的区别。</p>

<h2>【试验1】第一次生成 R.java 文件</h2>

<p>然后我们切换到刚刚建立的标准 Android 工程的目录下面，准备手工生成 <code>R.java</code> 文件。<code>R.java</code> 文件是什么我就不解释了，这里我们根据主项目和两个 Libary 项目分别生成三个 <code>R.java</code> 文件，后面我们再做解释，先一步一步跟着做。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$aapt</span> package -m -J ./gen -M ./AndroidManifest.xml <span class="se">\</span>
</span><span class='line'>    -S ./res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectA/res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectB/res <span class="se">\</span>
</span><span class='line'>    -I ~/Dev/android-sdk-macosx/platforms/android-21/android.jar<span class="se">\</span>
</span><span class='line'>    --auto-add-overlay
</span><span class='line'>
</span><span class='line'><span class="nv">$aapt</span> package -m -J ./gen -M ../AndroidLibProjectA/AndroidManifest.xml  <span class="se">\</span>
</span><span class='line'>    -S ./res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectA/res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectB/res <span class="se">\</span>
</span><span class='line'>    -I ~/Dev/android-sdk-macosx/platforms/android-21/android.jar<span class="se">\</span>
</span><span class='line'>    --auto-add-overlay <span class="se">\</span>
</span><span class='line'>    --non-constant-id
</span><span class='line'>
</span><span class='line'><span class="nv">$aapt</span> package -m -J ./gen -M ../AndroidLibProjectB/AndroidManifest.xml <span class="se">\</span>
</span><span class='line'>    -S ./res  <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectA/res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectB/res <span class="se">\</span>
</span><span class='line'>    -I ~/Dev/android-sdk-macosx/platforms/android-21/android.jar<span class="se">\</span>
</span><span class='line'>    --auto-add-overlay <span class="se">\</span>
</span><span class='line'>    --non-constant-id
</span></code></pre></td></tr></table></div></figure>


<p>如果三个命令都执行成功的话会在刚刚建立的标准 Android 工程根目录的 <code>gen</code> 目录下根据不同的子目录产生三个 R.java 文件：</p>

<ul>
<li><code>./gen/com/leenjewel/test/R.java</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leenjewel</span><span class="o">.</span><span class="na">test</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">R</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">attr</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">drawable</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ic_launcher</span><span class="o">=</span><span class="mh">0x7f020000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">layout</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">main</span><span class="o">=</span><span class="mh">0x7f030000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">string</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">app_name</span><span class="o">=</span><span class="mh">0x7f040000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>./gen/com/leenjewel/test/liba/R.java</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leenjewel</span><span class="o">.</span><span class="na">test</span><span class="o">.</span><span class="na">liba</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">R</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">attr</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">drawable</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">ic_launcher</span><span class="o">=</span><span class="mh">0x7f020000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">layout</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="o">=</span><span class="mh">0x7f030000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">string</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">app_name</span><span class="o">=</span><span class="mh">0x7f040000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>./gen/com/leenjewel/test/libb/R.java</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leenjewel</span><span class="o">.</span><span class="na">test</span><span class="o">.</span><span class="na">libb</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">R</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">attr</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">drawable</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">ic_launcher</span><span class="o">=</span><span class="mh">0x7f020000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">layout</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="o">=</span><span class="mh">0x7f030000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">string</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">app_name</span><span class="o">=</span><span class="mh">0x7f040000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>【试验1】观测结果：</h3>

<ul>
<li>1、三个 R.java 文件中资源的 ID 相同。</li>
<li>2、三个 R.java 文件的 package 不同。</li>
<li>3、Library 工程生成的 R.java 文件的资源属性没有 final 标识。</li>
</ul>


<p>第一个试验我们得出了三个观测结果，我们的试验继续。通过刚刚生成的三个 R.java 文件不难看出现在这三个工程各自持有的资源是一样的，接下来我们先要给这三个工程加点儿不一样的东西进去。</p>

<h3>特别提示：</h3>

<p>接下来为了更好的观察试验结果，我们可以用熟悉的代码管理工具如 git 或 svn 给主工程 <code>AndroidTestProject</code> 初始化一个代码版本库并进行一次提交，这样通过 diff 我们可以更方便的观察试验变化。</p>

<p>每一个工程的 <code>res/drawable-*/</code> 目录下面都有一个自动生成的 <code>ic_launcher.png</code> 文件，他们的内容都是一样的：“经典的 Android 机器人”。为了区分他们，我们随便用个图片编辑工具在两个 Library 工程的 <code>ic_launcher.png</code> 的小机器人胸前按照它们所属的项目分别打上 <code>A</code> 和 <code>B</code> 两个标签。</p>

<p>然后再分别编辑 <code>res/values/strings.xml</code> 资源文件，加入一些新的字符串节点。</p>

<ul>
<li><code>AndroidTestProject/res/values/strings.xml</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;resources&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;app_name&quot;</span><span class="nt">&gt;</span>MainActivity<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="c">&lt;!-- new!!! --&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;same_thing&quot;</span><span class="nt">&gt;</span>SameP<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;p_thing&quot;</span><span class="nt">&gt;</span>PThing<span class="nt">&lt;/string&gt;</span>
</span><span class='line'><span class="nt">&lt;/resources&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>AndroidLibProjectA/res/vaues/strings.xml</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;resources&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;app_name&quot;</span><span class="nt">&gt;</span>A<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="c">&lt;!-- new!!! --&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;same_thing&quot;</span><span class="nt">&gt;</span>SameA<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;a_thing&quot;</span><span class="nt">&gt;</span>AThing<span class="nt">&lt;/string&gt;</span>
</span><span class='line'><span class="nt">&lt;/resources&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>AndroidLibProjectB/res/values/strings.xml</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;resources&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;app_name&quot;</span><span class="nt">&gt;</span>B<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="c">&lt;!-- new!!! --&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;same_thing&quot;</span><span class="nt">&gt;</span>SameB<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;b_thing&quot;</span><span class="nt">&gt;</span>BThing<span class="nt">&lt;/string&gt;</span>
</span><span class='line'><span class="nt">&lt;/resources&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>做完了这些改变后如果已经给主工程建立了代码库的同学这个时候可以再次提交一下。然后我们准备进行下一个试验。</p>

<p>我们先再次重新生成一下前面刚刚生成过的三个 <code>R.java</code> 文件。生成后可以发现新增加了几个资源 ID，但是我们刚刚观测的结果没变，生成的三个 <code>R.java</code> 文件的资源 ID 依然是一致的。出于篇幅考虑这里就不再放出三个 R.java 文件的内容了，只放了主工程的 R.java 文件内容。</p>

<ul>
<li><code>AndroidTestProject/gen/com/leenjewel/test/R.java</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leenjewel</span><span class="o">.</span><span class="na">test</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">R</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">attr</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">drawable</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ic_launcher</span><span class="o">=</span><span class="mh">0x7f020000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">layout</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">main</span><span class="o">=</span><span class="mh">0x7f030000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">string</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">a_thing</span><span class="o">=</span><span class="mh">0x7f040003</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">app_name</span><span class="o">=</span><span class="mh">0x7f040000</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">b_thing</span><span class="o">=</span><span class="mh">0x7f040002</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">p_thing</span><span class="o">=</span><span class="mh">0x7f040004</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">same_thing</span><span class="o">=</span><span class="mh">0x7f040001</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们修改过资源后重新生成三个 <code>R.java</code> 文件，再次提交，准备新的试验。</p>

<h2>【试验2】改变资源路径顺序重新生成 R.java 文件</h2>

<p>以主工程为例，我们刚刚一直使用的生成主工程 R.java 文件的命令是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$aapt</span> package -m -J ./gen -M ./AndroidManifest.xml <span class="se">\</span>
</span><span class='line'>    -S ./res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectA/res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectB/res <span class="se">\</span>
</span><span class='line'>    -I ~/Dev/android-sdk-macosx/platforms/android-21/android.jar<span class="se">\</span>
</span><span class='line'>    --auto-add-overlay
</span></code></pre></td></tr></table></div></figure>


<p>现在我们调整一下这个命令里 <code>-S</code> 参数的顺序，将 <code>AndroidLibProjectA/res</code> 放在第一，其他不变：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$aapt</span> package -m -J ./gen -M ./AndroidManifest.xml <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectA/res <span class="se">\</span>
</span><span class='line'>    -S ./res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectB/res <span class="se">\</span>
</span><span class='line'>    -I ~/Dev/android-sdk-macosx/platforms/android-21/android.jar<span class="se">\</span>
</span><span class='line'>    --auto-add-overlay
</span></code></pre></td></tr></table></div></figure>


<p>这时再次生成主工程的 <code>R.java</code> 文件看看有什么变化：</p>

<ul>
<li><code>AndroidTestProject/gen/com/leenjewel/test/R.java</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leenjewel</span><span class="o">.</span><span class="na">test</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">R</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">attr</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">drawable</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">ic_launcher</span><span class="o">=</span><span class="mh">0x7f020000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">layout</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">main</span><span class="o">=</span><span class="mh">0x7f030000</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">string</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">a_thing</span><span class="o">=</span><span class="mh">0x7f040004</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">app_name</span><span class="o">=</span><span class="mh">0x7f040000</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">b_thing</span><span class="o">=</span><span class="mh">0x7f040002</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">p_thing</span><span class="o">=</span><span class="mh">0x7f040003</span><span class="o">;</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">same_thing</span><span class="o">=</span><span class="mh">0x7f040001</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>【试验2】观测结果：</h3>

<ul>
<li>1、改变资源路径顺序后 R.java 文件中资源 ID 的值发生了变化。</li>
</ul>


<p>注意，这次我们不提交文件的变动，将主工程还原到调整资源路径顺序之前的状态然后继续我们的试验。</p>

<h2>【试验3】将资源生成 APK 包</h2>

<p>下面我们要将主工程和两个依赖库工程的资源打包，这也是 Android 应用程序 apk 包生成过程中的步骤之一。这里我们直接给出命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$aapt</span> package -f -M AndroidManifest.xml <span class="se">\</span>
</span><span class='line'>    -S ./res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectA/res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectB/res <span class="se">\</span>
</span><span class='line'>    -I ~/Dev/android-sdk-macosx/platforms/android-21/android.jar<span class="se">\</span>
</span><span class='line'>    -F ./out/res.apk <span class="se">\</span>
</span><span class='line'>    --auto-add-overlay
</span></code></pre></td></tr></table></div></figure>


<p>这个命令看上去多多少少和刚刚生成 R.java 的命令有些类似，如果执行顺利的话会在主工程根目录下面的 <code>out</code> 目录下生成一个叫做 <code>res.apk</code> 的包。当然这个包并不能在 Android 设备上运行，这只是个半成品，我们继续。</p>

<p>了解 Android 开发的人都知道 apk 其实就是一个 zip 压缩包，用 zip 解压缩软件就可以进行解压缩操作。但是当我们尝试通过 zip 解压缩我们刚刚生成的 <code>res.apk</code> 后发现里面并不是简简单单的将我们的资源文件直接打包进去而是额外的还做了一些类似于编译的操作，例如我们之前编辑过的 <code>res/values/strings.xml</code> 资源就已经被“编译”成为 <code>resources.arsc</code> 文件的一部分，而诸如 <code>AndroidManifest.xml</code> 这样的文件也不再是明文的我们可以看懂的格式了。</p>

<p>这时我们需要一个工具将我们刚刚生成的这个 <code>res.apk</code> 包“反编译”回来，这个好用的工具就是 <a href="https://ibotpeaches.github.io/Apktool/">apktool</a>，下载这个工具后我们来“反编译”我们的 apk 包：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$java</span> -jar apktool.jar d res.apk
</span></code></pre></td></tr></table></div></figure>


<p>如果执行顺利的话我们在 <code>res.apk</code> 包所在的同级目录下可以看到一个 <code>res</code> 目录，里面就是刚刚通过 apktool 反编译回来的文件，我们重点观察两个文件：</p>

<ul>
<li><code>ic_launcher.png</code> 文件</li>
<li><code>res/values/strings.xml</code> 文件</li>
</ul>


<p>由于之前我们给主工程和两个依赖库工程的 <code>ic_launcher.png</code> 文件做过标记，所以这时候不难看出：</p>

<h3>【试验3】观测结果：</h3>

<ul>
<li>1、<code>res.apk</code> 包中 <code>ic_launcher.png</code> 文件来自 AndroidTestProject 即来自主工程。</li>
<li><p>2、<code>res.apk</code> 包中 <code>res/values/strings.xml</code> 文件的资源 <code>same_thing</code> 和 <code>app_name</code> 的值来自 AndroidTestProject 即来自主工程。</p></li>
<li><p><code>res/values/strings.xml</code> 文件</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;resources&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;app_name&quot;</span><span class="nt">&gt;</span>MainActivity<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;same_thing&quot;</span><span class="nt">&gt;</span>SameP<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;b_thing&quot;</span><span class="nt">&gt;</span>BThing<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;a_thing&quot;</span><span class="nt">&gt;</span>AThing<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;p_thing&quot;</span><span class="nt">&gt;</span>PThing<span class="nt">&lt;/string&gt;</span>
</span><span class='line'><span class="nt">&lt;/resources&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>不用提交任何代码，我们试验继续。</p>

<h2>【试验4】改变资源路径顺序重新生成 APK 包</h2>

<p>把刚刚第一次生成的 <code>res.apk</code> 和用 apktool 反编译出来的 <code>res</code> 目录都删掉。为了方便对比，再看一眼刚刚用来生成 apk 的命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$aapt</span> package -f -M AndroidManifest.xml <span class="se">\</span>
</span><span class='line'>    -S ./res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectA/res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectB/res <span class="se">\</span>
</span><span class='line'>    -I ~/Dev/android-sdk-macosx/platforms/android-21/android.jar<span class="se">\</span>
</span><span class='line'>    -F ./out/res.apk <span class="se">\</span>
</span><span class='line'>    --auto-add-overlay
</span></code></pre></td></tr></table></div></figure>


<p>然后我们依然是调整一下 <code>-S</code> 命令参数的顺序和刚才一样我们把主工程的 <code>res</code> 目录和依赖库工程 AndroidLibProjectA 的 <code>res</code> 目录调换顺序再生成一下 apk 包看看：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$aapt</span> package -f -M AndroidManifest.xml <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectA/res <span class="se">\</span>
</span><span class='line'>    -S ./res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectB/res <span class="se">\</span>
</span><span class='line'>    -I ~/Dev/android-sdk-macosx/platforms/android-21/android.jar<span class="se">\</span>
</span><span class='line'>    -F ./out/res.apk <span class="se">\</span>
</span><span class='line'>    --auto-add-overlay
</span></code></pre></td></tr></table></div></figure>


<p>重新生成新的 <code>res.apk</code> 包之后我们还是用 apktool 将包进行反编译然后观察：</p>

<h3>【试验4】观测结果：</h3>

<ul>
<li>1、<code>res.apk</code> 包中 <code>ic_launcher.png</code> 文件来自 AndroidLibProjectA 即来自依赖库 A 工程。</li>
<li><p>2、<code>res.apk</code> 包中 <code>res/values/strings.xml</code> 文件的资源 <code>same_thing</code> 和 <code>app_name</code> 的值来自 AndroidLibProjectA 即来自依赖库 A 工程。</p></li>
<li><p><code>res/values/strings.xml</code> 文件</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;resources&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;app_name&quot;</span><span class="nt">&gt;</span>A<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;same_thing&quot;</span><span class="nt">&gt;</span>SameA<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;b_thing&quot;</span><span class="nt">&gt;</span>BThing<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;p_thing&quot;</span><span class="nt">&gt;</span>PThing<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>    <span class="nt">&lt;string</span> <span class="na">name=</span><span class="s">&quot;a_thing&quot;</span><span class="nt">&gt;</span>AThing<span class="nt">&lt;/string&gt;</span>
</span><span class='line'><span class="nt">&lt;/resources&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你觉得意犹未尽那么可以尝试再次调整资源路径顺序，这次把依赖库 B 工程的资源目录的顺序放在最前面然后重复试验 4 的步骤再次生成 <code>res.apk</code> 包并使用 apktool 反编译之后观察试验结果。而我们不打算再这么做了，因为结果已经很明确了。</p>

<p>试验就暂时做到这，接下来我们说说通过这四个无聊的小试验我们了解到了什么。</p>

<p>细心的同学相比已经有结论了。如果单单只是一个 Android 标准工程的资源打包的话那就轻松很多了，直接一个命令就搞定。而附带诸多 Library 工程依赖的话就要考虑资源的合并问题了，而资源合并过程中主要要处理的就是同名资源问题。通过我们做过的试验我们可以得出一个结论即：</p>

<blockquote><p><strong>Android 的资源打包过程中对于资源特别是同名资源的处理只和资源路径的先后顺序有关系，只要资源路径顺序不变，在 R.java 文件中生成的资源引用 ID 就不变</strong>。</p></blockquote>

<p>资源打包的事情就说到这里。顺带提一句，上面的试验中并没有出现 <code>assets</code> 资源文件打包的情况，其实 <code>assets</code> 资源文件打包和 <code>res</code> 资源文件打包的原理和规则都是一样的，加上 <code>assets</code> 资源打包的命令看起来大概是这个样子的</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$aapt</span> package -f -M AndroidManifest.xml <span class="se">\</span>
</span><span class='line'>    -A ./assets <span class="se">\</span>
</span><span class='line'>    -A ../AndroidLibProjectA/assets <span class="se">\</span>
</span><span class='line'>    -A ../AndroidLibProjectB/assets <span class="se">\</span>
</span><span class='line'>    -S ./res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectA/res <span class="se">\</span>
</span><span class='line'>    -S ../AndroidLibProjectB/res <span class="se">\</span>
</span><span class='line'>    -I ~/Dev/android-sdk-macosx/platforms/android-21/android.jar<span class="se">\</span>
</span><span class='line'>    -F ./out/res.apk <span class="se">\</span>
</span><span class='line'>    --auto-add-overlay
</span></code></pre></td></tr></table></div></figure>


<p><code>assets</code> 资源文件对于同名文件资源的合并处理规则也是和资源路径顺序有关。</p>

<h2>编译源代码</h2>

<ul>
<li>编译 java</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>javac -target 1.7  -source 1.7 <span class="se">\</span>
</span><span class='line'>    -d  ./bin <span class="se">\</span>
</span><span class='line'>    -bootclasspath  ~/Dev/android-sdk-macosx/platforms/android-21/android.jar <span class="se">\</span>
</span><span class='line'>    -classpath ./libs/lib1.jar:./libs/lib2.jar:./libs/lib3.jar <span class="se">\</span>
</span><span class='line'>    ./src/com/package/your/xxxx.java <span class="se">\</span>
</span><span class='line'>    ./src/com/package/your/xxxxx.java <span class="se">\</span>
</span><span class='line'>    ./src/com/package/your/xxxxxx.java
</span><span class='line'>    ....
</span></code></pre></td></tr></table></div></figure>


<p>这里要说的是 Android Library 工程和 Android 主工程的源代码是分开编译的。因为主工程中的代码是依赖 Library 工程的，所以要将所有 Library 工程编译并生成 <code>jar</code> 文件，然后再编译主工程时将所有 Library 工程的 <code>jar</code> 引入 <code>classpath</code> 中。</p>

<p>主工程编译的时候记得要连同之前生成在 <code>gen</code> 文件夹中的 <code>R.java</code> 文件和 <code>src</code> 文件夹下面的所有源代码一起编译。</p>

<ul>
<li>生成 jar</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>jar  cvf  ./bin/classes.jar <span class="se">\</span>
</span><span class='line'>    -C ./bin  .
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>生成 dex</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>dx  --dex <span class="se">\</span>
</span><span class='line'>    --output  ./bin/classes.dex <span class="se">\</span>
</span><span class='line'>    ./bin/classes.jar <span class="se">\</span>
</span><span class='line'>    ./libs/lib1.jar <span class="se">\</span>
</span><span class='line'>    ./libs/lib2.jar <span class="se">\</span>
</span><span class='line'>    ./libs/lib3.jar <span class="se">\</span>
</span><span class='line'>    ../AndroidLibProjectA/libs/lib1.jar <span class="se">\</span>
</span><span class='line'>    ../AndroidLibProjectA/libs/lib2.jar <span class="se">\</span>
</span><span class='line'>    ../AndroidLibProjectB/libs/lib1.jar <span class="se">\</span>
</span><span class='line'>    ../AndroidLibProjectB/libs/lib2.jar
</span><span class='line'>    ......
</span></code></pre></td></tr></table></div></figure>


<p>这样所有的 Java 代码和依赖库就全部被编译成最终 Android apk 中要用到的 <code>classes.dex</code> 文件了。</p>

<h2>生成最终的 apk 包</h2>

<ul>
<li>添加 classes.dex 文件</li>
</ul>


<p>然后我们把生成的 <code>classes.dex</code> 文件丢进刚刚生成的资源 apk 包里。原本这步是通过 <code>apkbuilder</code> 脚本来做的，现在 Google 统一改成用 <code>aapt</code> 命令来做了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nb">cd</span> ./bin
</span><span class='line'>aapt add ../out/res.apk  classes.dex
</span></code></pre></td></tr></table></div></figure>


<p>这里需要注意的是 <code>classes.dex</code> 文件前面一定不要加额外的路径，如果加了路径那么这些路径会一并带进 apk 包里。而 Android apk 包里的 <code>classes.dex</code> 文件是直接放进包里面的，不能带路径。</p>

<ul>
<li>添加 .so 文件</li>
</ul>


<p>如果你使用了 NDK 技术或者有库依赖，那也需要将这些依赖的 <code>.so</code> 文件添加进 apk 包，方法和添加 <code>classes.dex</code> 一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$aapt</span> add res.apk lib/armeabi/xxx.so
</span></code></pre></td></tr></table></div></figure>


<p>据说 Windows 环境下执行上述 <code>aapt add</code> 命令时路径也要用类 Unix 系统的斜杠而不能用 Windows 的反斜杠，我手边没有 Windows 环境没有亲自尝试。</p>

<ul>
<li>签名</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>jarsigner  -digestalg  SHA1 <span class="se">\</span>
</span><span class='line'>    -sigalg  MD5withRSA <span class="se">\</span>
</span><span class='line'>    -verbose <span class="se">\</span>
</span><span class='line'>    -keystore  /your/keystore/file/path/xxxx.keystore <span class="se">\</span>
</span><span class='line'>    -storepass  xxxxxxxx <span class="se">\</span>
</span><span class='line'>    -keypass  xxxxxxxx <span class="se">\</span>
</span><span class='line'>    -signedjar  ./out/res.signed.apk <span class="se">\</span>
</span><span class='line'>    ./out/res.apk  <span class="s2">&quot;your keystore alias&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>优化 apk 包</li>
</ul>


<p>这是 Google 官方文档提到的将 apk 包文件做一下对齐操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>zipalign  -f  4  ./out/res.signed.apk  ./out/your.final.apk
</span></code></pre></td></tr></table></div></figure>


<p>至此一个可放在 Android 设备上运行的 apk 包就成功的生成了。</p>

<h2>Android 第三方库的集成方式</h2>

<p>前面也说了在国内特殊的 Android 开发环境下你的 Android 应用不接入几个第三方 SDK 你出门都不好意思和别人打招呼。甚至有时我们为了针对各种不同的渠道，一个 Android 应用程序出包时要不停的切换各种第三方 SDK 依赖，想必搞过 Android 开发的人都知道这是个很头疼的问题。</p>

<p>有了前面针对 Android apk 打包流程的介绍，我们最后再来探讨一下 Android 出包，特别是接入各种第三方 SDK ，针对不同渠道切换不同依赖出包的更为灵活的方式的思路。</p>

<h3>【集成方式1】以标准 Android Library Project 方式集成</h3>

<p>我们一般在使用自己内部开发的一些公共库或公共组件时会选用这种方式。所有的资源和代码都以标准的 Android Library Porject 的形式呈现，开发应用时只需要声明引用这些库工程即可。</p>

<p>通过刚刚的试验我们知道只要引入资源的路径顺序不变，主工程和依赖库工程所生成的 <code>R.java</code> 文件中资源 ID 的值是一样的。所以在开发依赖库工程时，在依赖库工程中通过自己的 R 类来引用资源写好的逻辑代码在主工程中同样是可以正常工作的。</p>

<h3>【集成方式2】依赖库通过复制粘贴进主工程的方式集成</h3>

<p>如果我们开发的库要发布给第三方使用的时候，一般会将代码混淆打包成 <code>jar</code> 文件连同资源文件一起发送给第三方。第三方拿到这样形式的 SDK 后一般会通过复制粘贴的方式将资源文件拷贝进主工程的 <code>res</code> 或 <code>assets</code> 文件夹内，将 <code>jar</code> 包拷贝进主工程的 <code>libs</code> 文件夹内。</p>

<p>这时由于库使用的资源文件是直接放置在主工程中的，所以最终生成的资源 ID 是不同的。存在于第三方库 <code>jar</code> 包中的库逻辑如果还是按照 R 类来引用资源的话就不行了。因为库逻辑是不可能预先知道主工程的包名的，这时只能通过 Java 的“反射”机制来进行资源引用了。举个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">int</span> <span class="nf">getResId</span><span class="o">(</span><span class="n">String</span> <span class="n">resType</span><span class="o">,</span> <span class="n">String</span> <span class="n">resName</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Class</span> <span class="n">localClass</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">getPackageName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;.R$&quot;</span> <span class="o">+</span> <span class="n">resType</span><span class="o">);</span>
</span><span class='line'>      <span class="n">Field</span> <span class="n">localField</span> <span class="o">=</span> <span class="n">localClass</span><span class="o">.</span><span class="na">getField</span><span class="o">(</span><span class="n">resName</span><span class="o">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">localField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">localField</span><span class="o">.</span><span class="na">getName</span><span class="o">()).</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NoSuchFieldException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// TODO Auto-generated catch block</span>
</span><span class='line'>      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是个通过 Java “反射”机制查找资源 ID 的方法。一般我们引用资源时会这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Button</span> <span class="n">btn</span> <span class="o">=</span> <span class="o">(</span><span class="n">Button</span><span class="o">)</span><span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">btn1</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>而在这种方式引入的依赖库中一般会通过上述的自有方法来获取资源 ID</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Button</span> <span class="n">btn</span> <span class="o">=</span> <span class="o">(</span><span class="n">Button</span><span class="o">)</span><span class="n">findViewById</span><span class="o">(</span><span class="n">getResId</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">,</span> <span class="s">&quot;btn1&quot;</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<h3>【集成方式3】通过二次打包的方式集成</h3>

<p>其实说到针对不同渠道不同第三方 SDK 依赖出包的问题，很多同学首先想到的就是使用如  <a href="http://www.anysdk.com">AnySDK</a> 这样的一整套解决方案。使用这种方案你只需要在你的主项目中薄薄的接入一层 AnySDK 的中间层 SDK 依赖，然后将你生成的 apk 包交给 AnySDK 的客户端，通过 UI 界面选择好你需要的第三方 SDK 依赖，然后等待进度条走完之后一个复合你要求的渠道包就生成出来了。</p>

<p>可是在你享受这种方便的时候是否思考过它是<strong>如何实现</strong>的呢？</p>

<p>当你依赖的第三方 SDK 并不在 AnySDK 这种解决方案提供商的支持之列，而支持计划遥遥无期的时候，当你生成的渠道包发生问题去寻求 AnySDK 的反馈而没有响应时，你是否咬牙切齿的想要自己也搞这么一套方便的解决方案把一切<strong>掌控在自己手中</strong>呢？</p>

<p>这里就告诉你它们所使用的是什么样的<strong>黑科技</strong>。</p>

<p>其实了解了 Android apk 的打包原理后，只要稍稍想一想就会明白所谓的黑科技也并不是什么复杂的东西，无非是：</p>

<ul>
<li><p>建立统一的接口规范，将各个第三方 SDK 的调用方式统一化、规范化。</p></li>
<li><p>将各个第三方 SDK 按照统一接口规范做一次二次封装，使其暴露的对外调用接口统一。</p></li>
<li><p>只将薄薄的一层统一调用接入标准工程项目中，排除了各种第三方依赖。</p></li>
<li><p>通过二次打包的方式将所需的各个第三方 SDK 打进 apk 包。</p></li>
<li><p>最后运行时通过动态加载技术经过统一的接口调用各个第三方 SDK。</p></li>
</ul>


<p>这里的重点在于二次打包。当然不排除各家类 AnySDK 解决方案提供商有各家的方式方法，不过大概的原理是相通的。</p>

<ul>
<li><p>用类似 <a href="https://ibotpeaches.github.io/Apktool/">apktool</a> 这样的工具将原 apk 包解包。</p></li>
<li><p>通过 <code>aapk</code> 工具将各个第三方 SDK 中的资源合并，重新生成 R.java 并编译成 R.class 文件替换原包中的 R.class 文件，然后根据各个第三方 SDK 的包路径不同对应生成各个包下的 R.java 文件。</p></li>
<li><p>将新生成的各个 class 文件和各个第三方 SDK 中的依赖 jar 包和原 apk 包中的 class 文件一起重新编译成 <code>classes.dex</code> 文件。</p></li>
<li><p>最后重新打包成新的 apk 然后重新签名一次即可。</p></li>
</ul>


<h2>最后的广告时间</h2>

<p><a href="https://github.com/leenjewel/mysdk">MySDK</a> 项目就是我仿照 AnySDK 这样的解决方案实现的一套框架。虽然还没有完工，但基本该有的东西都有了：</p>

<ul>
<li><p>统一接口的中间层 C++、Java、Objective-C、Cocos2d-x Lua 语言层面的调用支持。</p></li>
<li><p>基于 Web 和基于命令行的二次打包工具</p></li>
</ul>


<p>有兴趣的同学可以 clone 下来玩玩。附上简单玩法：</p>

<p>提前部署好你的 Android 环境。Android SDK 一定要有，并且要定义一个环境变量 <code>$ANDROID_SDK_ROOT</code> 指明 Android SDK 的位置。JDK 要安装这个更不用说了，还有 Python 环境。</p>

<p>Web 二次打包工具基于 Python 的 <a href="http://www.tornadoweb.org">Tornado Web Framework</a> 所以请先自行安装。然后：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">$git</span> <span class="n">clone</span> <span class="n">git</span><span class="nd">@github.com</span><span class="o">:</span><span class="n">leenjewel</span><span class="o">/</span><span class="n">mysdk</span><span class="o">.</span><span class="na">git</span>
</span><span class='line'>
</span><span class='line'><span class="n">$cd</span> <span class="n">mysdk</span>
</span><span class='line'>
</span><span class='line'><span class="n">$cd</span> <span class="n">apk</span><span class="o">.</span><span class="na">builder</span>
</span><span class='line'>
</span><span class='line'><span class="n">$python</span> <span class="n">setup</span><span class="o">.</span><span class="na">py</span> <span class="n">install</span>
</span><span class='line'>
</span><span class='line'><span class="n">$python</span> <span class="n">mysdk</span><span class="o">.</span><span class="na">py</span> <span class="n">start</span><span class="o">-</span><span class="n">server</span> <span class="err">\</span>
</span><span class='line'>    <span class="o">--</span><span class="n">server</span><span class="o">-</span><span class="n">config</span> <span class="o">./../</span><span class="n">example</span><span class="o">/</span><span class="n">apk_build_test</span><span class="o">/</span><span class="n">mysdk_web_server</span><span class="o">/</span><span class="n">settings</span><span class="o">.</span><span class="na">py</span> <span class="err">\</span>
</span><span class='line'>    <span class="o">--</span><span class="n">with</span><span class="o">-</span><span class="n">port</span> <span class="mi">8080</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果命令执行成功的话，直接打开浏览器访问 <a href="http://localhost:8080/index">http://localhost:8080/index</a> 就可以看到二次打包工具的 Web UI 界面了。</p>

<p>先新建一个工作空间(workspace)，点击 <code>New Workspace</code> 按钮新建好工作空间后继续点击 <code>Go To Workspace</code> 按钮进入新建好的工作空间。</p>

<p>在新建好的工作空间中点击 <code>New Project</code> 按钮新建一个二次打包项目。这里需要注意的是：</p>

<ul>
<li><p>APK File 文件选择 <code>example/apk_build_test/MySDKAPPExample.apk</code></p></li>
<li><p>APK Package Name 填写 <code>com.leenjewel.mysdk.appexample</code></p></li>
<li><p>Keystore File 文件选择 <code>example/android/MySDKAPPExample/keystore</code> 文件</p></li>
<li><p>Store Password 和 Key Password 都填写 <code>com.leenjewel.mysdk</code></p></li>
<li><p>Alias 填写 mysdk</p></li>
<li><p><code>aexamplesdk</code> 点击 <code>Add SDK</code> 按钮添加，<code>metadata_val_1</code> 的值随便填写，这表示二次打包将这个名叫 <code>aexamplesdk</code> 的第三方 SDK 加入到原包中。</p></li>
</ul>


<p>接着点击 <code>Create Project</code> 按钮完成二次打包项目的创建。</p>

<p>最后点击 <code>Build Project</code> 按钮进入到二次打包界面，再次确认项目配置填写无误的话直接点击二次打包界面里的 <code>Build Project</code> 按钮就开始二次打包操作了。</p>

<p>祝玩的愉快。如遇到问题欢迎和我讨论。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-12-02T18:29:48+08:00" pubdate data-updated="true">2015年12月2日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/android/'>android</a>


</div>
	
	<div class="comments"><a href="/blog/2015/12/02/ye-shuo-android-apk-da-bao/#disqus_thread">Comments</a></div>
	
	<div>
		<br/><div>如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</div>
		<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="post" target="_blank" accept-charset="GBK" id="alipayForm">
			<input name="optEmail" type="hidden" value="leenjewel@gmail.com" />
			<input name="payAmount" type="hidden" value="1.00" />
			<input id="title" name="title" type="hidden" value="捐赠给 leenjewel.github.io" />
			<input name="memo" type="hidden" value="文章写的不错，我来捐赠鼓励的！" />
			<input name="pay" type="image" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" width="150" height="40">
		</form>
	</div>
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/11/11/%5B%28xue-xi-xv6%29%5D-nei-he-gai-lan/">
		
			【学习Xv6】 内核概览</a>
	</h2>
	<div class="entry-content">
		<h2>前情提要</h2>

<p>上一篇<a href="http://leenjewel.github.io/blog/2015/05/26/%5B%28xue-xi-xv6%29%5D-jia-zai-bing-yun-xing-nei-he/">《【学习Xv6】加载并运行内核》</a>讲到内核已经成功加载到内存中开始运行了。内核可以说是一个操作系统最核心的部件了，所以涉及要讲的内容非常非常多，我们先缓一缓脚步，对内核有一个大致的了解然后在细细的去品味它。</p>

<h2>内核的组成</h2>

<p>要想知道内核里都有些什么还是要从 <code>Makefile</code> 入手看看组成内核都使用了那些源码文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>kernel: $(OBJS) entry.o entryother initcode kernel.ld
</span><span class='line'>    $(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
</span><span class='line'>    $(OBJDUMP) -S kernel &gt; kernel.asm
</span><span class='line'>    $(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; kernel.sym</span></code></pre></td></tr></table></div></figure>


<p>而 <code>$(OBJS)</code> 变量由于内容较多我们只列出其中的一部分</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OBJS = \
</span><span class='line'>  bio.o\
</span><span class='line'>  console.o\
</span><span class='line'>  exec.o\
</span><span class='line'>  file.o\
</span><span class='line'>  fs.o\
</span><span class='line'>  ide.o\
</span><span class='line'>  ioapic.o\
</span><span class='line'>  kalloc.o\
</span><span class='line'>  ......</span></code></pre></td></tr></table></div></figure>


<p>从这些 <code>.o</code> 文件的文件名不难看出这些都是内核基本功能的组成部分，这也是我们以后研究的重点，既然这篇是概览我们暂时先不去关心这些组件。</p>

<p>除去组件剩下的文件就只有这几个：<code>entry.S</code>、<code>initcode.S</code> 和 <code>entryother.S</code> 而这几个文件我们要从哪一个先入手呢？这要听 <code>kernel.ld</code> 文件的，因为链接器在链接生成最终的内核时也是听 <code>kernel.ld</code> 文件的安排的。</p>

<p><code>.ld</code> 文件是链接器配置文件或者叫链接脚本，它有自己的一套语法，链接器最终会根据链接器配置文件中的规则来生成最终的二进制文件。这里我们就不做具体的语法介绍了，有兴趣的同学请自行 Google 吧，我们只解释一下几个关键点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Simple linker script for the JOS kernel.
</span><span class='line'>   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
</span><span class='line'>
</span><span class='line'>OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
</span><span class='line'>OUTPUT_ARCH(i386)
</span><span class='line'>ENTRY(_start)
</span><span class='line'>
</span><span class='line'>SECTIONS
</span><span class='line'>{
</span><span class='line'>  /* Link the kernel at this address: "." means the current address */
</span><span class='line'>        /* Must be equal to KERNLINK */
</span><span class='line'>  . = 0x80100000;
</span><span class='line'>
</span><span class='line'>  .text : AT(0x100000) {
</span><span class='line'>      *(.text .stub .text.* .gnu.linkonce.t.*)
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>      /* Adjust the address for the data segment to the next page */
</span><span class='line'>  . = ALIGN(0x1000);
</span><span class='line'>
</span><span class='line'>    // ......
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里只关注四点：</p>

<ul>
<li><code>ENTRY(_start)</code> 　内核的代码为段执行入口：_start</li>
<li><code>. = 0x80100000</code> 内核的起始虚拟地址位置为：0x80100000</li>
<li><code>.text : AT(0x100000)</code> 内核代码段的内存装载地址为：0x100000</li>
<li><code>. = ALIGN(0x1000)</code> 内核代码段保证 4KB 对齐</li>
</ul>


<p>关于内核起始虚拟地址的问题我们后面遇到了再来说，代码段内存装载地址 <code>0x100000</code> 是不是看着眼熟？没错了，我们在上一篇<a href="http://leenjewel.github.io/blog/2015/05/26/%5B%28xue-xi-xv6%29%5D-jia-zai-bing-yun-xing-nei-he/">《【学习Xv6】加载并运行内核》</a>最后讲到 <code>bootmain.c</code> 文件加载并运行内核时看到过，这里再把上一篇的代码列出来大家回顾一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// bootmain.c</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">bootmain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">uchar</span><span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从 0xa0000 到 0xfffff 的物理地址范围属于设备空间，</span>
</span><span class='line'>  <span class="c1">// 所以内核放置在 0x10000 处开始</span>
</span><span class='line'>  <span class="n">elf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="o">*</span><span class="p">)</span><span class="mh">0x10000</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从内核所在硬盘位置读取一内存页 4kb 数据</span>
</span><span class='line'>  <span class="n">readseg</span><span class="p">((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 省略后面的代码......</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>正式因为链接脚本强制规定了内核代码段在内存中的位置才保证了引导区程序可以顺利的按照约定的地址去引导 CPU 执行内核代码。</p>

<h2>内核引导</h2>

<p>既然知道了内核的入口点是 <code>_start</code> 通过简单的文本搜索不难找到这个入口点在 <code>entry.S</code> 文件中，我们直接先列出代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;asm.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;memlayout.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;mmu.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;param.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># Multiboot header.  Data to direct multiboot loader.</span>
</span><span class='line'><span class="p">.</span><span class="n">p2align</span> <span class="mi">2</span>
</span><span class='line'><span class="p">.</span><span class="n">text</span>
</span><span class='line'><span class="p">.</span><span class="n">globl</span> <span class="n">multiboot_header</span>
</span><span class='line'><span class="nl">multiboot_header:</span>
</span><span class='line'>  <span class="err">#</span><span class="n">define</span> <span class="n">magic</span> <span class="mh">0x1badb002</span>
</span><span class='line'>  <span class="err">#</span><span class="n">define</span> <span class="n">flags</span> <span class="mi">0</span>
</span><span class='line'>  <span class="p">.</span><span class="kt">long</span> <span class="n">magic</span>
</span><span class='line'>  <span class="p">.</span><span class="kt">long</span> <span class="n">flags</span>
</span><span class='line'>  <span class="p">.</span><span class="kt">long</span> <span class="p">(</span><span class="o">-</span><span class="n">magic</span><span class="o">-</span><span class="n">flags</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># By convention, the _start symbol specifies the ELF entry point.</span>
</span><span class='line'><span class="cp"># Since we haven&#39;t set up virtual memory yet, our entry point is</span>
</span><span class='line'><span class="cp"># the physical address of &#39;entry&#39;.</span>
</span><span class='line'><span class="p">.</span><span class="n">globl</span> <span class="n">_start</span>
</span><span class='line'><span class="n">_start</span> <span class="o">=</span> <span class="n">V2P_WO</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># Entering xv6 on boot processor, with paging off.</span>
</span><span class='line'><span class="p">.</span><span class="n">globl</span> <span class="n">entry</span>
</span><span class='line'><span class="nl">entry:</span>
</span><span class='line'>  <span class="err">#</span> <span class="n">Turn</span> <span class="n">on</span> <span class="n">page</span> <span class="n">size</span> <span class="n">extension</span> <span class="k">for</span> <span class="mi">4</span><span class="n">Mbyte</span> <span class="n">pages</span>
</span><span class='line'>  <span class="n">movl</span>    <span class="o">%</span><span class="n">cr4</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">orl</span>     <span class="err">$</span><span class="p">(</span><span class="n">CR4_PSE</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">movl</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr4</span>
</span><span class='line'>  <span class="err">#</span> <span class="n">Set</span> <span class="n">page</span> <span class="n">directory</span>
</span><span class='line'>  <span class="n">movl</span>    <span class="err">$</span><span class="p">(</span><span class="n">V2P_WO</span><span class="p">(</span><span class="n">entrypgdir</span><span class="p">)),</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">movl</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr3</span>
</span><span class='line'>  <span class="err">#</span> <span class="n">Turn</span> <span class="n">on</span> <span class="n">paging</span><span class="p">.</span>
</span><span class='line'>  <span class="n">movl</span>    <span class="o">%</span><span class="n">cr0</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">orl</span>     <span class="err">$</span><span class="p">(</span><span class="n">CR0_PG</span><span class="o">|</span><span class="n">CR0_WP</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">movl</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr0</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">#</span> <span class="n">Set</span> <span class="n">up</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span><span class="p">.</span>
</span><span class='line'>  <span class="n">movl</span> <span class="err">$</span><span class="p">(</span><span class="n">stack</span> <span class="o">+</span> <span class="n">KSTACKSIZE</span><span class="p">),</span> <span class="o">%</span><span class="n">esp</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">#</span> <span class="n">Jump</span> <span class="n">to</span> <span class="n">main</span><span class="p">(),</span> <span class="n">and</span> <span class="k">switch</span> <span class="n">to</span> <span class="n">executing</span> <span class="n">at</span>
</span><span class='line'>  <span class="err">#</span> <span class="n">high</span> <span class="n">addresses</span><span class="p">.</span> <span class="n">The</span> <span class="n">indirect</span> <span class="n">call</span> <span class="n">is</span> <span class="n">needed</span> <span class="n">because</span>
</span><span class='line'>  <span class="err">#</span> <span class="n">the</span> <span class="n">assembler</span> <span class="n">produces</span> <span class="n">a</span> <span class="n">PC</span><span class="o">-</span><span class="n">relative</span> <span class="n">instruction</span>
</span><span class='line'>  <span class="err">#</span> <span class="k">for</span> <span class="n">a</span> <span class="n">direct</span> <span class="n">jump</span><span class="p">.</span>
</span><span class='line'>  <span class="n">mov</span> <span class="err">$</span><span class="n">main</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">jmp</span> <span class="o">*%</span><span class="n">eax</span>
</span><span class='line'>
</span><span class='line'><span class="p">.</span><span class="n">comm</span> <span class="n">stack</span><span class="p">,</span> <span class="n">KSTACKSIZE</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们直接略去 <code>multiboot_header</code> 这部分。这部分是为了方便通过 <a href="https://zh.wikipedia.org/zh/GNU_GRUB">GNU GRUB</a> 来引导 xv6 系统的。我们直接看 <code>.globl _start</code> 部分，入口只做了一件事儿就是转到 <code>entry</code> 段继续执行。不过别看这里只有一行代码，我们也要说一下。</p>

<p><code>V2P_WO</code> 的定义在 <code>memlayout.h</code> 文件中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define KERNBASE 0x80000000         </span><span class="c1">// First kernel virtual address</span>
</span><span class='line'><span class="cp">#define V2P_WO(x) ((x) - KERNBASE)</span>
</span></code></pre></td></tr></table></div></figure>


<p>它的作用是将内存虚拟地址转换成物理地址。我们现在知道内核的虚拟地址起始于 <code>0x80100000</code> 而对应的内存物理地址是 <code>0x100000</code> ，因为代码的偏移量是一样的即：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">指令虚拟地址</span> <span class="o">=</span> <span class="mh">0x80100000</span> <span class="o">+</span> <span class="err">偏移量</span>
</span><span class='line'><span class="err">指令内存地址</span> <span class="o">=</span> <span class="mh">0x100000</span> <span class="o">+</span> <span class="err">偏移量</span>
</span><span class='line'>
</span><span class='line'><span class="err">所以运用初中解方程式的知识</span>
</span><span class='line'>
</span><span class='line'><span class="err">执行内存地址</span> <span class="o">=</span> <span class="mh">0x100000</span> <span class="o">+</span> <span class="err">指令虚拟地址</span> <span class="o">-</span> <span class="mh">0x80100000</span>
</span><span class='line'>             <span class="o">=</span> <span class="err">指令虚拟地址</span> <span class="o">-</span> <span class="mh">0x80000000</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来我们继续看 <code>entry</code> 段做了什么。总结来说一共做了五件事儿：</p>

<ul>
<li>1、开启 4MB 内存页支持</li>
<li>2、建立内存页表</li>
<li>3、开启内存分页机制</li>
<li>4、设置内核栈顶位置</li>
<li>5、跳转到 <code>main</code> 继续执行</li>
</ul>


<p>我们一件一件的说。</p>

<h3>开启 4MB 内存分页支持</h3>

<p>这是通过设置寄存器 <code>cr4</code> 的 <code>PSE</code> 位来完成的。<code>cr4</code> 寄存器是个 32 位的寄存器目前只用到低 21 位，每一位的至位都控制这一些功能的状态，所以 <code>cr4</code> 寄存器又叫做控制寄存器。</p>

<p><code>PSE</code> 位是 <code>cr4</code> 控制寄存器的第 5 位，当该位置为 1 时表示内存页大小为 4MB，当置为 0 时表示内存页大小为 4KB。</p>

<h3>建立内存页表</h3>

<p>这里先从内存的分页机制说起。之前我们已经接触过内存的分段管理机制了，和分段机制一样，分页机制同样是管理内存的一种方式，只不过这种方式相对于分段式来说更为先进，也是目前主流的现代操作系统所使用的内存管理方式。</p>

<p>通过分页将虚拟地址转换为物理地址这项工作是由 MMU(内存管理单元)负责的，以 x86 32 位架构来说它支持两级分页（Pentium Pro下分页可以是三级），这也是由 MMU 决定的。同时 x86 架构支持 4KB、2MB 和 4MB 单位页面大小的分页。当然无论以多少级进行分页，分页机制的原理是相通的，我们就以两级分页来说。</p>

<p>看下图是二级页表分页机制下虚拟地址转换为物理地址的过程，以 32 位系统为例我们知道 32 位系统的内存虚拟地址是 32 位的，这里我们先假设页面大小是 4KB （随后我们再说 4MB 页面的情况）。</p>

<p>在 4KB 页面大小情况下 32 位的虚拟地址被分为三个部分，从高位到低位分别是：10 位的一级页表索引，10 位的二级页表索引，12 位的页内偏移量。</p>

<p><code>cr3</code> 寄存器中保存着一级页表所在的内存物理地址，当给出一个虚拟地址后，根据 <code>cr3</code> 的地址首先找到一级页表在内存上的存放位置。上面我们说到虚拟地址的高 10 位为一级页表的索引，所以 <code>2^10 = 1024</code> 即一级页表一共有 1024 个元素，通过虚拟地址高 10 位的索引我们找到其中一个元素，而这个元素的值指向二级页表在内存中的物理地址。</p>

<p>同理，虚拟地址中紧挨着高 10 位后面的 10 位是二级页表索引，因此二级页表也有 1024 个元素，通过虚拟地址的二级页表索引找到其中的一个元素，该元素指向内存分页中的一个页的地址。</p>

<p>通过二级页表我们现在找到了内存上的一页物理页。根据现在的设定，一物理页的大小是 4KB，4KB 的内存上还是存在着很多不同的数据的，那么我们如何从这段 4KB 内存上取得我们想要的数据呢？别忘了在虚拟地址上还剩下低 12 位没用呢，<code>2^12 = 4096 = 4KB</code> 根据这最后 12 位的索引我们最终在内存上准确的找到了我们想要的数据。</p>

<p>而根据二级页表和每页内存的大小我们也不难算出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">1024</span><span class="err">个一级页表项</span> <span class="n">x</span> <span class="mi">1024</span><span class="err">个二级页表项</span> <span class="n">x</span> <span class="mi">4</span><span class="n">KB</span><span class="err">页面大小</span> <span class="o">=</span> <span class="mi">4</span><span class="n">GB</span>
</span></code></pre></td></tr></table></div></figure>


<p>正好是 32 位系统的最大内存寻址。</p>

<p>我们再通过下面这张示意图体会一下这个过程。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">寄存器</span>                       <span class="err">虚拟地址</span>
</span><span class='line'><span class="o">+---+</span>        <span class="o">+---------------------------------------+</span>
</span><span class='line'><span class="o">|</span><span class="n">cr3</span><span class="o">|</span>        <span class="o">|</span>  <span class="n">Page</span> <span class="n">Dict</span>  <span class="o">|</span>  <span class="n">Page</span> <span class="n">Table</span>  <span class="o">|</span>  <span class="n">Offset</span>  <span class="o">|</span>
</span><span class='line'><span class="o">+---+</span>        <span class="o">|</span>  <span class="mi">31</span> <span class="o">--</span> <span class="mi">22</span>   <span class="o">|</span>  <span class="mi">21</span> <span class="o">--</span> <span class="mi">12</span>    <span class="o">|</span>  <span class="mi">11</span> <span class="o">--</span> <span class="mi">0</span> <span class="o">|</span>
</span><span class='line'>  <span class="o">|</span>          <span class="o">+---------------------------------------+</span>
</span><span class='line'><span class="n">__</span><span class="o">/</span>                   <span class="o">|</span>                   <span class="o">|</span>       <span class="o">|-----------|</span>
</span><span class='line'><span class="o">|</span>  <span class="o">+--------+</span>         <span class="o">|</span>      <span class="o">+--------+</span>   <span class="o">|</span>    <span class="o">+--------+</span>     <span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="o">|</span>        <span class="o">|</span>         <span class="o">|</span>      <span class="o">|</span>        <span class="o">|</span>   <span class="o">|</span>    <span class="o">|</span>        <span class="o">|</span>     <span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="o">+--------+</span>         <span class="o">|</span>      <span class="o">+--------+&lt;--|</span>    <span class="o">+--------+</span>     <span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="o">|</span>        <span class="o">|</span>         <span class="o">|</span>      <span class="o">|</span>        <span class="o">|-----|</span>  <span class="o">|</span>        <span class="o">|</span>     <span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="o">+--------+&lt;--------|</span>      <span class="o">+--------+</span>     <span class="o">|</span>  <span class="o">+--------+</span>     <span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="o">|</span>  <span class="n">PDE</span>   <span class="o">|----|</span>           <span class="o">|</span>   <span class="n">PTE</span>  <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>  <span class="n">Data</span>  <span class="o">|</span>     <span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="o">+--------+</span>    <span class="o">|</span>           <span class="o">+--------+</span>     <span class="o">|</span>  <span class="o">+--------+&lt;----|</span>
</span><span class='line'><span class="o">|</span>  <span class="o">|</span>        <span class="o">|</span>    <span class="o">|</span>           <span class="o">|</span>        <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>        <span class="o">|</span>
</span><span class='line'><span class="o">|</span>  <span class="o">+--------+</span>    <span class="o">|</span>           <span class="o">+--------+</span>     <span class="o">|</span>  <span class="o">+--------+</span>
</span><span class='line'><span class="o">|</span>  <span class="o">|</span>        <span class="o">|</span>    <span class="o">|</span>           <span class="o">|</span>        <span class="o">|</span>     <span class="o">|</span>  <span class="o">|</span>        <span class="o">|</span>
</span><span class='line'><span class="o">|-&gt;+--------+</span>    <span class="o">|----------&gt;+--------+</span>     <span class="o">|-&gt;+--------+</span>
</span><span class='line'>     <span class="err">一级页表</span>                    <span class="err">二级页表</span>          <span class="err">物理内存页</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们再额外算一笔账，二级页表中每个表项占 32 位，所以一个一级页表的总体积是 <code>4byte x 1024 = 4KB</code>，而每个一级页表项都对应一个二级页表，所以全部二级页表的总体积是 <code>4KB x 1024 = 4MB</code>，即二级页表分页机制自身内存占用也要约 4MB 外加 4KB。</p>

<p>我们还要额外提一下页表项。上面刚说过每个页表项占 32 位，它也是分两个部分：高 20 位是基地址，低 12 位是控制标记位。所以当我们通过一级页表索引在一级页表中查找时是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">一级页表项地址</span> <span class="o">=</span> <span class="n">cr3</span><span class="err">寄存器高</span><span class="mi">20</span><span class="err">位</span> <span class="o">+</span> <span class="p">(</span> <span class="mi">10</span><span class="err">位一级页表索引</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过二级页表索引在二级页表中查找时是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">二级页表项地址</span> <span class="o">=</span> <span class="err">一级页表项高</span><span class="mi">20</span><span class="err">位</span> <span class="o">+</span> <span class="p">(</span> <span class="mi">10</span><span class="err">位二级页表索引</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>读到这里你是否可以理解 <code>页表项索引左移 2 位</code> 这个操作的意义？索引就好比数组的下标，而这里我们要通过下标得到具体的位置，如果一条笔直的马路上每隔 2 米就插一面旗子，我现在站在这条路的起点处（20位基地址）问你第 5 面旗子（下标索引）距离我多远（地址），那么你一定会算：<code>5 x 2 = 10 米</code>，那么同理：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="err">页表项地址</span> <span class="o">=</span> <span class="err">基地址</span> <span class="o">+</span> <span class="p">(</span> <span class="err">索引</span> <span class="n">x</span> <span class="err">页表项大小</span> <span class="p">)</span>
</span><span class='line'>           <span class="o">=</span> <span class="err">基地址</span> <span class="o">+</span> <span class="p">(</span> <span class="err">索引</span> <span class="n">x</span> <span class="mi">4</span><span class="err">字节</span> <span class="p">)</span>
</span><span class='line'>           <span class="o">=</span> <span class="err">基地址</span> <span class="o">+</span> <span class="p">(</span> <span class="err">索引</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后我们再看看页表项低 12 位控制位都代表什么意义</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">+</span> <span class="mi">11</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span>  <span class="mi">7</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span>  <span class="mi">4</span>  <span class="o">+</span>  <span class="mi">3</span>  <span class="o">+</span> <span class="mi">2</span>  <span class="o">+</span> <span class="mi">1</span>  <span class="o">+</span> <span class="mi">0</span> <span class="o">+</span>
</span><span class='line'><span class="o">|</span>    <span class="n">Avail</span>    <span class="o">|</span> <span class="n">G</span> <span class="o">|</span> <span class="n">PS</span> <span class="o">|</span> <span class="n">D</span> <span class="o">|</span> <span class="n">A</span> <span class="o">|</span> <span class="n">PCD</span> <span class="o">|</span> <span class="n">PWT</span> <span class="o">|</span> <span class="n">US</span> <span class="o">|</span> <span class="n">RW</span> <span class="o">|</span> <span class="n">P</span> <span class="o">|</span>
</span><span class='line'><span class="o">+--------------------------------------------------------+</span>
</span><span class='line'><span class="o">|</span>     <span class="mo">000</span>     <span class="o">|</span> <span class="mi">0</span> <span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">|</span>  <span class="mi">0</span>  <span class="o">|</span>  <span class="mi">0</span>  <span class="o">|</span>  <span class="mi">0</span> <span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span>
</span><span class='line'><span class="o">+--------------------------------------------------------+</span>
</span><span class='line'>
</span><span class='line'><span class="n">P</span>     <span class="o">:</span> <span class="mi">0</span> <span class="err">表示此页不在物理内存中，</span><span class="mi">1</span> <span class="err">表示此页在物理内存中</span>
</span><span class='line'><span class="n">RW</span>    <span class="o">:</span> <span class="mi">0</span> <span class="err">表示只读，</span><span class="mi">1</span> <span class="err">表示可读可写（要配合</span> <span class="n">US</span> <span class="err">位）</span>
</span><span class='line'><span class="n">US</span>    <span class="o">:</span> <span class="mi">0</span> <span class="err">表示特权级页面，</span><span class="mi">1</span> <span class="err">表示普通权限页面</span>
</span><span class='line'><span class="n">PWT</span>   <span class="o">:</span> <span class="mi">1</span> <span class="err">表示写这个页面时直接写入内存，</span><span class="mi">0</span> <span class="err">表示先写到缓存中</span>
</span><span class='line'><span class="n">PCD</span>   <span class="o">:</span> <span class="mi">1</span> <span class="err">表示该页禁用缓存机制，</span><span class="mi">0</span> <span class="err">表示启用缓存</span>
</span><span class='line'><span class="n">A</span>     <span class="o">:</span> <span class="err">当该页被初始化时为</span> <span class="mi">0</span><span class="err">，一但进行过读</span><span class="o">/</span><span class="err">写则置为</span> <span class="mi">1</span>
</span><span class='line'><span class="n">D</span>     <span class="o">:</span> <span class="err">脏页标记（这里就不做具体介绍了）</span>
</span><span class='line'><span class="n">PS</span>    <span class="o">:</span> <span class="mi">0</span> <span class="err">表示页面大小为</span> <span class="mi">4</span><span class="n">KB</span><span class="err">，</span><span class="mi">1</span> <span class="err">表示页面大小为</span> <span class="mi">4</span><span class="n">MB</span>
</span><span class='line'><span class="n">G</span>     <span class="o">:</span> <span class="mi">1</span> <span class="err">表示页面为共享页面（这里就不做具体介绍了）</span>
</span><span class='line'><span class="n">Avail</span> <span class="o">:</span> <span class="mi">3</span> <span class="err">位保留位</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后我们再说回 xv6。</p>

<p>到目前为止我们知道 xv6 开启了 4MB 内存页大小，在 x86 架构下当通过 <code>cr4</code> 控制寄存器的 <code>PSE</code> 位打开了 4MB 分页后 MMU 内存管理单元的分页机制就会从二级分页简化位一级分页。</p>

<p>即虚拟地址的高 10 位仍然是一级页表项索引，但是后面的 22 位则全部变为页内偏移量（因为一页有 <code>2^22 = 4MB</code> 大小了嘛）。</p>

<p>我们来看看这个一级页表的结构</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp"># Set page directory</span>
</span><span class='line'>  <span class="n">movl</span>    <span class="err">$</span><span class="p">(</span><span class="n">V2P_WO</span><span class="p">(</span><span class="n">entrypgdir</span><span class="p">)),</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">movl</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="o">%</span><span class="n">cr3</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过代码我们知道页表地址是存在一个叫做 <code>entrypgdir</code> 的变量中了，通过文本搜索可以在 <code>main.c</code> 文件的最后找到这个变量，我们看一下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// Boot page table used in entry.S and entryother.S.</span>
</span><span class='line'><span class="c1">// Page directories (and page tables), must start on a page boundary,</span>
</span><span class='line'><span class="c1">// hence the &quot;__aligned__&quot; attribute.  </span>
</span><span class='line'><span class="c1">// Use PTE_PS in page directory entry to enable 4Mbyte pages.</span>
</span><span class='line'><span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="n">PGSIZE</span><span class="p">)))</span>
</span><span class='line'><span class="n">pde_t</span> <span class="n">entrypgdir</span><span class="p">[</span><span class="n">NPDENTRIES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Map VA&#39;s [0, 4MB) to PA&#39;s [0, 4MB)</span>
</span><span class='line'>  <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="n">PTE_W</span> <span class="o">|</span> <span class="n">PTE_PS</span><span class="p">,</span>
</span><span class='line'>  <span class="c1">// Map VA&#39;s [KERNBASE, KERNBASE+4MB) to PA&#39;s [0, 4MB)</span>
</span><span class='line'>  <span class="p">[</span><span class="n">KERNBASE</span><span class="o">&gt;&gt;</span><span class="n">PDXSHIFT</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="n">PTE_W</span> <span class="o">|</span> <span class="n">PTE_PS</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//PAGEBREAK!</span>
</span><span class='line'><span class="c1">// Blank page.</span>
</span></code></pre></td></tr></table></div></figure>


<p>将这些宏定义都转义过来我们看看这个页表的样子</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entrypgdir</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">|</span> <span class="mh">0x001</span> <span class="o">|</span> <span class="mh">0x002</span> <span class="o">|</span> <span class="mh">0x080</span><span class="p">,</span>  <span class="c1">// 0x083 = 0000 1000 0011</span>
</span><span class='line'>    <span class="p">[</span><span class="mh">0x80000000</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">|</span> <span class="mh">0x001</span> <span class="o">|</span> <span class="mh">0x002</span> <span class="o">|</span> <span class="mh">0x080</span>  <span class="c1">// 0x083</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>可见这个页表非常简单，只有两个页表项 <code>0x00000000</code> 和 <code>0x80000000</code>，而且两个页表项索引的内存物理地址都是 <code>0 ~ 4MB</code>，其他页表项全部未作设置。而且通过这两个页表项的值也可以清楚的看出这段基地址为 0 的 4MB 大小的内存页还是特级权限内存页（低 12 位的控制位对应关系已经附在上面解释控制位的示意图里了）。</p>

<p>不难想象这么简单的页表肯定不是 xv6 最终使用的页表。这里可以先剧透一下，这确实只是一个临时页表，它只保证内核在即将打开内存分页支持后内核可以正常执行接下来的代码，而内核在紧接着执行 <code>main</code> 方法时会马上再次重新分配新的页表，而且最终的页表是 4KB 单位页面的精细页表哦~</p>

<h3>开启内存分页机制</h3>

<p>我们在上上篇<a href="http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">《【学习xv6】从实模式到保护模式》</a>讲到如何打开保护模式时其实就已经介绍过开启分页机制的方法了：将 <code>cr0</code> 寄存器的第 31 位置为 1。</p>

<p>这里还要在提一句，至此我们开启了内存分页机制，接下来内核的代码执行和数据读写都要经过 MMU 通过分页机制对内核指令地址和数据地址的转换，那么目前的页表是如何保证在转换后的物理地址是正确的，如何保证内核可以继续正常运行的呢？</p>

<p>我们来分析一下。</p>

<p>根据 <code>kernel.ld</code> 链接器脚本的设定，内核的虚拟地址起始于 <code>0x80100000</code> 即内核代码段的起始处，而内核的代码段被放置在内存物理地址 <code>0x100000</code> 处。我们刚刚看到目前的临时页表将虚拟地址 <code>0x80000000</code> 映射到物理内存的 <code>0x0</code> 处，所以我们来尝试用刚刚了解到的内存分页机制来解析一下 <code>0x80100000</code> 虚拟地址最后转换成物理地址是多少。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mh">0x80100000</span> <span class="o">=</span> <span class="mi">1000</span> <span class="mo">0000</span> <span class="mo">00</span><span class="o">|</span><span class="mo">01</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span>
</span><span class='line'>
</span><span class='line'><span class="mh">0x80100000</span> <span class="err">高</span> <span class="mi">10</span> <span class="err">位</span> <span class="o">=</span> <span class="mi">1000</span> <span class="mo">0000</span> <span class="mo">00</span> <span class="o">=</span> <span class="mi">512</span>
</span><span class='line'>
</span><span class='line'><span class="mh">0x80100000</span> <span class="err">后</span> <span class="mi">22</span> <span class="err">位</span> <span class="o">=</span> <span class="mo">01</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="o">=</span> <span class="mi">1048576</span>
</span><span class='line'>
</span><span class='line'><span class="err">索引</span> <span class="mi">512</span> <span class="err">对应</span>  <span class="n">entrypgdir</span><span class="p">[</span> <span class="mh">0x80000000</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span> <span class="p">]</span> <span class="err">即基地址为</span> <span class="mh">0x0</span>
</span><span class='line'>
</span><span class='line'><span class="err">换算的物理地址</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1048576</span> <span class="o">=</span> <span class="mi">1048576</span> <span class="o">=</span> <span class="mh">0x100000</span>
</span><span class='line'>
</span><span class='line'><span class="err">即内核代码段所在内存物理地址</span> <span class="mh">0x100000</span>
</span></code></pre></td></tr></table></div></figure>


<p>说白了就是通过页表将内核高端的虚拟地址直接映射到内核真实所在的低端物理内存位置。</p>

<p>这样虽然保证了在分页机制开启的情况下内核也可以正常运行，但也限制了内核最多只能使用 4MB 的内存，不过对于现在的内核来说 4MB 足够了。</p>

<h3>设置内核栈顶位置并跳转到 main 执行</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="err">#</span> <span class="n">Set</span> <span class="n">up</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span><span class="p">.</span>
</span><span class='line'>  <span class="n">movl</span> <span class="err">$</span><span class="p">(</span><span class="n">stack</span> <span class="o">+</span> <span class="n">KSTACKSIZE</span><span class="p">),</span> <span class="o">%</span><span class="n">esp</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">#</span> <span class="n">Jump</span> <span class="n">to</span> <span class="n">main</span><span class="p">(),</span> <span class="n">and</span> <span class="k">switch</span> <span class="n">to</span> <span class="n">executing</span> <span class="n">at</span>
</span><span class='line'>  <span class="err">#</span> <span class="n">high</span> <span class="n">addresses</span><span class="p">.</span> <span class="n">The</span> <span class="n">indirect</span> <span class="n">call</span> <span class="n">is</span> <span class="n">needed</span> <span class="n">because</span>
</span><span class='line'>  <span class="err">#</span> <span class="n">the</span> <span class="n">assembler</span> <span class="n">produces</span> <span class="n">a</span> <span class="n">PC</span><span class="o">-</span><span class="n">relative</span> <span class="n">instruction</span>
</span><span class='line'>  <span class="err">#</span> <span class="k">for</span> <span class="n">a</span> <span class="n">direct</span> <span class="n">jump</span><span class="p">.</span>
</span><span class='line'>  <span class="n">mov</span> <span class="err">$</span><span class="n">main</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
</span><span class='line'>  <span class="n">jmp</span> <span class="o">*%</span><span class="n">eax</span>
</span><span class='line'>
</span><span class='line'><span class="p">.</span><span class="n">comm</span> <span class="n">stack</span><span class="p">,</span> <span class="n">KSTACKSIZE</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里通过 <code>.comm</code> 在内核 bbs 段开辟了一段 <code>KSTACKSIZE = 4096 = 4KB</code> 大小的内核栈并将栈顶设置为这段数据区域的末尾处（栈是自上而下的嘛），最后通过 <code>jmp</code> 语句跳转到 <code>main</code> 方法处继续执行。</p>

<p>看到 <code>main</code> 这个单词玩过 C 语言的会觉得亲切吧。没错，我们即将踏入 C 语言的天地了。顺带提一句，看过这篇之后你应该能想明白为什么 <code>main</code> 函数会是 C 语言编写的程序的入口（链接器脚本），可不可以用别的函数做 C 语言编写程序的入口呢？（可以，通过链接器脚本）。</p>

<h2>内核运行</h2>

<p>我们来到 <code>main.c</code> 文件的 <code>main</code> 函数处，这里很干净的调用了一连串的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// Bootstrap processor starts running C code here.</span>
</span><span class='line'><span class="c1">// Allocate a real stack and switch to it, first</span>
</span><span class='line'><span class="c1">// doing some setup required for memory allocator to work.</span>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">kinit1</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">P2V</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">));</span> <span class="c1">// phys page allocator</span>
</span><span class='line'>  <span class="n">kvmalloc</span><span class="p">();</span>      <span class="c1">// kernel page table</span>
</span><span class='line'>  <span class="n">mpinit</span><span class="p">();</span>        <span class="c1">// collect info about this machine</span>
</span><span class='line'>  <span class="n">lapicinit</span><span class="p">();</span>
</span><span class='line'>  <span class="n">seginit</span><span class="p">();</span>       <span class="c1">// set up segments</span>
</span><span class='line'>  <span class="n">cprintf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">cpu%d: starting xv6</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
</span><span class='line'>  <span class="n">picinit</span><span class="p">();</span>       <span class="c1">// interrupt controller</span>
</span><span class='line'>  <span class="n">ioapicinit</span><span class="p">();</span>    <span class="c1">// another interrupt controller</span>
</span><span class='line'>  <span class="n">consoleinit</span><span class="p">();</span>   <span class="c1">// I/O devices &amp; their interrupts</span>
</span><span class='line'>  <span class="n">uartinit</span><span class="p">();</span>      <span class="c1">// serial port</span>
</span><span class='line'>  <span class="n">pinit</span><span class="p">();</span>         <span class="c1">// process table</span>
</span><span class='line'>  <span class="n">tvinit</span><span class="p">();</span>        <span class="c1">// trap vectors</span>
</span><span class='line'>  <span class="n">binit</span><span class="p">();</span>         <span class="c1">// buffer cache</span>
</span><span class='line'>  <span class="n">fileinit</span><span class="p">();</span>      <span class="c1">// file table</span>
</span><span class='line'>  <span class="n">iinit</span><span class="p">();</span>         <span class="c1">// inode cache</span>
</span><span class='line'>  <span class="n">ideinit</span><span class="p">();</span>       <span class="c1">// disk</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ismp</span><span class="p">)</span>
</span><span class='line'>    <span class="n">timerinit</span><span class="p">();</span>   <span class="c1">// uniprocessor timer</span>
</span><span class='line'>  <span class="n">startothers</span><span class="p">();</span>   <span class="c1">// start other processors</span>
</span><span class='line'>  <span class="n">kinit2</span><span class="p">(</span><span class="n">P2V</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">),</span> <span class="n">P2V</span><span class="p">(</span><span class="n">PHYSTOP</span><span class="p">));</span> <span class="c1">// must come after startothers()</span>
</span><span class='line'>  <span class="n">userinit</span><span class="p">();</span>      <span class="c1">// first user process</span>
</span><span class='line'>  <span class="c1">// Finish setting up this processor in mpmain.</span>
</span><span class='line'>  <span class="n">mpmain</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此我们已经了解一台 PC 从加电启动开始如何从实模式到保护模式、内存寻址如何从分段式到分页式，启动方式如何从 BIOS 到引导区程序再从引导区程序加载内核到内存中运行。</p>

<p>即便写了这么多，内核这位“神秘的少女”也只是刚刚走到我们面前，我们还未揭开这位“神秘的少女”的面纱去窥探她美丽的容貌。不过我们距离这一刻已经非常非常的近了，接下来我们将会看到 xv6 的内核是如何实现内存管理、进程管理、IO 操作等现代化操作系统所应该实现的诸多特性。</p>

<p>让我们继续加油！</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-11-11T16:28:13+08:00" pubdate data-updated="true">2015年11月11日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/cao-zuo-xi-tong/'>操作系统</a>


</div>
	
	<div class="comments"><a href="/blog/2015/11/11/%5B%28xue-xi-xv6%29%5D-nei-he-gai-lan/#disqus_thread">Comments</a></div>
	
	<div>
		<br/><div>如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</div>
		<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="post" target="_blank" accept-charset="GBK" id="alipayForm">
			<input name="optEmail" type="hidden" value="leenjewel@gmail.com" />
			<input name="payAmount" type="hidden" value="1.00" />
			<input id="title" name="title" type="hidden" value="捐赠给 leenjewel.github.io" />
			<input name="memo" type="hidden" value="文章写的不错，我来捐赠鼓励的！" />
			<input name="pay" type="image" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" width="150" height="40">
		</form>
	</div>
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/06/30/zai-cocos2d-x-zhong-shi-yong-openssl/">
		
			在 Cocos2d-x 中使用 OpenSSL</a>
	</h2>
	<div class="entry-content">
		<p>在我们使用 Cocos2d-x 引擎制作游戏过程中经常会遇到诸如对数据进行加密、解密、MD5、SHA1 散列计算等操作的需求。对于这样的需求使用 OpenSSL 库来解决是最为方便的。下面我们就说说如何将 OpenSSL 库集成到 Cocos2d-x 项目中并在 iOS 和 Android 平台下使用。什么？！不知道 OpenSSL 是什么？这么大名鼎鼎的开源项目，<a href="https://zh.wikipedia.org/wiki/OpenSSL">移步 Wiki </a>去了解吧。</p>

<h2>下载 OpenSSL 源代码</h2>

<p>直接到 OpenSSL 开源项目官网去<a href="https://www.openssl.org/source/openssl-1.0.2c.tar.gz">下载</a>最新版本即可。我下载的是<code>openssl-1.0.2c</code></p>

<h2>编译生成 iOS 平台下适用的 OpenSSL 静态链接库</h2>

<p>首先解压缩你下载的 OpenSSL 源代码压缩包。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>tar -zxvf openssl-1.0.2c.tar.gz
</span></code></pre></td></tr></table></div></figure>


<p>玩过 Linux 的人都知道从源代码编译程序一般需要三步：</p>

<ol>
<li>./Configure</li>
<li>make</li>
<li>make install</li>
</ol>


<p>编译 OpenSSL 生成静态链接库的过程也一样，唯一的区别是我们要针对不同的平台架构生成针对每个平台架构的静态链接库。例如 iPhone、iPad 目前有三种架构：<code>arm64</code>、<code>armv7s</code>和<code>armv7</code>外加模拟器的架构 <code>i386</code>，所以我们要重复上面三个步骤 4 次，生成四个平台架构对应的静态链接库。</p>

<p>这里我们偷个懒，用<a href="https://raw.githubusercontent.com/Raphaelios/raphaelios-scripts/master/openssl/build-openssl.sh"> GitHub 上 Raphaelios 写的 Shell 脚本</a>来直接编译 OpenSSL ，下面我贴出脚本的源码并简单添加一些说明注释。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c">#  Copyright (c) 2013 Claudiu-Vlad Ursache &lt;claudiu@cvursache.com&gt;</span>
</span><span class='line'><span class="c">#  MIT License (see LICENSE.md file)</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c">#  Based on work by Felix Schulze:</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c">#  Automatic build script for libssl and libcrypto </span>
</span><span class='line'><span class="c">#  for iPhoneOS and iPhoneSimulator</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c">#  Created by Felix Schulze on 16.12.10.</span>
</span><span class='line'><span class="c">#  Copyright 2010 Felix Schulze. All rights reserved.</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c">#  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
</span><span class='line'><span class="c">#  you may not use this file except in compliance with the License.</span>
</span><span class='line'><span class="c">#  You may obtain a copy of the License at</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c">#  http://www.apache.org/licenses/LICENSE-2.0</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="c">#  Unless required by applicable law or agreed to in writing, software</span>
</span><span class='line'><span class="c">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
</span><span class='line'><span class="c">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
</span><span class='line'><span class="c">#  See the License for the specific language governing permissions and</span>
</span><span class='line'><span class="c">#  limitations under the License.</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 当执行时使用到未定义过的变量，则显示错误信息</span>
</span><span class='line'><span class="nb">set</span> -u
</span><span class='line'>
</span><span class='line'><span class="c"># Setup architectures, library name and other vars + cleanup from previous runs</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 四个平台架构标识</span>
</span><span class='line'><span class="nv">ARCHS</span><span class="o">=(</span><span class="s2">&quot;arm64&quot;</span> <span class="s2">&quot;armv7s&quot;</span> <span class="s2">&quot;armv7&quot;</span> <span class="s2">&quot;i386&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 四个平台架构分别对应的 SDK 名称</span>
</span><span class='line'><span class="nv">SDKS</span><span class="o">=(</span><span class="s2">&quot;iphoneos&quot;</span> <span class="s2">&quot;iphoneos&quot;</span> <span class="s2">&quot;iphoneos&quot;</span> <span class="s2">&quot;macosx&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 使用的 OpenSSL 库版本</span>
</span><span class='line'><span class="nv">LIB_NAME</span><span class="o">=</span><span class="s2">&quot;openssl-1.0.2c&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 临时输出目录</span>
</span><span class='line'><span class="nv">TEMP_LIB_PATH</span><span class="o">=</span><span class="s2">&quot;/tmp/${LIB_NAME}&quot;</span>
</span><span class='line'><span class="nv">LIB_DEST_DIR</span><span class="o">=</span><span class="s2">&quot;lib&quot;</span>
</span><span class='line'><span class="nv">HEADER_DEST_DIR</span><span class="o">=</span><span class="s2">&quot;include&quot;</span>
</span><span class='line'>rm -rf <span class="s2">&quot;${HEADER_DEST_DIR}&quot;</span> <span class="s2">&quot;${LIB_DEST_DIR}&quot;</span> <span class="s2">&quot;${TEMP_LIB_PATH}*&quot;</span> <span class="s2">&quot;${LIB_NAME}&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Unarchive library, then configure and make for specified architectures</span>
</span><span class='line'><span class="c"># 编译静态链接库的函数</span>
</span><span class='line'>configure_make<span class="o">()</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>   <span class="nv">ARCH</span><span class="o">=</span><span class="nv">$1</span>; <span class="nv">GCC</span><span class="o">=</span><span class="nv">$2</span>; <span class="nv">SDK_PATH</span><span class="o">=</span><span class="nv">$3</span>;
</span><span class='line'>   <span class="nv">LOG_FILE</span><span class="o">=</span><span class="s2">&quot;${TEMP_LIB_PATH}-${ARCH}.log&quot;</span>
</span><span class='line'>   tar xfz <span class="s2">&quot;${LIB_NAME}.tar.gz&quot;</span>
</span><span class='line'>   <span class="nb">pushd</span> .; <span class="nb">cd</span> <span class="s2">&quot;${LIB_NAME}&quot;</span>;
</span><span class='line'>
</span><span class='line'>   ./Configure BSD-generic32 --openssldir<span class="o">=</span><span class="s2">&quot;${TEMP_LIB_PATH}-${ARCH}&quot;</span> &amp;&gt; <span class="s2">&quot;${LOG_FILE}&quot;</span>
</span><span class='line'>
</span><span class='line'>   make <span class="nv">CC</span><span class="o">=</span><span class="s2">&quot;${GCC} -arch ${ARCH}&quot;</span> <span class="nv">CFLAG</span><span class="o">=</span><span class="s2">&quot;-isysroot ${SDK_PATH}&quot;</span> &amp;&gt; <span class="s2">&quot;${LOG_FILE}&quot;</span>;
</span><span class='line'>   make install &amp;&gt; <span class="s2">&quot;${LOG_FILE}&quot;</span>;
</span><span class='line'>   <span class="nb">popd</span>; rm -rf <span class="s2">&quot;${LIB_NAME}&quot;</span>;
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 分别开始编译四个平台架构的静态链接库</span>
</span><span class='line'><span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>0; i &lt; <span class="k">${#</span><span class="nv">ARCHS</span><span class="p">[@]</span><span class="k">}</span>; i++<span class="o">))</span>
</span><span class='line'><span class="k">do</span>
</span><span class='line'>   <span class="c"># 获取 SDK 路径</span>
</span><span class='line'>   <span class="nv">SDK_PATH</span><span class="o">=</span><span class="k">$(</span>xcrun -sdk <span class="k">${</span><span class="nv">SDKS</span><span class="p">[i]</span><span class="k">}</span> --show-sdk-path<span class="k">)</span>
</span><span class='line'>   <span class="c"># 过去 gcc 编译器路径</span>
</span><span class='line'>   <span class="nv">GCC</span><span class="o">=</span><span class="k">$(</span>xcrun -sdk <span class="k">${</span><span class="nv">SDKS</span><span class="p">[i]</span><span class="k">}</span> -find gcc<span class="k">)</span>
</span><span class='line'>   <span class="c"># 编译</span>
</span><span class='line'>   configure_make <span class="s2">&quot;${ARCHS[i]}&quot;</span> <span class="s2">&quot;${GCC}&quot;</span> <span class="s2">&quot;${SDK_PATH}&quot;</span>
</span><span class='line'><span class="k">done</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Combine libraries for different architectures into one</span>
</span><span class='line'><span class="c"># Use .a files from the temp directory by providing relative paths</span>
</span><span class='line'><span class="c"># 通过 lipo 命令将四个平台架构的静态库打包成一个静态库</span>
</span><span class='line'>create_lib<span class="o">()</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>   <span class="nv">LIB_SRC</span><span class="o">=</span><span class="nv">$1</span>; <span class="nv">LIB_DST</span><span class="o">=</span><span class="nv">$2</span>;
</span><span class='line'>   <span class="nv">LIB_PATHS</span><span class="o">=(</span> <span class="s2">&quot;${ARCHS[@]/#/${TEMP_LIB_PATH}-}&quot;</span> <span class="o">)</span>
</span><span class='line'>   <span class="nv">LIB_PATHS</span><span class="o">=(</span> <span class="s2">&quot;${LIB_PATHS[@]/%//${LIB_SRC}}&quot;</span> <span class="o">)</span>
</span><span class='line'>   lipo <span class="k">${</span><span class="nv">LIB_PATHS</span><span class="p">[@]</span><span class="k">}</span> -create -output <span class="s2">&quot;${LIB_DST}&quot;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>mkdir <span class="s2">&quot;${LIB_DEST_DIR}&quot;</span>;
</span><span class='line'>create_lib <span class="s2">&quot;lib/libcrypto.a&quot;</span> <span class="s2">&quot;${LIB_DEST_DIR}/libcrypto.a&quot;</span>
</span><span class='line'>create_lib <span class="s2">&quot;lib/libssl.a&quot;</span> <span class="s2">&quot;${LIB_DEST_DIR}/libssl.a&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Copy header files + final cleanups</span>
</span><span class='line'>mkdir -p <span class="s2">&quot;${HEADER_DEST_DIR}&quot;</span>
</span><span class='line'>cp -R <span class="s2">&quot;${TEMP_LIB_PATH}-${ARCHS[0]}/include&quot;</span> <span class="s2">&quot;${HEADER_DEST_DIR}&quot;</span>
</span><span class='line'>rm -rf <span class="s2">&quot;${TEMP_LIB_PATH}-*&quot;</span> <span class="s2">&quot;{LIB_NAME}&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个脚本的用法就是将脚本和刚刚下载的 OpenSSL 源码压缩包放在同一个目录下，然后不用解压 OpenSSL 压缩包，直接运行脚本即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>sh  build-openssl.sh
</span></code></pre></td></tr></table></div></figure>


<p>耐心等待片刻之后，如果没有任何报错信息，则会在脚本所在目录多出两个目录 <code>include</code> 和 <code>lib</code>，在 <code>lib</code> 目录下就是我们刚刚通过脚本生成好的静态链接库 <code>libcrypto.a</code> 和 <code>libssl.a</code>。</p>

<h2>编译生成 Android 平台下适用的 OpenSSL 静态链接库</h2>

<p>接下来我们继续编译 Android 平台下的 OpenSSL 静态链接库。编译 Android 下的静态链接库自然要用到 NDK。所以首先要确保你下载了 NDK。我这里使用的是 <code>android-ndk-r10d</code>。</p>

<p>同样根据平台架构不同 Android 下面可以生成 <code>arm</code>、<code>armv7</code>和<code>x86</code>。具体的生成步骤都是直接在命令行下执行的。</p>

<p>首先解压缩你的 OpenSSL 源代码压缩包并跳转至解压缩后的源代码目录.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>tar -zxvf openssl-1.0.2c.tar.gz
</span><span class='line'><span class="nb">cd </span>openssl-1.0.2c
</span></code></pre></td></tr></table></div></figure>


<h3>armv7a</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#设置你自己的 NDK 路径</span>
</span><span class='line'><span class="nb">export </span><span class="nv">NDK</span><span class="o">=</span>/Your Android NDK Path/android-ndk-r10d
</span><span class='line'><span class="nv">$NDK</span>/build/tools/make-standalone-toolchain.sh --platform<span class="o">=</span>android-9 --toolchain<span class="o">=</span>arm-linux-androideabi-4.6 --install-dir<span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/android-toolchain-arm
</span><span class='line'><span class="nb">export </span><span class="nv">TOOLCHAIN_PATH</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/android-toolchain-arm/bin
</span><span class='line'><span class="nb">export </span><span class="nv">TOOL</span><span class="o">=</span>arm-linux-androideabi
</span><span class='line'><span class="nb">export </span><span class="nv">NDK_TOOLCHAIN_BASENAME</span><span class="o">=</span><span class="k">${</span><span class="nv">TOOLCHAIN_PATH</span><span class="k">}</span>/<span class="k">${</span><span class="nv">TOOL</span><span class="k">}</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CC</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-gcc
</span><span class='line'><span class="nb">export </span><span class="nv">CXX</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-g++
</span><span class='line'><span class="nb">export </span><span class="nv">LINK</span><span class="o">=</span><span class="k">${</span><span class="nv">CXX</span><span class="k">}</span>
</span><span class='line'><span class="nb">export </span><span class="nv">LD</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-ld
</span><span class='line'><span class="nb">export </span><span class="nv">AR</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-ar
</span><span class='line'><span class="nb">export </span><span class="nv">RANLIB</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-ranlib
</span><span class='line'><span class="nb">export </span><span class="nv">STRIP</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-strip
</span><span class='line'><span class="nb">export </span><span class="nv">ARCH_FLAGS</span><span class="o">=</span><span class="s2">&quot;-march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16&quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">ARCH_LINK</span><span class="o">=</span><span class="s2">&quot;-march=armv7-a -Wl,--fix-cortex-a8&quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CPPFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_FLAGS} -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 &quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CXXFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_FLAGS} -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions &quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_FLAGS} -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 &quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_LINK} &quot;</span>
</span><span class='line'>./Configure android-armv7
</span><span class='line'><span class="nv">PATH</span><span class="o">=</span><span class="nv">$TOOLCHAIN_PATH</span>:<span class="nv">$PATH</span> make
</span></code></pre></td></tr></table></div></figure>


<p>上述命令运行完成后，同样你会在 OpenSSL 源代码目录发现新生成的两个静态链接库文件<code>libcrypto.a</code> 和 <code>libssl.a</code>。我们新建一个目录 <code>armeabi-v7a</code> 将两个新生成的静态链接库文件移动到这个文件夹中备用。</p>

<p>然后我们删除掉刚刚解压缩的 OpenSSL 源码目录，重新解压缩 OpenSSL 的源代码压缩包，准备继续编译生成另外平台架构的静态链接库。</p>

<h3>arm</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#设置你自己的 NDK 路径</span>
</span><span class='line'><span class="nb">export </span><span class="nv">NDK</span><span class="o">=</span>/Your Android NDK Path/android-ndk-r10d
</span><span class='line'><span class="nv">$NDK</span>/build/tools/make-standalone-toolchain.sh --platform<span class="o">=</span>android-9 --toolchain<span class="o">=</span>arm-linux-androideabi-4.6 --install-dir<span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/android-toolchain-arm
</span><span class='line'><span class="nb">export </span><span class="nv">TOOLCHAIN_PATH</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/android-toolchain-arm/bin
</span><span class='line'><span class="nb">export </span><span class="nv">TOOL</span><span class="o">=</span>arm-linux-androideabi
</span><span class='line'><span class="nb">export </span><span class="nv">NDK_TOOLCHAIN_BASENAME</span><span class="o">=</span><span class="k">${</span><span class="nv">TOOLCHAIN_PATH</span><span class="k">}</span>/<span class="k">${</span><span class="nv">TOOL</span><span class="k">}</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CC</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-gcc
</span><span class='line'><span class="nb">export </span><span class="nv">CXX</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-g++
</span><span class='line'><span class="nb">export </span><span class="nv">LINK</span><span class="o">=</span><span class="k">${</span><span class="nv">CXX</span><span class="k">}</span>
</span><span class='line'><span class="nb">export </span><span class="nv">LD</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-ld
</span><span class='line'><span class="nb">export </span><span class="nv">AR</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-ar
</span><span class='line'><span class="nb">export </span><span class="nv">RANLIB</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-ranlib
</span><span class='line'><span class="nb">export </span><span class="nv">STRIP</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-strip
</span><span class='line'><span class="nb">export </span><span class="nv">ARCH_FLAGS</span><span class="o">=</span><span class="s2">&quot;-mthumb&quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">ARCH_LINK</span><span class="o">=</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CPPFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_FLAGS} -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 &quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CXXFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_FLAGS} -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions &quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_FLAGS} -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 &quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_LINK} &quot;</span>
</span><span class='line'>./Configure android
</span><span class='line'><span class="nv">PATH</span><span class="o">=</span><span class="nv">$TOOLCHAIN_PATH</span>:<span class="nv">$PATH</span> make
</span></code></pre></td></tr></table></div></figure>


<p>然后我们新建一个目录 <code>armeabi</code> 将新生成的静态链接库文件 <code>libcrypto.a</code> 和 <code>libssl.a</code> 移动到这个文件夹中备用。删除掉源代码目录，重新解压，继续编译生成静态链接库。</p>

<h3>x86</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#设置你自己的 NDK 路径</span>
</span><span class='line'><span class="nb">export </span><span class="nv">NDK</span><span class="o">=</span>/Your Android NDK Path/android-ndk-r10d
</span><span class='line'><span class="nv">$NDK</span>/build/tools/make-standalone-toolchain.sh --platform<span class="o">=</span>android-9 --toolchain<span class="o">=</span>x86-4.6 --install-dir<span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/android-toolchain-x86
</span><span class='line'><span class="nb">export </span><span class="nv">TOOLCHAIN_PATH</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/android-toolchain-x86/bin
</span><span class='line'><span class="nb">export </span><span class="nv">TOOL</span><span class="o">=</span>i686-linux-android
</span><span class='line'><span class="nb">export </span><span class="nv">NDK_TOOLCHAIN_BASENAME</span><span class="o">=</span><span class="k">${</span><span class="nv">TOOLCHAIN_PATH</span><span class="k">}</span>/<span class="k">${</span><span class="nv">TOOL</span><span class="k">}</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CC</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-gcc
</span><span class='line'><span class="nb">export </span><span class="nv">CXX</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-g++
</span><span class='line'><span class="nb">export </span><span class="nv">LINK</span><span class="o">=</span><span class="k">${</span><span class="nv">CXX</span><span class="k">}</span>
</span><span class='line'><span class="nb">export </span><span class="nv">LD</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-ld
</span><span class='line'><span class="nb">export </span><span class="nv">AR</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-ar
</span><span class='line'><span class="nb">export </span><span class="nv">RANLIB</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-ranlib
</span><span class='line'><span class="nb">export </span><span class="nv">STRIP</span><span class="o">=</span><span class="nv">$NDK_TOOLCHAIN_BASENAME</span>-strip
</span><span class='line'><span class="nb">export </span><span class="nv">ARCH_FLAGS</span><span class="o">=</span><span class="s2">&quot;-march=i686 -msse3 -mstackrealign -mfpmath=sse&quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">ARCH_LINK</span><span class="o">=</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CPPFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_FLAGS} -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 &quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CXXFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_FLAGS} -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 -frtti -fexceptions &quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_FLAGS} -fpic -ffunction-sections -funwind-tables -fstack-protector -fno-strict-aliasing -finline-limit=64 &quot;</span>
</span><span class='line'><span class="nb">export </span><span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">&quot; ${ARCH_LINK} &quot;</span>
</span><span class='line'>./Configure android-x86
</span><span class='line'><span class="nv">PATH</span><span class="o">=</span><span class="nv">$TOOLCHAIN_PATH</span>:<span class="nv">$PATH</span> make
</span></code></pre></td></tr></table></div></figure>


<p>同样我们新建一个目录 <code>x86</code> 用来存放新生成的静态链接库文件 <code>libcrypto.a</code> 和 <code>libssl.a</code>。</p>

<h2>将 OpenSSL 接入 Cocos2d-x 项目</h2>

<p>iOS 和 Android 适用的 OpenSSL 静态链接库我们都已经编译生成了。下面看看我们怎么将 OpenSSL 静态链接库接入到 Cocos2d-x 项目中来使用。</p>

<h3>引入 iOS 适用的 OpenSSL 静态链接库</h3>

<p>首先这里要说明的是我使用的 Cocos2d-x 版本是 3.6。我们先在 Cocos2d-x  项目中新建一个文件夹。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>mkdir -p Your_Cocos2d-x_Project_Path/Classes/security/openssl
</span></code></pre></td></tr></table></div></figure>


<p>然后我们将 iOS 适用的 OpenSSL 静态链接库文件 <code>libcrypto.a</code> 和 <code>libssl.a</code> 拷贝到我们刚刚新建的目录下。</p>

<p>在 Xcode 中将 OpenSSL 的静态链接库文件<code>libcrypto.a</code> 和 <code>libssl.a</code> 引入到项目中。具体做法就是在 <code>[Build Phases] ====&gt; [Link Binary With Libraries]</code> 中添加对两个静态链接库的引用。</p>

<h3>在 Xcode 中添加 OpenSSL 头文件搜索路径</h3>

<p>然后我们再新建一个用于存放 OpenSSL 头文件的文件夹</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>mkdir -p Your_Cocos2d-x_Project_Path/Classes/security/openssl/include/openssl
</span></code></pre></td></tr></table></div></figure>


<p>将我们刚刚生成 iOS 适用的 OpenSSL 静态链接库文件时生成的 <code>include</code> 文件夹下面找到的所有的 <code>.h</code> 头文件全部复制到我们刚刚生成的目录下面。</p>

<p><strong>这里需要特别注意</strong>的是包含 OpenSSL 头文件的文件夹必须叫作 <strong>openssl</strong> ，否则项目编译会不成功。</p>

<p>然后继续在 Xcode 中设置 OpenSSL 头文件的搜索路径。具体做法就是在 <code>[Build Settings] ====&gt; [User Header Search Paths]</code> 中添加刚刚我们建立的用于存放 OpenSSL 头文件的目录的路径。要添加的路径为 <code>Your_Cocos2d-x_Project_Path/Classes/security/openssl/include</code></p>

<h3>引入 Android 适用的 OpenSSL 静态链接库</h3>

<p>我们把刚刚用于存放 OpenSSL 静态链接库文件的 <code>armeabi</code> 文件夹拷贝到 Cocos2d-x 项目中来，拷贝的位置是 Android 用于存放库文件的 <code>libs</code> 文件夹。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>cp -ivr Your_OpenSSL_Android_Path/armeabi  <span class="se">\</span>
</span><span class='line'>  Your_Cocos2d-x_Project_Path/proj.android/libs/
</span></code></pre></td></tr></table></div></figure>


<p><strong>这里需要特别注意</strong>如果你的 Cocos2d-x 项目原本已经有了 <code>armeabi</code> 文件夹，注意不要覆盖，而是将 <code>libcrypto.a</code> 和 <code>libssl.a</code> 文件直接放入已有的 <code>armeabi</code> 文件夹中即可。</p>

<h3>在 Android.mk 文件中添加 OpenSSL 头文件搜索路径</h3>

<p>用趁手的编辑器打开 <code>Your_Cocos2d-x_Project_Path/proj.android/jni/Android.mk</code> 文件，将 OpenSSL 头文件路径添加到 <code>LOCAL_C_INCLUDES</code> 变量中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>LOCAL_C_INCLUDES :<span class="o">=</span> <span class="se">\</span>
</span><span class='line'>  <span class="c"># ... Some Other Paths \</span>
</span><span class='line'>  <span class="k">$(</span>LOCAL_PATH<span class="k">)</span>/../../Classes/security/openssl/include <span class="se">\</span>
</span><span class='line'>  <span class="c"># ... Some Other Paths \</span>
</span></code></pre></td></tr></table></div></figure>


<h2>走个捷径</h2>

<p>如果你觉得编译太麻烦，要编译的东西太多太复杂，或者手头没有编译环境，翻墙下载个 NDK 又太费劲巴拉巴拉&hellip;&hellip;总之你不想自己编译 OpenSSL 的静态链接库，那么你可以走一个捷径。直接使用我已经编译好的文件即可。<a href="https://github.com/leenjewel/openssl_for_ios_and_android">我已经把编译好的 OpenSSL 静态链接库放在 GitHub 上方便大家自取了</a>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>git clone git@github.com:leenjewel/openssl_for_ios_and_android.git
</span></code></pre></td></tr></table></div></figure>


<h2>参考资料</h2>

<p>如果你的 Cocos2d-x 项目编译运行成功，那么恭喜你，OpenSSL 库已经接入到你得项目中了，你已经可以调用 OpenSSL 的 API 来实现你自己的需求了。这里附上两个相关的资料供你参考：</p>

<blockquote><p>《How-To-Build-openssl-For-iOS》</p>

<p>《Compiling the latest OpenSSL for Android》</p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-06-30T14:13:22+08:00" pubdate data-updated="true">2015年6月30日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/cocos2d/'>cocos2d</a>


</div>
	
	<div class="comments"><a href="/blog/2015/06/30/zai-cocos2d-x-zhong-shi-yong-openssl/#disqus_thread">Comments</a></div>
	
	<div>
		<br/><div>如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</div>
		<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="post" target="_blank" accept-charset="GBK" id="alipayForm">
			<input name="optEmail" type="hidden" value="leenjewel@gmail.com" />
			<input name="payAmount" type="hidden" value="1.00" />
			<input id="title" name="title" type="hidden" value="捐赠给 leenjewel.github.io" />
			<input name="memo" type="hidden" value="文章写的不错，我来捐赠鼓励的！" />
			<input name="pay" type="image" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" width="150" height="40">
		</form>
	</div>
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/05/26/%5B%28xue-xi-xv6%29%5D-jia-zai-bing-yun-xing-nei-he/">
		
			【学习Xv6】加载并运行内核</a>
	</h2>
	<div class="entry-content">
		<h2>前情提要</h2>

<p>学习 xv6 系列的上一篇<a href="http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">《【学习xv6】从实模式到保护模式》</a>讲到我们的系统已经将计算机的 CPU 从实模式切换到保护模式状态下了，接下来我们可以暂时告别晦涩难懂的汇编语言来到 C 语言环境中了，引导的工作快要接近尾声，内核即将被载入运行。</p>

<h2>预备知识</h2>

<h3>从硬盘读取数据</h3>

<p>在<a href="http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">《【学习xv6】从实模式到保护模式》</a>中我们已经讲到了如何通过向 804x 键盘控制器端口发送信号来打开 A20 gate 了，同样道理，我们向硬盘控制器的指定端口发送信号就可以操作硬盘，从硬盘读取或向硬盘写入数据。IDE 标准定义了 8 个寄存器来操作硬盘。PC 体系结构将第一个硬盘控制器映射到端口 1F0-1F7 处，而第二个硬盘控制器则被映射到端口 170-177 处。这几个寄存器的描述如下（以第一个控制器为例）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1F0        - 数据寄存器。读写数据都必须通过这个寄存器
</span><span class='line'>
</span><span class='line'>1F1        - 错误寄存器，每一位代表一类错误。全零表示操作成功。
</span><span class='line'>
</span><span class='line'>1F2        - 扇区计数。这里面存放你要操作的扇区数量
</span><span class='line'>
</span><span class='line'>1F3        - 扇区LBA地址的0-7位
</span><span class='line'>
</span><span class='line'>1F4        - 扇区LBA地址的8-15位
</span><span class='line'>
</span><span class='line'>1F5        - 扇区LBA地址的16-23位
</span><span class='line'>
</span><span class='line'>1F6 (低4位) - 扇区LBA地址的24-27位
</span><span class='line'>
</span><span class='line'>1F6 (第4位) - 0表示选择主盘，1表示选择从盘
</span><span class='line'>
</span><span class='line'>1F6 (5-7位) - 必须为1
</span><span class='line'>
</span><span class='line'>1F7 (写)    - 命令寄存器
</span><span class='line'>
</span><span class='line'>1F7 (读)    - 状态寄存器
</span><span class='line'>
</span><span class='line'>              bit 7 = 1  控制器忙
</span><span class='line'>              bit 6 = 1  驱动器就绪
</span><span class='line'>              bit 5 = 1  设备错误
</span><span class='line'>              bit 4        N/A
</span><span class='line'>              bit 3 = 1  扇区缓冲区错误
</span><span class='line'>              bit 2 = 1  磁盘已被读校验
</span><span class='line'>              bit 1        N/A
</span><span class='line'>              bit 0 = 1  上一次命令执行失败</span></code></pre></td></tr></table></div></figure>


<p>稍后讲到从硬盘加载内核到内存时我们再通过 xv6 的实际代码来看看硬盘操作的具体实现。</p>

<h3>ELF文件格式</h3>

<p>在<a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format"> Wiki 百科上有 ELF 文件格式的详细解释</a>，简单的说 ELF 文件格式是 Linux 下可执行文件的标准格式。就好像 Windows 操作系统里的可执行文件 .exe 一样（当然，Windows 里的可执行文件的标准格式叫 PE 文件格式），Linux 操作系统里的可执行文件也有它自己的格式。只有按照文件标准格式组织好的可执行文件操作系统才知道如何加载运行它。我们并使使用 C 语言按照教科书写出的 HelloWorld 代码在 Linux 环境下最终通过编译器（gcc等）编译出的可以运行的程序就是 ELF 文件格式的。</p>

<p>那么 ELF 文件格式具体的结构是怎样的呢？ 大概是下面这个样子的。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center"> ELF 头部 ( ELF Header ) </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> 程序头表 (Program Header Table) </td>
</tr>
<tr>
<td></td>
<td align="center">.text</td>
</tr>
<tr>
<td></td>
<td align="center">.rodata</td>
</tr>
<tr>
<td></td>
<td align="center">&hellip;&hellip;</td>
</tr>
<tr>
<td></td>
<td align="center">节头表 (Section Header Table)</td>
</tr>
</tbody>
</table>


<p>这里我们暂时只关心 ELF 文件结构的前两个部分：ELF 头部和程序头表，xv6 源代码的 elf.h 文件中有其详细的定义，我们来看一下。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define ELF_MAGIC 0x464C457FU  </span><span class="c1">// &quot;\x7FELF&quot; in little endian</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ELF 文件格式的头部</span>
</span><span class='line'><span class="k">struct</span> <span class="n">elfhdr</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">magic</span><span class="p">;</span>       <span class="c1">// 4 字节，为 0x464C457FU（大端模式）或 0x7felf（小端模式）</span>
</span><span class='line'>                      <span class="c1">// 表明该文件是个 ELF 格式文件</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uchar</span> <span class="n">elf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>    <span class="c1">// 12 字节，每字节对应意义如下：</span>
</span><span class='line'>                    <span class="c1">//     0 : 1 = 32 位程序；2 = 64 位程序</span>
</span><span class='line'>                    <span class="c1">//     1 : 数据编码方式，0 = 无效；1 = 小端模式；2 = 大端模式</span>
</span><span class='line'>                    <span class="c1">//     2 : 只是版本，固定为 0x1</span>
</span><span class='line'>                    <span class="c1">//     3 : 目标操作系统架构</span>
</span><span class='line'>                    <span class="c1">//     4 : 目标操作系统版本</span>
</span><span class='line'>                    <span class="c1">//     5 ~ 11 : 固定为 0</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">type</span><span class="p">;</span>      <span class="c1">// 2 字节，表明该文件类型，意义如下：</span>
</span><span class='line'>                    <span class="c1">//     0x0 : 未知目标文件格式</span>
</span><span class='line'>                    <span class="c1">//     0x1 : 可重定位文件</span>
</span><span class='line'>                    <span class="c1">//     0x2 : 可执行文件</span>
</span><span class='line'>                    <span class="c1">//     0x3 : 共享目标文件</span>
</span><span class='line'>                    <span class="c1">//     0x4 : 转储文件</span>
</span><span class='line'>                    <span class="c1">//     0xff00 : 特定处理器文件</span>
</span><span class='line'>                    <span class="c1">//     0xffff : 特定处理器文件</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">machine</span><span class="p">;</span>   <span class="c1">// 2 字节，表明运行该程序需要的计算机体系架构，</span>
</span><span class='line'>                    <span class="c1">// 这里我们只需要知道 0x0 为未指定；0x3 为 x86 架构</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uint</span> <span class="n">version</span><span class="p">;</span>     <span class="c1">// 4 字节，表示该文件的版本号</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uint</span> <span class="n">entry</span><span class="p">;</span>       <span class="c1">// 4 字节，该文件的入口地址，没有入口（非可执行文件）则为 0</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uint</span> <span class="n">phoff</span><span class="p">;</span>       <span class="c1">// 4 字节，表示该文件的“程序头部表”相对于文件的位置，单位是字节</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uint</span> <span class="n">shoff</span><span class="p">;</span>       <span class="c1">// 4 字节，表示该文件的“节区头部表”相对于文件的位置，单位是字节</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>       <span class="c1">// 4 字节，特定处理器标志</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">ehsize</span><span class="p">;</span>    <span class="c1">// 2 字节，ELF文件头部的大小，单位是字节</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">phentsize</span><span class="p">;</span> <span class="c1">// 2 字节，表示程序头部表中一个入口的大小，单位是字节</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">phnum</span><span class="p">;</span>     <span class="c1">// 2 字节，表示程序头部表的入口个数，</span>
</span><span class='line'>                    <span class="c1">// phnum * phentsize = 程序头部表大小（单位是字节）</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">shentsize</span><span class="p">;</span> <span class="c1">// 2 字节，节区头部表入口大小，单位是字节</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">shnum</span><span class="p">;</span>     <span class="c1">// 2 字节，节区头部表入口个数，</span>
</span><span class='line'>                    <span class="c1">// shnum * shentsize = 节区头部表大小（单位是字节）</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ushort</span> <span class="n">shstrndx</span><span class="p">;</span>  <span class="c1">// 2 字节，表示字符表相关入口的节区头部表索引</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 程序头表</span>
</span><span class='line'><span class="k">struct</span> <span class="n">proghdr</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">type</span><span class="p">;</span>        <span class="c1">// 4 字节， 段类型</span>
</span><span class='line'>                    <span class="c1">//         1 PT_LOAD : 可载入的段</span>
</span><span class='line'>                    <span class="c1">//         2 PT_DYNAMIC : 动态链接信息</span>
</span><span class='line'>                    <span class="c1">//         3 PT_INTERP : 指定要作为解释程序调用的以空字符结尾的路径名的位置和大小</span>
</span><span class='line'>                    <span class="c1">//         4 PT_NOTE : 指定辅助信息的位置和大小</span>
</span><span class='line'>                    <span class="c1">//         5 PT_SHLIB : 保留类型，但具有未指定的语义</span>
</span><span class='line'>                    <span class="c1">//         6 PT_PHDR : 指定程序头表在文件及程序内存映像中的位置和大小</span>
</span><span class='line'>                    <span class="c1">//         7 PT_TLS : 指定线程局部存储模板</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">off</span><span class="p">;</span>         <span class="c1">// 4 字节， 段的第一个字节在文件中的偏移</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">vaddr</span><span class="p">;</span>       <span class="c1">// 4 字节， 段的第一个字节在内存中的虚拟地址</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">paddr</span><span class="p">;</span>       <span class="c1">// 4 字节， 段的第一个字节在内存中的物理地址(适用于物理内存定位型的系统)</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">filesz</span><span class="p">;</span>      <span class="c1">// 4 字节， 段在文件中的长度</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">memsz</span><span class="p">;</span>       <span class="c1">// 4 字节， 段在内存中的长度</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>       <span class="c1">// 4 字节， 段标志</span>
</span><span class='line'>                    <span class="c1">//         1 : 可执行</span>
</span><span class='line'>                    <span class="c1">//         2 : 可写入</span>
</span><span class='line'>                    <span class="c1">//         4 : 可读取</span>
</span><span class='line'>  <span class="n">uint</span> <span class="n">align</span><span class="p">;</span>       <span class="c1">// 4 字节， 段在文件及内存中如何对齐</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ELF文件的加载与运行</h3>

<p>既然 ELF 标准文件格式是可执行文件（当然不仅仅用于可执行文件，还可以用于动态链接库文件等）使用的文件格式，那么它一定是可以被加载并运行的。学习 xv6 系列的上一篇<a href="http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">《【学习xv6】从实模式到保护模式》</a>的预备知识中我们讲到</p>

<blockquote><p>程序的组成我们可以简单的理解为：数据加上指令就是程序。</p></blockquote>

<p>我们写好的程序代码经过编译器的编译成为机器码，而机器码根据其自身的作用不同被分为不同的段，其中最主要的就是<strong>代码段</strong>和<strong>数据段</strong>。</p>

<p>而一个可执行程序又是有很多个这样的段组成的，一个可执行程序可以有好几个代码段和好几个数据段和其他不同的段。当一个程序准备运行的时候，操作系统会将程序的这些段载入到内从中，再通知 CPU 程序代码段的位置已经开始执行指令的点即入口点。</p>

<p>既然一个可执行程序有多个代码段、多个数据段和其他段，操作系统在加载这些段的时候为了更好的组织利用内存，希望将一些列作用相同的段放在一起加载（比如多个代码段就可以一并加载），编译器为了方便操作系统加载这些作用相同的段，在编译的时候会刻意将作用相同的段安排在一起。而这些作用相同的段在程序中（ELF文件）中是如何组织的，这些组织信息就被记录在 ELF 文件的程序头表中。</p>

<p>所以一个 ELF 文件格式的可执行程序的加载运行过程是这样的：</p>

<ul>
<li>通过读取 ELF 头表中的信息了解该可执行程序是否可以运行（版本号，适用的计算机架构等等）</li>
<li>通过 ELF 头表中的信息找到程序头表</li>
<li>通过读取 ELF 文件中程序头表的信息了解可执行文件中各个段的位置以及加载方式</li>
<li>将可执行文件中需要加载的段加载到内存中，并通知 CPU 从指定的入口点开始执行</li>
</ul>


<h2>从 bootmain 开始</h2>

<p>学习 xv6 系列的上一篇<a href="http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">《【学习xv6】从实模式到保护模式》</a>的最后我们写到</p>

<blockquote><p>通过这个跳转实际上 CPU 就会跳转到 bootasm.S 文件的 start32 标识符处继续执行了</p></blockquote>

<p>我们打开 bootasm.S 文件看看对应的 start32 位置处的代码做了什么事情。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="nl">start32:</span>
</span><span class='line'>  <span class="err">#</span> <span class="n">Set</span> <span class="n">up</span> <span class="n">the</span> <span class="n">protected</span><span class="o">-</span><span class="n">mode</span> <span class="n">data</span> <span class="n">segment</span> <span class="n">registers</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">像上面讲</span> <span class="n">ljmp</span> <span class="err">时所说的，这时候已经在保护模式下了</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">数据段在</span> <span class="n">GDT</span> <span class="err">中的下标是</span> <span class="mi">2</span><span class="err">，所以这里数据段的段选择子是</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span> <span class="o">=</span> <span class="mo">0000</span> <span class="mo">0000</span> <span class="mo">0001</span> <span class="mo">0000</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">这</span> <span class="mi">16</span> <span class="err">位的段选择子中的前</span> <span class="mi">13</span> <span class="err">位是</span> <span class="n">GDT</span> <span class="err">段表下标，这里前</span> <span class="mi">13</span> <span class="err">位的值是</span> <span class="mi">2</span> <span class="err">代表选择了数据段</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">这里将</span> <span class="mi">3</span> <span class="err">个数据段寄存器都赋值成数据段段选择子的值</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="err">$</span><span class="p">(</span><span class="n">SEG_KDATA</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span> <span class="o">%</span><span class="n">ax</span>    <span class="err">#</span> <span class="n">Our</span> <span class="n">data</span> <span class="n">segment</span> <span class="n">selector</span>  <span class="err">段选择子赋值给</span> <span class="n">ax</span> <span class="err">寄存器</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">ds</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="n">DS</span><span class="o">:</span> <span class="n">Data</span> <span class="n">Segment</span>        <span class="err">初始化数据段寄存器</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">es</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="n">ES</span><span class="o">:</span> <span class="n">Extra</span> <span class="n">Segment</span>       <span class="err">初始化扩展段寄存器</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">ss</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="n">SS</span><span class="o">:</span> <span class="n">Stack</span> <span class="n">Segment</span>       <span class="err">初始化堆栈段寄存器</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="n">ax</span>                 <span class="err">#</span> <span class="n">Zero</span> <span class="n">segments</span> <span class="n">not</span> <span class="n">ready</span> <span class="k">for</span> <span class="n">use</span>  <span class="n">ax</span> <span class="err">寄存器清零</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">fs</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="n">FS</span>                      <span class="err">辅助寄存器清零</span>
</span><span class='line'>  <span class="n">movw</span>    <span class="o">%</span><span class="n">ax</span><span class="p">,</span> <span class="o">%</span><span class="n">gs</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="n">GS</span>                      <span class="err">辅助寄存器清零</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">#</span> <span class="n">Set</span> <span class="n">up</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">pointer</span> <span class="n">and</span> <span class="n">call</span> <span class="n">into</span> <span class="n">C</span><span class="p">.</span>
</span><span class='line'>  <span class="n">movl</span>    <span class="err">$</span><span class="n">start</span><span class="p">,</span> <span class="o">%</span><span class="n">esp</span>
</span><span class='line'>  <span class="n">call</span>    <span class="n">bootmain</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里在初始化了一些寄存器后直接调用了一个叫做 <code>bootmain</code> 的函数，而这个函数是写在 bootmain.c 文件中的，终于我们暂时告别了汇编来到了 C 的世界了。来看看 bootmain 函数在做什么事情。</p>

<h2>载入内核</h2>

<p>bootmain.c 这个文件很小，代码很少，它其实是引导工作的最后部分（引导的大部分工作都在 bootasm.S 中实现），它负责将内核从硬盘上加载到内存中，然后开始执行内核中的程序。我们来看代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define SECTSIZE  512  </span><span class="c1">// 硬盘扇区大小 512 字节</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">bootmain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">uchar</span><span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从 0xa0000 到 0xfffff 的物理地址范围属于设备空间，</span>
</span><span class='line'>  <span class="c1">// 所以内核放置在 0x10000 处开始</span>
</span><span class='line'>  <span class="n">elf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="o">*</span><span class="p">)</span><span class="mh">0x10000</span><span class="p">;</span>  <span class="c1">// scratch space</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从内核所在硬盘位置读取一内存页 4kb 数据</span>
</span><span class='line'>  <span class="n">readseg</span><span class="p">((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 判断是否为 ELF 文件格式</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">ELF_MAGIC</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>  <span class="c1">// let bootasm.S handle error</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 加载 ELF 文件中的程序段 (ignores ph flags).</span>
</span><span class='line'>  <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proghdr</span><span class="o">*</span><span class="p">)((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span> <span class="o">+</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">phoff</span><span class="p">);</span>
</span><span class='line'>  <span class="n">eph</span> <span class="o">=</span> <span class="n">ph</span> <span class="o">+</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">phnum</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">;</span>
</span><span class='line'>    <span class="n">readseg</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">off</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">memsz</span> <span class="o">&gt;</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">)</span>
</span><span class='line'>      <span class="n">stosb</span><span class="p">(</span><span class="n">pa</span> <span class="o">+</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">memsz</span> <span class="o">-</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Call the entry point from the ELF header.</span>
</span><span class='line'>  <span class="c1">// Does not return!</span>
</span><span class='line'>  <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
</span><span class='line'>  <span class="n">entry</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里将内核（一个 ELF 格式文件）从硬盘读取到内存 <code>0x10000</code> 处的关键方法是 <code>readseg(uchar*, uint, uint)</code> 我们再来看看这个函数的具体实现代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">readseg</span><span class="p">(</span><span class="n">uchar</span><span class="o">*</span> <span class="n">pa</span><span class="p">,</span> <span class="n">uint</span> <span class="n">count</span><span class="p">,</span> <span class="n">uint</span> <span class="n">offset</span><span class="p">)</span>  <span class="c1">// 0x10000, 4096(0x1000), 0</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">uchar</span><span class="o">*</span> <span class="n">epa</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">epa</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">+</span> <span class="n">count</span><span class="p">;</span>  <span class="c1">// 0x11000</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 根据扇区大小 512 字节做对齐</span>
</span><span class='line'>  <span class="n">pa</span> <span class="o">-=</span> <span class="n">offset</span> <span class="o">%</span> <span class="n">SECTSIZE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// bootblock 引导区在第一扇区（下标为 0），内核在第二个扇区（下标为 1）</span>
</span><span class='line'>  <span class="c1">// 这里做 +1 操作是统一略过引导区</span>
</span><span class='line'>  <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">/</span> <span class="n">SECTSIZE</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// If this is too slow, we could read lots of sectors at a time.</span>
</span><span class='line'>  <span class="c1">// We&#39;d write more to memory than asked, but it doesn&#39;t matter --</span>
</span><span class='line'>  <span class="c1">// we load in increasing order.</span>
</span><span class='line'>  <span class="c1">// 一次读取一个扇区 512 字节的数据</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(;</span> <span class="n">pa</span> <span class="o">&lt;</span> <span class="n">epa</span><span class="p">;</span> <span class="n">pa</span> <span class="o">+=</span> <span class="n">SECTSIZE</span><span class="p">,</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="n">readsect</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们来看看为什么说内核在磁盘的第二扇区，引导区在磁盘的第一扇区。在 xv6 系列文章的第一篇<a href="http://leenjewel.github.io/blog/2014/07/24/%5B%28xue-xi-xv6-%29%5D-zai-mac-osx-xia-yun-xing-xv6/">《【学习 Xv6 】在 Mac OSX 下运行 Xv6》</a>里讲到过</p>

<blockquote><p>编译成功后我们会得到 xv6.img 和 fs.img 两个文件。</p>

<p>在 Hardware 配置页的 Hard disk 里把 xv6.img 载入进去。</p>

<p>在 Advanced 配置页的 Hard disk 2 里把 fs.img 载入进去。</p></blockquote>

<p>由此我们可以猜测内核应该在 xv6.img 这个镜像文件中。下面我们通过 Makefile 来印证这一点，我们看一下 xv6 的 Makefile 文件关于 xv6.img 构建过程的说明</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">xv6</span><span class="p">.</span><span class="n">img</span><span class="o">:</span> <span class="n">bootblock</span> <span class="n">kernel</span> <span class="n">fs</span><span class="p">.</span><span class="n">img</span>
</span><span class='line'>  <span class="n">dd</span> <span class="k">if</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">zero</span> <span class="n">of</span><span class="o">=</span><span class="n">xv6</span><span class="p">.</span><span class="n">img</span> <span class="n">count</span><span class="o">=</span><span class="mi">10000</span>
</span><span class='line'>  <span class="n">dd</span> <span class="k">if</span><span class="o">=</span><span class="n">bootblock</span> <span class="n">of</span><span class="o">=</span><span class="n">xv6</span><span class="p">.</span><span class="n">img</span> <span class="n">conv</span><span class="o">=</span><span class="n">notrunc</span>
</span><span class='line'>  <span class="n">dd</span> <span class="k">if</span><span class="o">=</span><span class="n">kernel</span> <span class="n">of</span><span class="o">=</span><span class="n">xv6</span><span class="p">.</span><span class="n">img</span> <span class="n">seek</span><span class="o">=</span><span class="mi">1</span> <span class="n">conv</span><span class="o">=</span><span class="n">notrunc</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出 xv6.img 是一个由 10000 个扇区组成的（512b x 10000 = 5 MB），而里面包含的只有 <code>bootblock</code> 和 <code>kernel</code> 两个块，通过名字我们不难看出 <code>bootblock</code> 就是引导区，它的大小正好是 512 字节即一个磁盘扇区大小（可以通过文件浏览器看到），所以根据它们写入 xv6.img 的顺序我们证实了猜测，在 xv6 系统中引导区占一个磁盘扇区大小，放置在磁盘的第一扇区，紧随其后的是内核文件（ELF 文件格式）。我们用一个十六进制编辑器打开 kernel 文件看看，可以看到开头的数据内如如下</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">magic</th>
<th align="center">elf[12]</th>
<th align="center">type</th>
<th align="center">machine</th>
<th align="center">version</th>
<th align="center">entry</th>
<th align="center">phoff</th>
<th align="center">shoff</th>
<th align="center">flags</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">7F 45 4C 46</td>
<td align="center">01 01 01 00 00 00 00 00 00 00 00 00</td>
<td align="center">02 00</td>
<td align="center">03 00</td>
<td align="center">01 00 00 00</td>
<td align="center">0C 00 10 00</td>
<td align="center">34 00 00 00</td>
<td align="center">00 F6 01 00</td>
<td align="center">00 00 00 00|</td>
</tr>
<tr>
<td></td>
<td align="center">ehsize</td>
<td align="center">phentsize</td>
<td align="center">phnum</td>
<td align="center">shentsize</td>
<td align="center">shnum</td>
<td align="center">shstrndx</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="center">34 00</td>
<td align="center">20 00</td>
<td align="center">02 00</td>
<td align="center">28 00</td>
<td align="center">12 00</td>
<td align="center">0F 00</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>


<p>而内核文件的前 4 字节正式 ELF 文件头的模数 <code>ELF_MAGIC 0x464C457F</code> 这也说明了内核文件确实是一个 ELF 格式的文件。如果我们按照 ELF 文件结构重拍上面的机器码会是这样</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">字段名称</th>
<th align="center">大小</th>
<th align="center">数值</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">magic</td>
<td align="center">4字节</td>
<td align="center">7F 45 4C 46</td>
<td align="center">ELF 格式文件|</td>
</tr>
<tr>
<td></td>
<td align="center">elf</td>
<td align="center">12字节</td>
<td align="center">01 01 01 00 00 00 00 00 00 00 00 00</td>
<td align="center"> 32 位小端模式，目标操作系统为 System V</td>
</tr>
<tr>
<td></td>
<td align="center">type</td>
<td align="center">2字节</td>
<td align="center">02 00</td>
<td align="center">可执行文件|</td>
</tr>
<tr>
<td></td>
<td align="center">machine</td>
<td align="center">2字节</td>
<td align="center">03 00</td>
<td align="center">指定计算机体系架构为 x86|</td>
</tr>
<tr>
<td></td>
<td align="center">version</td>
<td align="center">4字节</td>
<td align="center">01 00 00 00</td>
<td align="center">版本号为 1|</td>
</tr>
<tr>
<td></td>
<td align="center">entry</td>
<td align="center">4字节</td>
<td align="center">0C 00 10 00</td>
<td align="center">该可执行文件入口地址|</td>
</tr>
<tr>
<td></td>
<td align="center">phoff</td>
<td align="center">4字节</td>
<td align="center">34 00 00 00</td>
<td align="center">程序头表相对于文件的起始位置是 52 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">shoff</td>
<td align="center">4字节</td>
<td align="center">00 F6 01 00</td>
<td align="center">节区头表相对于文件的起始位置是 128512 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">flags</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">无特定处理器标志|</td>
</tr>
<tr>
<td></td>
<td align="center">ehsize</td>
<td align="center">2字节</td>
<td align="center">34 00</td>
<td align="center">ELF 头大小为 52 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">phentsize</td>
<td align="center">2字节</td>
<td align="center">20 00</td>
<td align="center">程序头表一个入口的大小是 32 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">phnum</td>
<td align="center">2字节</td>
<td align="center">02 00</td>
<td align="center">程序头表入口个数是 2 个|</td>
</tr>
<tr>
<td></td>
<td align="center">shentsize</td>
<td align="center">2字节</td>
<td align="center">28 00</td>
<td align="center">节区头表入口大小是 40 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">shnum</td>
<td align="center">2字节</td>
<td align="center">12 00</td>
<td align="center">节区头表入口个数是 18 个|</td>
</tr>
<tr>
<td></td>
<td align="center">shstrndx</td>
<td align="center">2字节</td>
<td align="center">0F 00</td>
<td align="center">字符表入口在节区头表的索引是 15|</td>
</tr>
</tbody>
</table>


<p>通过十六进制编辑器逐个字节的去分析内核文件的 ELF 头部是希望大家能有个更直观的认识，当然了 Linux 也为我们提供了方便的工具 <code>readelf</code> 命令来检查 ELF 文件的相关信息。我们再通过 <code>readelf</code> 命令验证一下我们刚刚通过十六进制编辑器分析的结果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>readelf -h kernel
</span><span class='line'>ELF Header:
</span><span class='line'>  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
</span><span class='line'>  Class:                             ELF32
</span><span class='line'>  Data:                              2<span class="err">&#39;</span>s complement, little endian
</span><span class='line'>  Version:                           1 <span class="o">(</span>current<span class="o">)</span>
</span><span class='line'>  OS/ABI:                            UNIX - System V
</span><span class='line'>  ABI Version:                       0
</span><span class='line'>  Type:                              EXEC <span class="o">(</span>Executable file<span class="o">)</span>
</span><span class='line'>  Machine:                           Intel 80386
</span><span class='line'>  Version:                           0x1
</span><span class='line'>  Entry point address:               0x10000c
</span><span class='line'>  Start of program headers:          52 <span class="o">(</span>bytes into file<span class="o">)</span>
</span><span class='line'>  Start of section headers:          128512 <span class="o">(</span>bytes into file<span class="o">)</span>
</span><span class='line'>  Flags:                             0x0
</span><span class='line'>  Size of this header:               52 <span class="o">(</span>bytes<span class="o">)</span>
</span><span class='line'>  Size of program headers:           32 <span class="o">(</span>bytes<span class="o">)</span>
</span><span class='line'>  Number of program headers:         2
</span><span class='line'>  Size of section headers:           40 <span class="o">(</span>bytes<span class="o">)</span>
</span><span class='line'>  Number of section headers:         18
</span><span class='line'>  Section header string table index: 15
</span></code></pre></td></tr></table></div></figure>


<p>最后我们看一下从磁盘读取内核到内存的方法实现，看看是怎样通过向特定端口发送数据来达到操作磁盘目的的。具体的说明请看代码附带的注释。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// Read a single sector at offset into dst.</span>
</span><span class='line'><span class="c1">// 这里使用的是 LBA 磁盘寻址模式</span>
</span><span class='line'><span class="c1">// LBA是非常单纯的一种寻址模式﹔从0开始编号来定位区块，</span>
</span><span class='line'><span class="c1">// 第一区块LBA=0，第二区块LBA=1，依此类推</span>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">readsect</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">uint</span> <span class="n">offset</span><span class="p">)</span>      <span class="c1">// 0x10000, 1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// Issue command.</span>
</span><span class='line'>  <span class="n">waitdisk</span><span class="p">();</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>                     <span class="c1">// 要读取的扇区数量 count = 1</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F3</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>                <span class="c1">// 扇区 LBA 地址的 0-7 位</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F4</span><span class="p">,</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>           <span class="c1">// 扇区 LBA 地址的 8-15 位</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F5</span><span class="p">,</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>          <span class="c1">// 扇区 LBA 地址的 16-23 位</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F6</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0xE0</span><span class="p">);</span> <span class="c1">// offset | 11100000 保证高三位恒为 1</span>
</span><span class='line'>                                      <span class="c1">//         第7位     恒为1</span>
</span><span class='line'>                                      <span class="c1">//         第6位     LBA模式的开关，置1为LBA模式</span>
</span><span class='line'>                                      <span class="c1">//         第5位     恒为1</span>
</span><span class='line'>                                      <span class="c1">//         第4位     为0代表主硬盘、为1代表从硬盘</span>
</span><span class='line'>                                      <span class="c1">//         第3~0位   扇区 LBA 地址的 24-27 位</span>
</span><span class='line'>  <span class="n">outb</span><span class="p">(</span><span class="mh">0x1F7</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>                  <span class="c1">// 20h为读，30h为写</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Read data.</span>
</span><span class='line'>  <span class="n">waitdisk</span><span class="p">();</span>
</span><span class='line'>  <span class="n">insl</span><span class="p">(</span><span class="mh">0x1F0</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">SECTSIZE</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>运行内核</h2>

<p>内核从磁盘上载入到内存中后 <code>bootmain</code> 函数接下来就准备运行内核中的方法了。我们还是回到 <code>bootmain</code> 函数上来，请注意看我加上的注释说明。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">bootmain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">uchar</span><span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从 0xa0000 到 0xfffff 的物理地址范围属于设备空间，</span>
</span><span class='line'>  <span class="c1">// 所以内核放置在 0x10000 处开始</span>
</span><span class='line'>  <span class="n">elf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="o">*</span><span class="p">)</span><span class="mh">0x10000</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从内核所在硬盘位置读取一内存页 4kb 数据</span>
</span><span class='line'>  <span class="n">readseg</span><span class="p">((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 判断是否为 ELF 文件格式</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">ELF_MAGIC</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>  <span class="c1">// let bootasm.S handle error</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 加载 ELF 文件中的程序段 (ignores ph flags).</span>
</span><span class='line'>  <span class="c1">// 找到内核 ELF 文件的程序头表</span>
</span><span class='line'>  <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">proghdr</span><span class="o">*</span><span class="p">)((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span> <span class="o">+</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">phoff</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// 内核 ELF 文件程序头表的结束位置</span>
</span><span class='line'>  <span class="n">eph</span> <span class="o">=</span> <span class="n">ph</span> <span class="o">+</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">phnum</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// 开始将内核 ELF 文件程序头表载入内存</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">paddr</span><span class="p">;</span>
</span><span class='line'>    <span class="n">readseg</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">off</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// 如果内存大小大于文件大小，用 0 补齐内存空位</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">memsz</span> <span class="o">&gt;</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">)</span>
</span><span class='line'>      <span class="n">stosb</span><span class="p">(</span><span class="n">pa</span> <span class="o">+</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">memsz</span> <span class="o">-</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">filesz</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Call the entry point from the ELF header.</span>
</span><span class='line'>  <span class="c1">// Does not return!</span>
</span><span class='line'>  <span class="c1">// 从内核 ELF 文件入口点开始执行内核</span>
</span><span class='line'>  <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
</span><span class='line'>  <span class="n">entry</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>载入内核后根据 ELF 头表的说明，<code>bootmain</code>函数开始将内核 ELF 文件的程序头表从磁盘载入内存，为运行内核代码做着最后的准备工作。根据上一节的分析我们知道内核的 ELF 文件的程序头表紧跟在 ELF 头表后面，程序头表一共 2 个，每个 32 字节大小，一共是 64 字节，我们继续用十六进制编辑器打开 <code>kernel</code> 内核二进制文件看看程序头表的内容。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">type</th>
<th align="center">off</th>
<th align="center">vaddr</th>
<th align="center">paddr</th>
<th align="center">filesz</th>
<th align="center">memsz</th>
<th align="center">flags</th>
<th align="center">align</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">01 00 00 00</td>
<td align="center">00 10 00 00</td>
<td align="center">00 00 10 80</td>
<td align="center">00 00 10 00</td>
<td align="center">96 B5 00 00</td>
<td align="center">FC 26 01 00</td>
<td align="center">07 00 00 00</td>
<td align="center">00 10 00 00|</td>
</tr>
<tr>
<td></td>
<td align="center">type</td>
<td align="center">off</td>
<td align="center">vaddr</td>
<td align="center">paddr</td>
<td align="center">filesz</td>
<td align="center">memsz</td>
<td align="center">flags</td>
<td align="center">align|</td>
</tr>
<tr>
<td></td>
<td align="center">51 E5 74 64</td>
<td align="center">00 00 00 00</td>
<td align="center">00 00 00 00</td>
<td align="center">00 00 00 00</td>
<td align="center">00 00 00 00</td>
<td align="center">00 00 00 00</td>
<td align="center">07 00 00 00</td>
<td align="center">04 00 00 00|</td>
</tr>
</tbody>
</table>


<ul>
<li>程序头表 1</li>
</ul>


<table>
<thead>
<tr>
<th></th>
<th align="center">字段名称</th>
<th align="center">大小</th>
<th align="center">数值</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">type</td>
<td align="center">4字节</td>
<td align="center">01 00 00 00</td>
<td align="center">可载入的段|</td>
</tr>
<tr>
<td></td>
<td align="center">off</td>
<td align="center">4字节</td>
<td align="center">00 10 00 00</td>
<td align="center">段在文件中的偏移是 4096 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">vaddr</td>
<td align="center">4字节</td>
<td align="center">00 00 10 80</td>
<td align="center">段在内存中的虚拟地址|</td>
</tr>
<tr>
<td></td>
<td align="center">paddr</td>
<td align="center">4字节</td>
<td align="center">00 10 00 00</td>
<td align="center">同段在文件中的偏移量|</td>
</tr>
<tr>
<td></td>
<td align="center">filesz</td>
<td align="center">4字节</td>
<td align="center">96 B5 00 00</td>
<td align="center">段在文件中的大小是 46486 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">memsz</td>
<td align="center">4字节</td>
<td align="center">FC 26 01 00</td>
<td align="center">段在内存中的大小是 75516 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">flags</td>
<td align="center">4字节</td>
<td align="center">07 00 00 00</td>
<td align="center">段的权限是可写、可读、可执行|</td>
</tr>
<tr>
<td></td>
<td align="center">align</td>
<td align="center">4字节</td>
<td align="center">00 10 00 00</td>
<td align="center">段的对齐方式是 4096 字节，即4kb|</td>
</tr>
</tbody>
</table>


<ul>
<li>程序头表 2</li>
</ul>


<table>
<thead>
<tr>
<th></th>
<th align="center">字段名称</th>
<th align="center">大小</th>
<th align="center">数值</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">type</td>
<td align="center">4字节</td>
<td align="center">51 E5 74 64</td>
<td align="center"> PT_GNU_STACK 段|</td>
</tr>
<tr>
<td></td>
<td align="center">off</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">段在文件中的偏移是 0 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">vaddr</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">段在内存中的虚拟地址|</td>
</tr>
<tr>
<td></td>
<td align="center">paddr</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">同段在文件中的偏移量|</td>
</tr>
<tr>
<td></td>
<td align="center">filesz</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">段在文件中的大小是 0 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">memsz</td>
<td align="center">4字节</td>
<td align="center">00 00 00 00</td>
<td align="center">段在内存中的大小是 0 字节|</td>
</tr>
<tr>
<td></td>
<td align="center">flags</td>
<td align="center">4字节</td>
<td align="center">07 00 00 00</td>
<td align="center">段的权限是可写、可读、可执行|</td>
</tr>
<tr>
<td></td>
<td align="center">align</td>
<td align="center">4字节</td>
<td align="center">04 00 00 00</td>
<td align="center">段的对齐方式是 4 字节|</td>
</tr>
</tbody>
</table>


<p>同样我们再通过 <code>readelf</code> 命令来验证我们通过十六进制编辑器对内核 ELF 文件的程序头表的分析结果十分正确。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>readelf -l kernel
</span><span class='line'>
</span><span class='line'>Elf file <span class="nb">type </span>is EXEC <span class="o">(</span>Executable file<span class="o">)</span>
</span><span class='line'>Entry point 0x10000c
</span><span class='line'>There are 2 program headers, starting at offset 52
</span><span class='line'>
</span><span class='line'>Program Headers:
</span><span class='line'>  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
</span><span class='line'>  LOAD           0x001000 0x80100000 0x00100000 0x0b596 0x126fc RWE 0x1000
</span><span class='line'>  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4
</span><span class='line'>
</span><span class='line'> Section to Segment mapping:
</span><span class='line'>  Segment Sections...
</span><span class='line'>   00     .text .rodata .stab .stabstr .data .bss
</span><span class='line'>   01
</span></code></pre></td></tr></table></div></figure>


<p>在预备知识里我们讲到 ELF 文件的程序头表描述了程序各个段的情况，所以我们再通过<code>readelf</code>命令看看内核文件都有那些段</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>readelf -S kernel
</span><span class='line'>There are 18 section headers, starting at offset 0x1f600:
</span><span class='line'>
</span><span class='line'>Section Headers:
</span><span class='line'>  <span class="o">[</span>Nr<span class="o">]</span> Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
</span><span class='line'>  <span class="o">[</span> 0<span class="o">]</span>                   NULL            00000000 000000 000000 00      0   0  0
</span><span class='line'>  <span class="o">[</span> 1<span class="o">]</span> .text             PROGBITS        80100000 001000 008111 00  AX  0   0  4
</span><span class='line'>  <span class="o">[</span> 2<span class="o">]</span> .rodata           PROGBITS        80108114 009114 000672 00   A  0   0  4
</span><span class='line'>  <span class="o">[</span> 3<span class="o">]</span> .stab             PROGBITS        80108786 009786 000001 0c  WA  4   0  1
</span><span class='line'>  <span class="o">[</span> 4<span class="o">]</span> .stabstr          STRTAB          80108787 009787 000001 00  WA  0   0  1
</span><span class='line'>  <span class="o">[</span> 5<span class="o">]</span> .data             PROGBITS        80109000 00a000 002596 00  WA  0   0 4096
</span><span class='line'>  <span class="o">[</span> 6<span class="o">]</span> .bss              NOBITS          8010b5a0 00c596 00715c 00  WA  0   0 32
</span><span class='line'>  <span class="o">[</span> 7<span class="o">]</span> .debug_line       PROGBITS        00000000 00c596 001f8c 00      0   0  1
</span><span class='line'>  <span class="o">[</span> 8<span class="o">]</span> .debug_info       PROGBITS        00000000 00e522 00a965 00      0   0  1
</span><span class='line'>  <span class="o">[</span> 9<span class="o">]</span> .debug_abbrev     PROGBITS        00000000 018e87 0026ed 00      0   0  1
</span><span class='line'>  <span class="o">[</span>10<span class="o">]</span> .debug_aranges    PROGBITS        00000000 01b578 0003a0 00      0   0  8
</span><span class='line'>  <span class="o">[</span>11<span class="o">]</span> .debug_loc        PROGBITS        00000000 01b918 002f30 00      0   0  1
</span><span class='line'>  <span class="o">[</span>12<span class="o">]</span> .debug_str        PROGBITS        00000000 01e848 000cdc 01  MS  0   0  1
</span><span class='line'>  <span class="o">[</span>13<span class="o">]</span> .comment          PROGBITS        00000000 01f524 00001c 01  MS  0   0  1
</span><span class='line'>  <span class="o">[</span>14<span class="o">]</span> .debug_ranges     PROGBITS        00000000 01f540 000018 00      0   0  1
</span><span class='line'>  <span class="o">[</span>15<span class="o">]</span> .shstrtab         STRTAB          00000000 01f558 0000a5 00      0   0  1
</span><span class='line'>  <span class="o">[</span>16<span class="o">]</span> .symtab           SYMTAB          00000000 01f8d0 0023d0 10     17 138  4
</span><span class='line'>  <span class="o">[</span>17<span class="o">]</span> .strtab           STRTAB          00000000 021ca0 0012d0 00      0   0  1
</span><span class='line'>Key to Flags:
</span><span class='line'>  W <span class="o">(</span>write<span class="o">)</span>, A <span class="o">(</span>alloc<span class="o">)</span>, X <span class="o">(</span>execute<span class="o">)</span>, M <span class="o">(</span>merge<span class="o">)</span>, S <span class="o">(</span>strings<span class="o">)</span>
</span><span class='line'>  I <span class="o">(</span>info<span class="o">)</span>, L <span class="o">(</span>link order<span class="o">)</span>, G <span class="o">(</span>group<span class="o">)</span>, T <span class="o">(</span>TLS<span class="o">)</span>, E <span class="o">(</span>exclude<span class="o">)</span>, x <span class="o">(</span>unknown<span class="o">)</span>
</span><span class='line'>  O <span class="o">(</span>extra OS processing required<span class="o">)</span> o <span class="o">(</span>OS specific<span class="o">)</span>, p <span class="o">(</span>processor specific<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>结合这两次 <code>readelf</code> 命令的输出我们不难看出，内核文件的 ELF 程序头表中只有第一个是需要被加载的，而这个程序头表指出的加载位置 <code>0x80100000</code> 和内核程序的代码段 <code>.text</code> 的位置是一样的。</p>

<p>而要加载的段是 <code>.text .rodata .stab .stabstr .data .bss</code> ，这些段在内存中的大小总和是<del><code>0x008111 + 0x000672 + 0x000001 + 0x000001 + 0x002596 + 0x00715c = 0x73335</code> 按照对齐要求 <code>0x1000</code> 对齐后为 <code>0x75516</code> 和 ELF 程序头表中的内存大小信息一致</del>（这里特别感谢<a href="https://xuzhenglun.github.io/">@徐正伦同学的指正</a>）<code>0x008111 + 0x000672 + 0x000001 + 0x000001 + 0x002596 + 0x00715c = 73335 即 0x11e77</code> 按照对齐要求 <code>0x1000</code> 对齐后为 <code>75516 即 0x000126fc（注意大小端转换，FC 26 01 00 是按照小端排列的，转换成正常的十六进制数为 0x000126fc）</code> 和 ELF 程序头表中的内存大小信息一致。</p>

<p>我们再算算这些段在文件中的大小，由于这些段在文件中是顺序排列的，所以用 <code>.bss段</code> 的文件偏移量减去 <code>.text段</code> 的文件偏移量 <code>0x00c596 - 0x001000 = 46486</code> 这也是和 ELF 程序头表中段在文件中大小的信息一致。</p>

<h2>内核加载后的系统内存布局</h2>

<p>至此内核已经被载入内存并准备投入运行了。在结束这一篇前我们再看一眼目前状态下系统整体的内存布局，对即将运行的内核环境有一个大致的了解。我们来看几个关键点</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// bootmain.c</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">bootmain</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">uchar</span><span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从 0xa0000 到 0xfffff 的物理地址范围属于设备空间，</span>
</span><span class='line'>  <span class="c1">// 所以内核放置在 0x10000 处开始</span>
</span><span class='line'>  <span class="n">elf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="o">*</span><span class="p">)</span><span class="mh">0x10000</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 从内核所在硬盘位置读取一内存页 4kb 数据</span>
</span><span class='line'>  <span class="n">readseg</span><span class="p">((</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">elf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 省略后面的代码......</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由此可知内核被放置在 0x10000 处开始。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='nasm'><span class='line'><span class="err">#</span> <span class="nf">bootasm.S</span>
</span><span class='line'>
</span><span class='line'><span class="nf">.code32</span>  <span class="err">#</span> <span class="nv">Tell</span> <span class="nv">assembler</span> <span class="nv">to</span> <span class="nv">generate</span> <span class="mi">32</span><span class="o">-</span><span class="nv">bit</span> <span class="nv">code</span> <span class="nv">now.</span>
</span><span class='line'><span class="nl">start32:</span>
</span><span class='line'>  <span class="err">#</span> <span class="nf">Set</span> <span class="nv">up</span> <span class="nv">the</span> <span class="nv">protected</span><span class="o">-</span><span class="nv">mode</span> <span class="nv">data</span> <span class="ow">seg</span><span class="nv">ment</span> <span class="nv">registers</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">像上面讲</span> <span class="nf">ljmp</span> <span class="err">时所说的，这时候已经在保护模式下了</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">数据段在</span> <span class="nf">GDT</span> <span class="err">中的下标是</span> <span class="mi">2</span><span class="err">，所以这里数据段的段选择子是</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span> <span class="err">=</span> <span class="mi">0000</span> <span class="mi">0000</span> <span class="mi">0001</span> <span class="mi">0000</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">这</span> <span class="err">16</span> <span class="err">位的段选择子中的前</span> <span class="err">13</span> <span class="err">位是</span> <span class="nf">GDT</span> <span class="err">段表下标，这里前</span> <span class="mi">13</span> <span class="err">位的值是</span> <span class="mi">2</span> <span class="err">代表选择了数据段</span>
</span><span class='line'>  <span class="err">#</span> <span class="err">这里将</span> <span class="err">3</span> <span class="err">个数据段寄存器都赋值成数据段段选择子的值</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="kc">$</span><span class="p">(</span><span class="ow">SEG</span><span class="nv">_KDATA</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">),</span> <span class="o">%</span><span class="nb">ax</span>    <span class="err">#</span> <span class="nv">Our</span> <span class="nv">data</span> <span class="ow">seg</span><span class="nv">ment</span> <span class="nv">selector</span>  <span class="err">段选择子赋值给</span> <span class="nb">ax</span> <span class="err">寄存器</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="o">%</span><span class="nb">ax</span><span class="p">,</span> <span class="o">%</span><span class="nb">ds</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="nb">DS</span><span class="p">:</span> <span class="nv">Data</span> <span class="ow">Seg</span><span class="nv">ment</span>        <span class="err">初始化数据段寄存器</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="o">%</span><span class="nb">ax</span><span class="p">,</span> <span class="o">%</span><span class="nb">es</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="nb">ES</span><span class="p">:</span> <span class="nv">Extra</span> <span class="ow">Seg</span><span class="nv">ment</span>       <span class="err">初始化扩展段寄存器</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="o">%</span><span class="nb">ax</span><span class="p">,</span> <span class="o">%</span><span class="nb">ss</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="nb">SS</span><span class="p">:</span> <span class="nv">Stack</span> <span class="ow">Seg</span><span class="nv">ment</span>       <span class="err">初始化堆栈段寄存器</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="nb">ax</span>                 <span class="err">#</span> <span class="nv">Zero</span> <span class="ow">seg</span><span class="nv">ments</span> <span class="nv">not</span> <span class="nv">ready</span> <span class="nv">for</span> <span class="nv">use</span>  <span class="nb">ax</span> <span class="err">寄存器清零</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="o">%</span><span class="nb">ax</span><span class="p">,</span> <span class="o">%</span><span class="nb">fs</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="nb">FS</span>                      <span class="err">辅助寄存器清零</span>
</span><span class='line'>  <span class="nf">movw</span>    <span class="o">%</span><span class="nb">ax</span><span class="p">,</span> <span class="o">%</span><span class="nb">gs</span>                <span class="err">#</span> <span class="o">-&gt;</span> <span class="nb">GS</span>                      <span class="err">辅助寄存器清零</span>
</span><span class='line'>
</span><span class='line'>  <span class="err">#</span> <span class="nf">Set</span> <span class="nv">up</span> <span class="nv">the</span> <span class="nv">stack</span> <span class="nv">pointer</span> <span class="nv">and</span> <span class="nv">call</span> <span class="nv">into</span> <span class="nv">C.</span>
</span><span class='line'>  <span class="nf">movl</span>    <span class="kc">$</span><span class="nv">start</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>            <span class="err">#</span> <span class="err">栈顶被放置在</span> <span class="mh">0x7C00</span> <span class="err">处，即</span> <span class="kc">$</span><span class="nv">start</span>
</span><span class='line'>  <span class="nf">call</span>    <span class="nv">bootmain</span>
</span></code></pre></td></tr></table></div></figure>


<p>由此可知在执行 <code>bootmain.c</code> 之前 <code>bootasm.S</code> 汇编代码已经将栈的栈顶设置在了 <code>0x7C00</code> 处。之前我们了解过 x86 架构计算机的启动过程，BIOS 会将引导扇区的引导程序加载到 <code>0x7C00</code> 处并引导 CPU 从此处开始运行，故栈顶即被设置在了和引导程序一致的内存位置上。我们知道栈是自栈顶开始向下增长的，所以这里栈会逐渐远离引导程序，所以这里这样安置栈顶的位置并无什么问题。</p>

<p>最后放一张简单的内存布局示意图</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='nasm'><span class='line'><span class="err">0</span><span class="nf">x00000000</span>
</span><span class='line'><span class="err">+------------------------------------------------------------------------—+</span>
</span><span class='line'><span class="err">|</span>        <span class="err">0</span><span class="nf">x7c00</span>      <span class="mh">0x7d00</span>         <span class="mh">0x10000</span>                               <span class="o">|</span>
</span><span class='line'><span class="err">|</span>    <span class="err">栈</span>    <span class="err">|</span>  <span class="err">引导程序</span>  <span class="err">|</span>                <span class="err">|</span>    <span class="err">内核</span>                          <span class="err">|</span>
</span><span class='line'><span class="err">+-------------------------------------------------------------------------+</span>
</span><span class='line'>                                                                 <span class="err">0</span><span class="nf">xffffffff</span>
</span></code></pre></td></tr></table></div></figure>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-05-26T14:03:28+08:00" pubdate data-updated="true">2015年5月26日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/cao-zuo-xi-tong/'>操作系统</a>


</div>
	
	<div class="comments"><a href="/blog/2015/05/26/%5B%28xue-xi-xv6%29%5D-jia-zai-bing-yun-xing-nei-he/#disqus_thread">Comments</a></div>
	
	<div>
		<br/><div>如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</div>
		<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="post" target="_blank" accept-charset="GBK" id="alipayForm">
			<input name="optEmail" type="hidden" value="leenjewel@gmail.com" />
			<input name="payAmount" type="hidden" value="1.00" />
			<input id="title" name="title" type="hidden" value="捐赠给 leenjewel.github.io" />
			<input name="memo" type="hidden" value="文章写的不错，我来捐赠鼓励的！" />
			<input name="pay" type="image" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" width="150" height="40">
		</form>
	</div>
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/04/17/android-ping-tai-yong-gprof-gei-cocos2d-x-zuo-xing-neng-fen-xi/">
		
			Android 平台用 Gprof 给 Cocos2d-x 做性能分析</a>
	</h2>
	<div class="entry-content">
		<h3>gprof</h3>

<p>在 iOS 平台下我们可以用 Xcode 自带的 Profile 工具来测试我们程序的性能，那在 Android 平台下面要怎么搞呢？答案就是<code>gprof</code>。什么是 gprof 呢？引用 <a href="http://en.wikipedia.org/wiki/Gprof">Wiki</a> 的解释：</p>

<blockquote><p>Gprof is a performance analysis tool for Unix applications. It uses a hybrid of instrumentation and sampling[1] and was created as extended version of the older &ldquo;prof&rdquo; tool. Unlike prof, gprof is capable of limited call graph collecting and printing.</p></blockquote>

<p>因为 Android 本来就是基于 Linux 的，所以这里用 gprof 来做性能测试是没什么问题的。不过需要注意的是，这里所说的性能测试是针对 NDK 编译的 C++ 代码的。就想 Cocos2d-x 这样的 C++ 实现的游戏引擎就可以通过 gprof 来分析。下面我们来说说搞法。</p>

<h3>环境</h3>

<p>我是 Mac OS X 下，这里要做性能分析的 Cocos2d-x 项目是基于 Cocos2d-x 3.2 引擎，项目本身是基于 Lua 脚本编写的。其实这些都无关紧要，只不过是编译出的 so 文件有所不同罢了。只要是 NDK 的代码都可以用 gprof 来做性能分析的。</p>

<h3>android-ndk-profiler</h3>

<p>要想生成 gprof 的性能分析报告，我们优先要把一个叫做 <code>android-ndk-profiler</code> 的模块集成到我们的项目中。android-ndk-profiler 模块的源代码在 <a href="https://github.com/richq/android-ndk-profiler">GitHub</a> 上面，首先要把模块代码 clone 下来</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git@github.com:richq/android-ndk-profiler.git</span></code></pre></td></tr></table></div></figure>


<p>android-ndk-profiler 的项目自带了一篇<a href="https://github.com/richq/android-ndk-profiler/blob/master/docs/Usage.md">文档说明</a>教授如何集成和使用，但是写的比较简单，我来详细的说一下。android-ndk-profiler 项目 clone 下来后进到项目目录可以看到如下结构</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> |-docs
</span><span class='line'> |-example
</span><span class='line'> |-jni
</span><span class='line'> |-test</span></code></pre></td></tr></table></div></figure>


<p></p>

<p> 而我们需要的就是<code>jni</code>这个目录下面的文件。</p>

<h3>集成 android-ndk-profiler 到 Cocos2d-x 项目</h3>

<h6>拷贝文件</h6>

<p>来到我们自己的 Cocos2d-x 项目目录中，新建一个叫做 <code>android-ndk-profiler</code> 的文件夹，将刚刚克隆的 android-ndk-profile 模块的 jni 目录中的所有文件拷贝到我们刚刚建立的文件夹中。</p>

<h6>编辑 Android.mk 文件</h6>

<p>打开 <code>proj.android/jin/Android.mk</code> 文件，加入如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#*注意* YOUR_ANDROID_NDK_PROFILER_PATH 是你 cocos2d-x 项目中 android-ndk-profiler 目录的位置
</span><span class='line'>
</span><span class='line'>$(call import-add-path,$(YOUR_ANDROID_NDK_PROFILER_PATH))
</span><span class='line'>
</span><span class='line'># 加入头文件
</span><span class='line'>LOCAL_C_INCLUDES += $(YOUR_ANDROID_NDK_PROFILER_PATH)
</span><span class='line'>
</span><span class='line'>APP_DEBUG := $(strip $(NDK_DEBUG))
</span><span class='line'>
</span><span class='line'># 如果是 Debug 模式，则引入 android-ndk-profiler
</span><span class='line'>ifeq ($(APP_DEBUG),1)
</span><span class='line'>  LOCAL_CFLAGS := -pg
</span><span class='line'>  LOCAL_STATIC_LIBRARIES += android-ndk-profiler
</span><span class='line'>endif
</span><span class='line'>
</span><span class='line'>ifeq ($(APP_DEBUG),1)
</span><span class='line'>  $(call import-module,YOUR_ANDROID_NDK_PROFILER_PATH)
</span><span class='line'>endif</span></code></pre></td></tr></table></div></figure>


<p>这里只解释两点。</p>

<p><code>LOCAL_CFLAGS := -pg</code> 通过在编译使用 -pg 编译和链接选项，gcc 在你应用程序的每个函数中都加入了一个名为mcount ( or  “_mcount”  , or  “__mcount” , 依赖于编译器或操作系统) 的函数，也就是说你的应用程序里的每一个函数都会调用 mcount, 而 mcount 会在内存中保存一张函数调用图，并通过函数调用堆栈的形式查找子函数和父函数的地址。这张调用图也保存了所有与函数相关的调用时间，调用次数等等的所有信息。</p>

<p><code>APP_DEBUG</code> 这里增加了一个判断，只有当以 <code>NDK_DEBUG=1</code> 的 Debug 模式编译 NDK 代码的时候才开启 android-ndk-profiler 分析功能，这样保证我们出 Release 版本的时候不引入性能分析。</p>

<h3>使用 android-ndk-profiler</h3>

<p>以 Debug 模式重新编译一下项目代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd proj.android
</span><span class='line'>ndk-build NDK_DEBUG=1</span></code></pre></td></tr></table></div></figure>


<p>如果编译成功那么说明 android-ndk-profiler 已经成功集成到我们的 Cocos2d-x 项目中了，集成的过程非常简单，同样，android-ndk-profiler 的使用也非常的方便。</p>

<h6>编辑 AppDelegate.cpp 文件</h6>

<p>只需要引入一个头文件，添加两个函数调用即可</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// 引入头文件</span>
</span><span class='line'><span class="cp">#if (COCOS2D_DEBUG&gt;0 &amp;&amp; CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)</span>
</span><span class='line'><span class="cp">#include &quot;prof.h&quot;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span> <span class="n">AppDelegate</span><span class="o">::</span><span class="n">applicationDidFinishLaunching</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="cp">#if (COCOS2D_DEBUG&gt;0 &amp;&amp; CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)</span>
</span><span class='line'>  <span class="n">monstartup</span><span class="p">(</span><span class="s">&quot;libcocos2dlua.so&quot;</span><span class="p">);</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>  <span class="c1">// 其他已有逻辑代码......</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">AppDelegate</span><span class="o">::</span><span class="n">applicationDidEnterBackground</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 其他已有逻辑代码......</span>
</span><span class='line'><span class="cp">#if (COCOS2D_DEBUG&gt;0 &amp;&amp; CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)</span>
</span><span class='line'>    <span class="n">moncleanup</span><span class="p">();</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里只需要注意两点。</p>

<p><code>AndroidManifest.xml</code> 因为要生成性能分析报告，所以要赋予你的 Android 程序 WRITE_EXTERNAL_STORAGE 权限，即</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;uses-permission</span> <span class="na">android:name=</span><span class="s">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>libcocos2dlua.so</code> 这个 so 文件会根据你的 Cocos2d-x 项目的类型不同名字上会有所不同，比如我们是 Lua 项目，所以 NDK 编译生成的 so 文件就叫 libcocos2dlua.so ，具体的文件名请自行到 proj.android/libs/armeabi 目录下查看。</p>

<p>再次以 Debug 模式重新编译一下项目代码，如果没有错误，那么大功就告成了。</p>

<h6>生成 gmon.out 性能分析报告</h6>

<p>项目编译完成后生成 apk 文件，将 apk 文件安装到 Android 设备上。通过上一小节我们对 AppDelegate.cpp 文件的修改不难看出，当程序在 Android 设备上运行的时候，调用了 <code>monstartup</code> 函数开始性能分析，当程序退到后台时调用了 <code>moncleanup</code> 函数生成性能分析报告。性能分析报告文件默认存储到 Android 设备的 /sdcard/gmon.out 位置，我们用 adb 工具可以把文件拉到电脑上面。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>adb pull /sdcard/gmon.out .
</span></code></pre></td></tr></table></div></figure>


<p>当然官方文档里面也提了，如果想要自定义性能分析报告存放的位置，可以在调用 <code>moncleanup</code> 函数前指定要保存的位置。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">setenv</span><span class="p">(</span><span class="s">&quot;CPUPROFILE&quot;</span><span class="p">,</span> <span class="s">&quot;/data/data/com.example.application/files/gmon.out&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">moncleanup</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h3>解读性能分析报告 gmon.out</h3>

<p>生成的性能分析告报 gmon.out 是不能直接通过文本编辑器打开来读的，它是个二进制文件，需要专门的工具来生成可读的文本文件。这个工具在 NDK 中已经提供了，以我使用的 android-ndk-r10d 为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">cd</span> <span class="n">android</span><span class="o">-</span><span class="n">ndk</span><span class="o">-</span><span class="n">r10d</span><span class="o">/</span><span class="n">toolchains</span><span class="o">/</span><span class="n">arm</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">androideabi</span><span class="o">-</span><span class="mf">4.9</span><span class="o">/</span><span class="n">prebuilt</span><span class="o">/</span><span class="n">darwin</span><span class="o">-</span><span class="n">x86_64</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span>
</span><span class='line'>
</span><span class='line'><span class="p">.</span><span class="o">/</span><span class="n">arm</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">androideabi</span><span class="o">-</span><span class="n">gprof</span> \
</span><span class='line'>  <span class="err">你的项目路径</span><span class="o">/</span><span class="n">proj</span><span class="p">.</span><span class="n">android</span><span class="o">/</span><span class="n">obj</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">armeabi</span><span class="o">/</span><span class="n">libcocos2dlua</span><span class="p">.</span><span class="n">so</span>\
</span><span class='line'>  <span class="err">你的</span><span class="n">gmon</span><span class="p">.</span><span class="n">out</span><span class="err">存放路径</span><span class="o">/</span><span class="n">gmon</span><span class="p">.</span><span class="n">out</span> <span class="o">&gt;</span> <span class="n">gmon</span><span class="p">.</span><span class="n">txt</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里只解释一点。</p>

<p><code>libcocos2dlua.so</code> 细心的读者发现这里使用的 so 文件并不是之前的那个放在 proj.android/libs/armeabi/libcocos2dlua.so 下面的那个 so 文件。这是因为最终随 apk 一起打包的那个 libcocos2dlua.so 文件（也就是 proj.android/libs/armeabi 目录下的）是不包含<strong>符号表</strong>的，而存放在 proj.android/obj/local/armeabi 目录下的是带<strong>符号表</strong>的版本。而什么是<strong>符号表</strong>，这是一个编译链接中的概念，请自行 Google 一下，或者读一读<a href="http://book.douban.com/subject/3652388/">《程序员的自我修养》这本书</a>，再次强烈推荐这本书。</p>

<h3>gmon.txt 解读</h3>

<p>我节选一下生成的 gmon.txt 的两处比较重要的部分来看</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Flat</span> <span class="nl">profile:</span>
</span><span class='line'>
</span><span class='line'><span class="n">Each</span> <span class="n">sample</span> <span class="n">counts</span> <span class="n">as</span> <span class="mf">0.01</span> <span class="n">seconds</span><span class="p">.</span>
</span><span class='line'>  <span class="o">%</span>   <span class="n">cumulative</span>   <span class="n">self</span>              <span class="n">self</span>     <span class="n">total</span>
</span><span class='line'> <span class="n">time</span>   <span class="n">seconds</span>   <span class="n">seconds</span>    <span class="n">calls</span>  <span class="n">ms</span><span class="o">/</span><span class="n">call</span>  <span class="n">ms</span><span class="o">/</span><span class="n">call</span>  <span class="n">name</span>
</span><span class='line'> <span class="mf">19.14</span>      <span class="mf">1.16</span>     <span class="mf">1.16</span>                             <span class="n">png_read_filter_row_paeth_multibyte_pixel</span>
</span><span class='line'> <span class="mf">15.35</span>      <span class="mf">2.09</span>     <span class="mf">0.93</span>                             <span class="n">cocos2d</span><span class="o">::</span><span class="n">Image</span><span class="o">::</span><span class="n">premultipliedAlpha</span><span class="p">()</span>
</span><span class='line'> <span class="mf">14.36</span>      <span class="mf">2.96</span>     <span class="mf">0.87</span>                             <span class="n">cocos2d</span><span class="o">::</span><span class="n">Texture2D</span><span class="o">::</span><span class="n">convertRGBA8888ToRGBA4444</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span>
</span><span class='line'>  <span class="mf">7.10</span>      <span class="mf">3.39</span>     <span class="mf">0.43</span>                             <span class="n">profCount</span>
</span><span class='line'>  <span class="mf">3.96</span>      <span class="mf">3.63</span>     <span class="mf">0.24</span>                             <span class="n">png_read_filter_row_up</span>
</span><span class='line'>  <span class="mf">3.30</span>      <span class="mf">3.83</span>     <span class="mf">0.20</span>                             <span class="n">llex</span>
</span><span class='line'>  <span class="mf">3.14</span>      <span class="mf">4.02</span>     <span class="mf">0.19</span>                             <span class="n">png_read_filter_row_sub</span>
</span><span class='line'>  <span class="mf">2.81</span>      <span class="mf">4.19</span>     <span class="mf">0.17</span>                             <span class="n">__gnu_mcount_nc</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">......</span>
</span><span class='line'>
</span><span class='line'>  
</span><span class='line'>           <span class="n">Call</span> <span class="n">graph</span> <span class="p">(</span><span class="n">explanation</span> <span class="n">follows</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nl">granularity:</span> <span class="n">each</span> <span class="n">sample</span> <span class="n">hit</span> <span class="n">covers</span> <span class="mi">2</span> <span class="n">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="mf">0.17</span><span class="o">%</span> <span class="n">of</span> <span class="mf">5.99</span> <span class="n">seconds</span>
</span><span class='line'>
</span><span class='line'><span class="n">index</span> <span class="o">%</span> <span class="n">time</span>    <span class="n">self</span>  <span class="n">children</span>    <span class="n">called</span>     <span class="n">name</span>
</span><span class='line'>                                                 <span class="o">&lt;</span><span class="n">spontaneous</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">[</span><span class="mi">1</span><span class="p">]</span>     <span class="mf">19.4</span>    <span class="mf">1.16</span>    <span class="mf">0.00</span>                 <span class="n">png_read_filter_row_paeth_multibyte_pixel</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span><span class='line'><span class="o">-----------------------------------------------</span>
</span><span class='line'>                                                 <span class="o">&lt;</span><span class="n">spontaneous</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">[</span><span class="mi">2</span><span class="p">]</span>     <span class="mf">15.5</span>    <span class="mf">0.93</span>    <span class="mf">0.00</span>                 <span class="n">cocos2d</span><span class="o">::</span><span class="n">Image</span><span class="o">::</span><span class="n">premultipliedAlpha</span><span class="p">()</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span><span class='line'><span class="o">-----------------------------------------------</span>
</span><span class='line'>                                                 <span class="o">&lt;</span><span class="n">spontaneous</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">[</span><span class="mi">3</span><span class="p">]</span>     <span class="mf">14.5</span>    <span class="mf">0.87</span>    <span class="mf">0.00</span>                 <span class="n">cocos2d</span><span class="o">::</span><span class="n">Texture2D</span><span class="o">::</span><span class="n">convertRGBA8888ToRGBA4444</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span><span class='line'><span class="o">-----------------------------------------------</span>
</span><span class='line'>                                                 <span class="o">&lt;</span><span class="n">spontaneous</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">[</span><span class="mi">4</span><span class="p">]</span>      <span class="mf">7.2</span>    <span class="mf">0.43</span>    <span class="mf">0.00</span>                 <span class="n">profCount</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>
</span><span class='line'><span class="o">-----------------------------------------------</span>
</span><span class='line'>                                                 <span class="o">&lt;</span><span class="n">spontaneous</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">[</span><span class="mi">5</span><span class="p">]</span>      <span class="mf">4.0</span>    <span class="mf">0.24</span>    <span class="mf">0.00</span>                 <span class="n">png_read_filter_row_up</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>
</span><span class='line'><span class="o">-----------------------------------------------</span>
</span></code></pre></td></tr></table></div></figure>


<p>简单解释一下含义</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Flat</span> <span class="nl">profile:</span>
</span><span class='line'>
</span><span class='line'><span class="n">Each</span> <span class="n">sample</span> <span class="n">counts</span> <span class="n">as</span> <span class="mf">0.01</span> <span class="n">seconds</span><span class="p">.</span>
</span><span class='line'>  <span class="o">%</span>   <span class="n">cumulative</span>   <span class="n">self</span>              <span class="n">self</span>     <span class="n">total</span>
</span><span class='line'> <span class="n">time</span>   <span class="n">seconds</span>   <span class="n">seconds</span>    <span class="n">calls</span>  <span class="n">ms</span><span class="o">/</span><span class="n">call</span>  <span class="n">ms</span><span class="o">/</span><span class="n">call</span>  <span class="n">name</span>
</span><span class='line'> <span class="err">函数</span>     <span class="err">程序</span>       <span class="err">函数</span>       <span class="err">函数</span>    <span class="err">函数</span>     <span class="err">函数</span>      <span class="err">函数名</span>
</span><span class='line'> <span class="err">消耗</span>     <span class="err">累计</span>       <span class="err">本身</span>       <span class="err">调用</span>    <span class="err">平均</span>     <span class="err">平均</span>
</span><span class='line'> <span class="err">时间</span>     <span class="err">执行</span>       <span class="err">执行</span>       <span class="err">次数</span>    <span class="err">执行</span>     <span class="err">执行</span>
</span><span class='line'> <span class="err">占程</span>     <span class="err">时间</span>       <span class="err">时间</span>              <span class="err">时间</span>     <span class="err">时间</span>
</span><span class='line'> <span class="err">序运</span>                                 <span class="p">(</span><span class="err">不</span>      <span class="p">(</span><span class="err">包</span>
</span><span class='line'> <span class="err">行时</span>                                  <span class="err">包</span>       <span class="err">括</span>
</span><span class='line'> <span class="err">间的</span>                                  <span class="err">括</span>       <span class="err">被</span>
</span><span class='line'> <span class="err">百分</span>                                  <span class="err">被</span>       <span class="err">调</span>
</span><span class='line'> <span class="err">比</span>                                    <span class="err">调</span>       <span class="err">用</span>
</span><span class='line'>                                      <span class="err">用</span>       <span class="err">时</span>
</span><span class='line'>                                      <span class="err">时</span>       <span class="err">间</span><span class="p">)</span>
</span><span class='line'>                                      <span class="err">间</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>           <span class="n">Call</span> <span class="n">graph</span> <span class="p">(</span><span class="n">explanation</span> <span class="n">follows</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nl">granularity:</span> <span class="n">each</span> <span class="n">sample</span> <span class="n">hit</span> <span class="n">covers</span> <span class="mi">2</span> <span class="n">byte</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="mf">0.17</span><span class="o">%</span> <span class="n">of</span> <span class="mf">5.99</span> <span class="n">seconds</span>
</span><span class='line'>
</span><span class='line'><span class="n">index</span> <span class="o">%</span> <span class="n">time</span>    <span class="n">self</span>  <span class="n">children</span>    <span class="n">called</span>     <span class="n">name</span>
</span><span class='line'> <span class="err">索引</span>    <span class="err">函数</span>     <span class="err">函数</span>   <span class="err">函数的</span>       <span class="err">被调用</span>      <span class="err">函数名</span>
</span><span class='line'> <span class="err">值</span>      <span class="err">执行</span>     <span class="err">本身</span>   <span class="err">子函数</span>        <span class="err">次数</span>
</span><span class='line'>        <span class="err">时间</span>     <span class="err">执行</span>    <span class="err">执行</span>
</span><span class='line'>        <span class="err">占程</span>     <span class="err">时间</span>    <span class="err">时间</span>
</span><span class='line'>        <span class="err">序运</span>
</span><span class='line'>        <span class="err">行时</span>
</span><span class='line'>        <span class="err">间百</span>
</span><span class='line'>        <span class="err">分比</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-04-17T11:27:52+08:00" pubdate data-updated="true">2015年4月17日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/cocos2d-x-android/'>Cocos2d-x Android</a>


</div>
	
	<div class="comments"><a href="/blog/2015/04/17/android-ping-tai-yong-gprof-gei-cocos2d-x-zuo-xing-neng-fen-xi/#disqus_thread">Comments</a></div>
	
	<div>
		<br/><div>如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</div>
		<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="post" target="_blank" accept-charset="GBK" id="alipayForm">
			<input name="optEmail" type="hidden" value="leenjewel@gmail.com" />
			<input name="payAmount" type="hidden" value="1.00" />
			<input id="title" name="title" type="hidden" value="捐赠给 leenjewel.github.io" />
			<input name="memo" type="hidden" value="文章写的不错，我来捐赠鼓励的！" />
			<input name="pay" type="image" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" width="150" height="40">
		</form>
	</div>
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/01/08/ios-ping-tai-cocos2d-x-xiang-mu-jie-ru-xin-lang-wei-bo-sdk-de-keng/">
		
			iOS 平台 Cocos2d-x 项目接入新浪微博 SDK 的坑</a>
	</h2>
	<div class="entry-content">
		<p>最近在做一个 iOS 的 cocos2d-x 项目接入新浪微博 SDK 的时候被“坑”了，最后终于顺利的解决了。发现网上也有不少人遇到一样的问题，但是能找到的数量有限的解决办法写得都不详细，很难让人理解，我来深入的写一写。</p>

<h3>我的开发环境</h3>

<ul>
<li><p>Mac OS X 10.10.1</p></li>
<li><p>Xcode 6.1.1 (6A2008a)</p></li>
<li><p>Cocos2d-x 3.2</p></li>
<li><p>新浪微博 SDK for iOS 2015 年 1 月 5 日从 <a href="https://github.com/sinaweibosdk/weibo_ios_sdk">github</a> clone 的版本</p></li>
</ul>


<h3>遇到的问题</h3>

<p>根据新浪微博 SDK 附带的文档接入项目后，在模拟器运行项目，在调用注册方法时发生崩溃。注册方法代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[WeiboSDK registerApp: @"xxxxxxxx"];</span></code></pre></td></tr></table></div></figure>


<p>崩溃信息打印如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[__NSDictionaryM weibosdk_WBSDKJSONString] : unrecognized selector sent to instance 0x170255780</span></code></pre></td></tr></table></div></figure>


<h3>解决问题遇到的阻碍</h3>

<p>新浪微博 SDK 附带的文档中有这么一个说明：</p>

<blockquote><p>在工程中引入静态库之后,需要在编译时添加   –ObjC   编译选项,避免静态库中类 加载   不全造成程序崩溃。方法:程序   Target->Buid   Settings->Linking   下   Other   Linker  Flags   项添加-ObjC</p></blockquote>

<p>在网上看到遇到同样崩溃错误的人有提到在编译时添加 <code>-all_load</code> 编译选项时也可以解决问题。方法也是在   Target->Buid   Settings->Linking   下   Other   Linker  Flags   项添加<code>-all_load</code>。</p>

<p>无独有偶，我在打开新浪微博 SDK 附带的 Demo 项目时发现这个项目的编译选项也是<code>-all_load</code>而不是它自己文档所提示的<del><code>-ObjC</code></del>。而且在同样的开发环境下，我的 cocos2d-x 项目会崩溃，但是新浪微博 SDK 附带的 Demo 可以正常工作，想必上述两个解决方案<strong>应该是正解</strong></p>

<p>但是在给自己的 cocos2d-x 项目添加了编译选项后，再次编译运行就发生了错误，错误信息如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Undefined symbols for architecture i386:
</span><span class='line'>  "_GCControllerDidConnectNotification", referenced from:
</span><span class='line'>      -[GCControllerConnectionEventHandler observerConnection:disconnection:] in libcocos2dx iOS.a(CCController-iOS.o)
</span><span class='line'>  "_GCControllerDidDisconnectNotification", referenced from:
</span><span class='line'>      -[GCControllerConnectionEventHandler observerConnection:disconnection:] in libcocos2dx iOS.a(CCController-iOS.o)
</span><span class='line'>  "_OBJC_CLASS_$_GCController", referenced from:
</span><span class='line'>      objc-class-ref in libcocos2dx iOS.a(CCController-iOS.o)
</span><span class='line'>     (maybe you meant: _OBJC_CLASS_$_GCControllerConnectionEventHandler)</span></code></pre></td></tr></table></div></figure>


<p>无论是设置成<del><code>-ObjC</code></del>还是<del><code>-all_load</code></del>编译都会失败，都会报上述<strong>找不到符号</strong>的链接错误。</p>

<h3>正确的解决办法</h3>

<p>这里先给出正确的解决办法再谈谈为什么要这么做。正确的做法还是设置 Other Linker Flags 这个编译选项，只不过即不用用<del><code>-ObjC</code></del>也不能用<del><code>-all_load</code></del>，而是要用<strong><code>-force_load path/to/your/libWeiboSDK.a</code></strong>，后面跟的是新浪微博 SDK 静态链接库的确切位置。</p>

<h3>这一切是为什么？</h3>

<h3>从编译链接说起</h3>

<p>这里不打算过多的介绍编译链接相关的只是，但是强烈推荐一本书<a href="http://book.douban.com/subject/3652388/">《程序员的自我修养》</a>，光看正标题你可能会担心这是本没什么“正经”内容的书，至少我当初第一次看到这书名的时候就是这么认为的，但是我错了，这本书的副标题是<strong>链接、装载与库</strong>。相信我，看过这本书 N 遍之后你自会对程序从源代码编译链接到生成二进制程序的原理和过程有一个非常透彻的理解，并且更重要的是看过这本书 N 遍之后你会上升几个层次。</p>

<p>言归正传，一个工程的源代码最终变成二进制的可执行程序、动态链接库或静态链接库要经历这么几个过程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>源代码 ==[编译器]==》 汇编码 ==[汇编器]==》 对象文件 ==[链接器]==》 可执行程序、动态链接库或静态链接库</span></code></pre></td></tr></table></div></figure>


<h3>再说说符号是什么？</h3>

<p>通俗的讲，我们在源码中写的<code>全局变量名</code>、<code>函数名</code>或<code>类名</code>在生成的<code>*.o</code>对象文件中都叫做符号，存在一个叫做<code>符号表</code>的地方。</p>

<p>举个例子：我们在<code>a.c</code>文件中写了一个函数叫<code>foo()</code>，然后在<code>main.c</code>文件中调用了<code>foo()</code>函数，在将源码编译生成的对象文件中<code>a.o</code>对象文件中的符号表里保存着<code>foo()</code>函数符号，并通过该符号可以定位到<code>a.o</code>文件中关于<code>foo()</code>方法的具体实现代码。</p>

<p>链接器在链接生成最终的二进制程序的时候会发现<code>main.o</code>对象文件中引用了符号<code>foo()</code>，而<code>foo()</code>符号并没有在<code>main.o</code>文件中定义，所以不会存在与<code>main.o</code>对象文件的符号表中，于是链接器就开始检查其他对象文件，当检查到<code>a.o</code>文件中定义了符号<code>foo()</code>，于是就将<code>a.o</code>对象文件链接进来。这样就确保了在<code>main.c</code>中能够正常调用<code>a.c</code>中实现的<code>foo()</code>方法了。</p>

<h3>libWeiboSDK.a 静态链接库里有什么？</h3>

<p>Unix 的静态链接库没什么神秘的，它就是个<strong>压缩包</strong>，和平时比较常见的 zip 或 rar 之类的压缩包一样，只不过人家是用一个叫 ar 的压缩工具压缩的而已。所以我们给它解压缩一下，看看它里面都有什么。既然是用 ar 压缩的，解压自然也要用 ar 这个工具。在命令行执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ar -x lieWeiboSDK.a</span></code></pre></td></tr></table></div></figure>


<p>结果报错了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ar: libWeiboSDK.a is a fat file (use libtool(1) or lipo(1) and ar(1) on it)
</span><span class='line'>ar: libWeiboSDK.a: Inappropriate file type or format</span></code></pre></td></tr></table></div></figure>


<p>这里先解释一下它为什么这么肥(fat)。在做 iOS 开发时我们都知道可以用模拟器和真机来测试我们的项目，但是这两个平台的架构是不一样的，模拟器是 i386 x86_64 架构的，而我们的设备是 armv7 arm64 架构的。当在制作静态链接库的时候也要针对不同的架构制作出针对真机和模拟器的两个静态链接库，而当我们想在自己的项目中使用静态链接库的时候，如果在模拟器上运行我们要用针对模拟器的静态库版本，用真机设备测试的时候还要切换到针对真机的静态链接库，这样一来非常的麻烦。</p>

<p>前面说过了静态链接库就是个<strong>压缩包</strong>，那么我们是否能将这两个静态链接库压缩成一个静态链接库这样就可以同时支持模拟器和真机设备两种架构了呢？答案是肯定的。比如我们手头有一个静态链接库的两个架构版本：<code>libXXX.i386_x86_64.a</code>和<code>libXXX.armv7_arm64.a</code>，那么我们可以通过如下命令来生成一个统一的静态链接库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lipo -create libXXX.i386_x86_64.a libXXX.armv7_arm64.a -output libXXX.a</span></code></pre></td></tr></table></div></figure>


<p>这样我们就得到了一个统一版本的静态库<code>libXXX.a</code>，它的好处是同时支持模拟器架构和真机设备架构，缺点是它的体积变大了，也就是说它很<strong>肥(fat)</strong>。</p>

<p>而<code>libWeiboSDK.a</code>就是这么一个合体后的静态库，我们照样可以通过命令来验证这一点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lipo -info libWeiboSDK.a</span></code></pre></td></tr></table></div></figure>


<p>这个命令会输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Architectures in the fat file: libWeiboSDK.a are: armv7 arm64 i386 x86_64</span></code></pre></td></tr></table></div></figure>


<p>既然是个胖子，那我们就要先给它瘦身才能解压。我们随便从里面抽出一个架构的静态链接库来，瘦身命令是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lipo -thin i386 libWeiboSDK.a -output libWeiboSDK.i386.a</span></code></pre></td></tr></table></div></figure>


<p>这样我们就把针对 i386 平台的新浪微博 SDK 静态链接库给抽离出来了，我们管它叫<code>libWeiboSDK.i386.a</code>，现在我们再用<code>ar</code>命令解压它看看里面有什么</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ar -x libWeibo.i386.a</span></code></pre></td></tr></table></div></figure>


<p>解压完成后你会看到好多好多以<code>.o</code>结尾的对象文件，回忆回忆刚刚我们讲到的编译链接过程，这些对象文件就是给<code>链接器</code>最终生成静态链接库时用到的文件，由于太多了，我只列出我们要讲到的几个：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-rw-r--r--  1 leenjewel  staff    13K Jan  8 15:47 NSData+WBSDKBase64.o
</span><span class='line'>-rw-r--r--  1 leenjewel  staff    42K Jan  8 15:47 UIImage+WBSDKResize.o
</span><span class='line'>-rw-r--r--  1 leenjewel  staff    12K Jan  8 15:47 UIImage+WBSDKStretch.o
</span><span class='line'>-rw-r--r--  1 leenjewel  staff    74K Jan  8 15:47 UIView+WBSDKSizes.o
</span><span class='line'>-rw-r--r--  1 leenjewel  staff    58K Jan  8 15:47 WBAidManager.o
</span><span class='line'>-rw-r--r--  1 leenjewel  staff    15K Jan  8 15:47 WBAuthorizeRequest.o
</span><span class='line'>-rw-r--r--  1 leenjewel  staff    16K Jan  8 15:47 WBAuthorizeResponse.o
</span><span class='line'>-rw-r--r--  1 leenjewel  staff    19K Jan  8 15:47 WBBaseMediaObject.o
</span><span class='line'>-rw-r--r--  1 leenjewel  staff   265K Jan  8 15:47 WBSDKJSONKit.o</span></code></pre></td></tr></table></div></figure>


<h3>为什么会在运行中崩溃？</h3>

<p>当我们把新浪微博 SDK 的静态链接库引入我们自己的项目，并 Build 我们自己的项目到模拟器或真机设备上运行的过程其实也是一个编译链接的过程，最终从项目 Build 生成可以在模拟器或真机设备运行的 App，而这个过程中对新浪微博 SDK 的静态链接库的处理方式和我们刚刚拆开<code>libWeiboSDK.a</code>的过程差不多：</p>

<ul>
<li><p>将 libWeibSDK.a 根据当前所构建的平台架构(模拟器还是真机设备)进行瘦身</p></li>
<li><p>将瘦身的静态库解压拆包</p></li>
<li><p>将用到的对象文件链接进入项目</p></li>
</ul>


<p>而我们遇到的崩溃问题恰恰是出在了<code>将用到的对象文件链接进入项目</code>这一步。</p>

<p>苹果的开发者网站针对这个问题有一篇<a href="https://developer.apple.com/library/ios/qa/qa1490/_index.html">说明文章</a>，我们来引用一下里面的内容：</p>

<blockquote><p>The dynamic nature of Objective-C complicates things slightly. Because the code that implements a method is not determined until the method is actually called,</p></blockquote>

<p>这句话解释起来就是说 Objective-C 是有运行时(runtime)的，一个方法要执行什么代码是在运行时决定的，而不是在链接时决定的。想要再深入了解 Objective-C 运行时知识的，可以看看<a href="http://blog.cocoabit.com/blog/2014/10/06/yi-li-jieobjective-cruntime/">这里</a></p>

<blockquote><p>Objective-C does not define linker symbols for methods. Linker symbols are only defined for classes.</p></blockquote>

<p>因为在 Objective-C 中，一个方法的执行是要到运行时才决定的，所以在链接时，链接器只链接类的符号，并不会链接方法的符号。</p>

<blockquote><p>For example, if main.m includes the code [[FooClass alloc] initWithBar:nil]; then main.o will contain an undefined symbol for FooClass, but no linker symbols for the -initWithBar: method will be in main.o</p></blockquote>

<p>最后还举了一个例子：当你在<code>main.m</code>文件中初始化一个类<code>FooClass</code>的对象，然后调用了这个类<code>FooClass</code>的一个对象方法<code>initWithBar</code>，在链接器分析由<code>main.m</code>编译生成的<code>main.o</code>对象文件时，发现这个对象文件没有定义符号<code>FooClass</code>于是就会去其他<code>.o</code>对象文件中去寻找<code>FooClass</code>符号的定义，而至于方法符号<code>initWithBar</code>的定义在哪里链接器是不关心的，因为<code>initWithBar</code>的执行是由运行时负责的，链接器不管。</p>

<p>好了，现在问题来了，我们再重复一下这句话：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Objective-C 中方法的执行实在运行时决定的，所以链接器只链接类的符号，不链接方法的符号</span></code></pre></td></tr></table></div></figure>


<p>我们再回过头看看崩溃的报错信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[__NSDictionaryM weibosdk_WBSDKJSONString] : unrecognized selector sent to instance 0x170255780</span></code></pre></td></tr></table></div></figure>


<p>这说明崩溃的原因是在运行时调用<code>__NSDictionaryM</code>类对象的<code>weibosdk_WBSDKJSONString</code>方法时没有找到该方法的定义。这里不难看出<code>__NSDictionaryM</code>是<code>Foundation Framework</code>中的类，而方法<code>weibosdk_WBSDKJSONString</code>是新浪微博 SDK 自己定义的方法，新浪在这里使用了<strong>分类技术</strong>扩展了<code>__NSDictionaryM</code>类的行为。我们来验证这一点：</p>

<p>我们已经解压出<code>libWeiboSDK.a</code>中的全部<code>.o</code>对象文件，我们用<code>nm</code>命令导出全部对象文件中的符号：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nm *.o &gt;&gt; libWeiboSDK.symbols.txt</span></code></pre></td></tr></table></div></figure>


<p>然后我们用个文本编辑器打开<code>libWeiboSDK.symbols.txt</code>查找<code>weibosdk_WBSDKJSONString</code>，我们可以查到如下结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>WBSDKJSONKit.o:
</span><span class='line'>00007ba0 t -[NSArray(WBSDKJSONKitSerializing) weibosdk_WBSDKJSONString]
</span><span class='line'>00007de8 t -[NSDictionary(WBSDKJSONKitSerializing) weibosdk_WBSDKJSONString]
</span><span class='line'>000079cd t -[NSString(WBSDKJSONKitSerializing) weibosdk_WBSDKJSONString]</span></code></pre></td></tr></table></div></figure>


<p>这就可以说明新浪微博 SDK 确实使用了<strong>分类技术</strong>扩展了<code>NSArray</code>、<code>NSDictionary</code>和<code>NSString</code>三个 Foundation Framework 下面的类的行为。好，现在可以真相大白了：</p>

<ul>
<li><p>在链接时，链接器发现<code>WBSDKJSONKit.o</code>对象文件中缺少类符号<code>NSArray</code>、<code>NSDictionary</code>和<code>NSString</code>。</p></li>
<li><p>链接器从<code>Foundation Framework</code>中找到了类的符号定义，从而将<code>Foundation Framework</code>中相关的对象文件链接进来</p></li>
<li><p>由于链接器不链接方法符号，所以<code>weibosdk_WBSDKJSONString</code>这样的方法符号完全被忽略了。</p></li>
<li><p>由于类符号的定义在<code>Foundation Farmework</code>中定义，所以<code>WBSDKJSONKit.o</code>对象文件中没有符号被引用，链接器就没有把这个对象文件链接进来。</p></li>
<li><p>运行时运行到<code>weibosdk_WBSDKJSONString</code>方法时，由于<code>Foundation Framework</code>中是不存在这个方法的定义的，而存在这个方法定义的<code>WBSDKJSONKit.o</code>对象文件又没有被链接器链接进来，所以崩溃了。</p></li>
</ul>


<h3>为什么增加编译选项可以解决问题？</h3>

<p>我们继续引用苹果的开发者网站针对这个问题的<a href="https://developer.apple.com/library/ios/qa/qa1490/_index.html">说明文章</a>中的内容：</p>

<blockquote><p>Passing the -ObjC option to the linker causes it to load all members of static libraries that implement any Objective-C class or category. This will pickup any category method implementations. But it can make the resulting executable larger, and may pickup unnecessary objects. For this reason it is not on by default.</p></blockquote>

<p>加了<code>-ObjC</code>选项后，不管是否被引用到，链接器会把 Objective-C 的类和分类的所有对象文件全部链接，全部链接后方法符号全部被链接进来，崩溃的问题自然被解决了。</p>

<p>而<code>-all_load</code>选项更彻底，这个选项会让链接器把全部的对象文件都链接进来，当然，代价就是构建的 APP 体积会变大。</p>

<h3>为什么 cocos2d-x 加了编译选项会无法编译通过？</h3>

<p>其实准确的说法是编译可以成功进行，链接器执行报错。我们再回顾一下加了<code>-ObjC</code>或<code>-all_load</code>链接选项后链接器的报错信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Undefined symbols for architecture i386:
</span><span class='line'>  "_GCControllerDidConnectNotification", referenced from:
</span><span class='line'>      -[GCControllerConnectionEventHandler observerConnection:disconnection:] in libcocos2dx iOS.a(CCController-iOS.o)
</span><span class='line'>  "_GCControllerDidDisconnectNotification", referenced from:
</span><span class='line'>      -[GCControllerConnectionEventHandler observerConnection:disconnection:] in libcocos2dx iOS.a(CCController-iOS.o)
</span><span class='line'>  "_OBJC_CLASS_$_GCController", referenced from:
</span><span class='line'>      objc-class-ref in libcocos2dx iOS.a(CCController-iOS.o)
</span><span class='line'>     (maybe you meant: _OBJC_CLASS_$_GCControllerConnectionEventHandler)</span></code></pre></td></tr></table></div></figure>


<p>根据报错信息我们能够了解到报错是一个名叫<code>CCController-iOS.o</code>对象文件导致的，而这个文件对应的源代码是<code>CCController-iOS.mm</code>，通过阅读源码我们发现，这个文件中定义了一个 Objective-C 的类<code>GCControllerConnectionEventHandler</code>，这个类中的方法引用了<code>GCControllerDidConnectNotification</code>和<code>GCControllerDidDisconnectNotification</code>两个类，而这两个类实在<code>GameController Framework</code>中定义的。</p>

<p>而 cocos2d-x 生成的项目默认并没有为我们引入<code>GameController Framework</code>，所以在链接时由于链接器找不到对应类的符号定义，所以才会报错。如果你到 Xcode->Target->Buid   Phases-> 下   Link Binary With Libraries   项添加<code>GameController Framework</code>就可以解决问题了，但是这种解决方式<strong>很不干净</strong></p>

<h3>正确的姿势</h3>

<p><code>-force_load path/to/your/libWeiboSDK.a</code>链接选项其实是干了和<code>-ObjC</code>、<code>-all_load</code>一样的事情，只不过它更有针对性，它只让链接器把你指定的静态链接库中的全部对象文件链接进来，这样更清爽一些。</p>

<p>希望我的解释已经够深入了。</p>

<p>:&ndash;)</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-01-08T14:48:45+08:00" pubdate data-updated="true">2015年1月8日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/cocos2d-x/'>cocos2d-x</a>


</div>
	
	<div class="comments"><a href="/blog/2015/01/08/ios-ping-tai-cocos2d-x-xiang-mu-jie-ru-xin-lang-wei-bo-sdk-de-keng/#disqus_thread">Comments</a></div>
	
	<div>
		<br/><div>如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</div>
		<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="post" target="_blank" accept-charset="GBK" id="alipayForm">
			<input name="optEmail" type="hidden" value="leenjewel@gmail.com" />
			<input name="payAmount" type="hidden" value="1.00" />
			<input id="title" name="title" type="hidden" value="捐赠给 leenjewel.github.io" />
			<input name="memo" type="hidden" value="文章写的不错，我来捐赠鼓励的！" />
			<input name="pay" type="image" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" width="150" height="40">
		</form>
	</div>
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/11/21/google-play-in-app-billing-cai-guo-de-na-xie-keng/">
		
			Google Play In-app Billing 踩过的那些坑</a>
	</h2>
	<div class="entry-content">
		<p>最近在做的一款游戏针对海外发行，要上 Google Play，所以支付这块儿要接入 Google Play 。因为我们是免费 App + 应用内支付，所以 Google Play 这块儿只接入 In-app 类型的支付方式，接下来我准备吐槽了。</p>

<h3>大环境</h3>

<p>国内做 Google Play 相关的开发外围难度因素可想而知。具体原因相比大家都知道，所以那个什么墙什么的我就不多说了。这里已经无力吐槽了。</p>

<h3>流程</h3>

<p>这里简单说一下 Google Play In-app Billing 支付的流程。具体的建议看<a href="https://developer.android.com/google/play/billing/index.html?hl=d">官方文档</a>最靠谱。Google Play 没有可重复购买商品这个概念，所有的“商品/充值档”用户成功购买过一次之后就不允许再次购买了。所以为了实现像应用内支付充值这种可重复购买的“商品/充值档”，Google Play 提供了一个<a href="https://developer.android.com/google/play/billing/api.html#consume">“消耗”借口(Consuming In-app Products)</a>。用户购买完商品后，调一下“消耗”接口，这样用户下次就可以继续购买了。</p>

<h3>写代码</h3>

<p>还是就看<a href="https://developer.android.com/google/play/billing/index.html?hl=d">官方文档</a>是最靠谱的，In-app Billing 的 API 有个 v2 版本和 v3 版本，v2 版本已经不支持了，直接整 v3 版本的吧。怎么开发，怎么写代码这块儿没什么好说的，看着文档写，基本都不会错。这里我只掉进坑里去一次，说说。</p>

<h3>ProductID 这个坑</h3>

<p>在发起购买时需要调用 <a href="https://developer.android.com/google/play/billing/billing_reference.html#getBuyIntent">getBuyIntent(int apiVersion, String packageName, String sku, String type, String developerPayload)</a>这个方法，sku 就是充值档ID（也就是 productId）。因为我们的游戏是夸 iOS 和 Android 平台的，在做 iOS 支付的时候，配置的充值档ID都是 Bundle Identifier + xxx 的格式，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>com.abc.def.product1
</span><span class='line'>com.abc.def.product2</span></code></pre></td></tr></table></div></figure>


<p>在 Google Play Developer Console 配置充值档时，为了统一，我们配置的和 iOS 一样的 productId，也同样是为了统一，我们 Android 项目配置的 package name 也和 iOS 配置的 Bundle Identifier 是一样的，所以我就掉坑里面了。</p>

<p>看到 <a href="https://developer.android.com/google/play/billing/billing_reference.html#getBuyIntent">getBuyIntent(int apiVersion, String packageName, String sku, String type, String developerPayload)</a> 这个方法需求一个 sku 还需求一个 packageName ，我当时<strong>错误</strong>的认为 sku 和 packageName 分开传，所以<strong>错误</strong>的写成了</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// 假设要充值的充值档 ID 为 com.abc.def.product1 </span>
</span><span class='line'><span class="c1">// **注意** 这样写是错误的！！！</span>
</span><span class='line'><span class="n">getBuyIntent</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">&quot;com.abc.def&quot;</span><span class="o">,</span> <span class="s">&quot;product1&quot;</span><span class="o">,</span> <span class="s">&quot;inapp&quot;</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果在调用 <a href="https://developer.android.com/google/play/billing/billing_reference.html#getSkuDetails">getSkuDetails(int apiVersion, String packageName, String type, in Bundle skusBundle)</a> 方法时就一直返回空结果，告诉我找不到对应的商品。这里正确的做法就是<strong>严格</strong>按照你 Google Play Developer Console 里配置的 ProductId 来写，配置的是什么值，就传什么值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// 假设要充值的充值档 ID 为 com.abc.def.product1 </span>
</span><span class='line'><span class="n">getBuyIntent</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">&quot;com.abc.def&quot;</span><span class="o">,</span> <span class="s">&quot;com.abc.def.product1&quot;</span><span class="o">,</span> <span class="s">&quot;inapp&quot;</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>支付验证</h3>

<p>一般的支付验证都是支付方会有个接口，玩家支付成功后需要将支付数据通过支付方提供的接口（一般为 HTTP 或 HTTPS）进行验证，验证通过后才会确认支付成功。</p>

<p>Google Play In-app Billing 并没有提供支付验证接口，它的验证方法是通过公钥自行验证计算。在客户端通过公钥自行验证虽然没什么问题，但总觉的不放心，特别是手游这种，还是发往自己的服务器端去做验证比较好。我看 Google 的官方文档对这方面的介绍并不是很多，贴别是服务器端验证，这里我贴出 PHP 的范例代码，其实挺简单的。</p>

<p>通过参看官方文档对 <a href="https://developer.android.com/google/play/billing/billing_reference.html#getBuyIntent">getBuyIntent</a> 支付成功返回的数据结构的说明：</p>

<blockquote><p>Table 3. Response data from an In-app Billing Version 3 purchase request.</p>

<p>Key : <strong>INAPP_PURCHASE_DATA</strong></p>

<p>Description : A String in JSON format that contains details about the purchase order. See table 4 for a description of the JSON fields.</p>

<p>Key : <strong>INAPP_DATA_SIGNATURE</strong></p>

<p>Description : String containing the signature of the purchase data that was signed with the private key of the developer. The data signature uses the RSASSA-PKCS1-v1_5 scheme.</p></blockquote>

<p>当客户端收到玩家支付完成的回调时，将上述两个数据传送给后端服务器接口，后端的验证流程是：</p>

<p>在 Google Play Developer Console 找到当前应用的设置页面，在“服务和API”设置分页内找到“此应用的许可密钥”，将密钥<strong>原封不动且删除多余空格</strong>地复制下来，然后我们直接上 PHP 的示例代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="nv">$inapp_purchase_data</span> <span class="o">=</span> <span class="s1">&#39;客户端回传的 INAPP_PURCHASE_DATA 对应的数据&#39;</span><span class="p">;</span>
</span><span class='line'><span class="nv">$inapp_data_signature</span> <span class="o">=</span> <span class="s1">&#39;客户端回传的 INAPP_DATA_SIGNATURE 对应的数据&#39;</span><span class="p">;</span>
</span><span class='line'><span class="nv">$google_public_key</span> <span class="o">=</span> <span class="s1">&#39;Google Play Developer Console 中此应用的许可密钥&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">$public_key</span> <span class="o">=</span> <span class="s2">&quot;-----BEGIN PUBLIC KEY-----</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">.</span> <span class="nb">chunk_split</span><span class="p">(</span><span class="nv">$google_public_key</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">.</span> <span class="s2">&quot;-----END PUBLIC KEY-----&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">$public_key_handle</span> <span class="o">=</span> <span class="nb">openssl_get_publickey</span><span class="p">(</span><span class="nv">$public_key</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="nv">$result</span> <span class="o">=</span> <span class="nb">openssl_verify</span><span class="p">(</span><span class="nv">$inapp_purchase_data</span><span class="p">,</span> <span class="nb">base64_decode</span><span class="p">(</span><span class="nv">$inapp_data_signature</span><span class="p">),</span> <span class="nv">$public_key_handle</span><span class="p">,</span> <span class="nx">OPENSSL_ALGO_SHA1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">===</span> <span class="nv">$result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 支付验证成功！</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>测试</h3>

<p>总的来说，Google Play In-app Billing 支付接入的开发算是比较简单的，步骤不多，也比较容易理解。最让人头疼的是测试，特别是你人在大陆，那就是难上加难了~坑略多。</p>

<h3>上传测试 APK</h3>

<p>首先你要在 Google Play Developer Console 里面为你要测试的 APP 新建一个应用，然后上传你要测试的 APP 的 APK 包。这里有两点注意：</p>

<blockquote><ul>
<li>上传的 APK 包必须要有签名，而且不能用 Debug 签名。</li>
<li>上传的 APK 包体积不能超过 50MB 超过的话要做分包（分包打算下回单开一篇来讲）。</li>
</ul>
</blockquote>

<p>Google Play Developer Console 一个应用可以对应发布三个频道，正式版、Beta版和Alpha版，我们测试用的 APK 只要上传到 Beta版或 Alpha版频道就好。</p>

<h3>发布你的应用</h3>

<p>看到“发布”这个词你可能会慌一下：“怎么，我的应用还没做完呢，怎么能发布呢？”。不要担心，这里你只上传了你的测试 APK 包到 Beta 或 Alpha 频道，把应用发布了，普通用户也是无法下载的。发布是必须做的，如果你只处于默认的“草稿”状态，是根本没办法测试支付功能的。</p>

<p>这里吐个槽，当你发布了你的应用后 Google Play 不会立即让它生效。仔细看你的 Google Play Developer Console 页面，你会发现 Google 提示你要等一等才会发布成功，等待的时间是按“小时”为单位的，没辙，耐心等待吧。</p>

<h3>准备测试帐号</h3>

<p>上面说了，发布应用后要等，到底要等到什么时候呢？在你的 Google Play Console 页面你对应发布的频道那里会有个“管理测试人员列表”的超链接，点开会弹出一个弹出框，在弹出框里有个标题是“与测试者分享以下链接”，下面有个 URL 链接，形如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="nx">https</span><span class="o">://</span><span class="nx">play</span><span class="o">.</span><span class="nx">google</span><span class="o">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">apps</span><span class="o">/</span><span class="nx">testing</span><span class="o">/</span><span class="nx">xxxxxxx</span>
</span></code></pre></td></tr></table></div></figure>


<p>的链接，用浏览器点开这个链接你会发现如果它跳转到了 Google Play 应用商店并能看到你的测试应用了，说明你已经发布成功了。</p>

<p>什么？你一直看不到 Google Play 应用商店里你发布的应用？那说明你当前登录到 Google Play 应用商店的帐号既不是你这个应用的开发者帐号，也不是你这个应用的测试组帐号。</p>

<p>成为开发者需要在 Google Play Developer Console 里面设置，这个就不多讲了。主要提一下怎么成为测试帐号。</p>

<p>首先你要到 <a href="https://groups.google.com">Google Group</a> 去建立一个新的论坛，然后回到 Google Play Console 页面你对应发布的频道，还是点击“管理测试人员列表”，在弹出的弹出框里将你刚刚建立好的 Google Group 群组的 Email 填写进去。这样只要你邀请进入这个 Google Group 的人员都是这个应用的测试人员了。</p>

<h3>在真机上安装要测试的APP</h3>

<p>要测试 Google Play In-app Billing 支付，一定要在真实的设备上测试，而且还要保证设备上装了 Google Play 国内一般装了制定 Android 系统的手机都不会默认安装 Google Play 需要你去网上搜一艘 Google Play 的安装包。我当时用的是 Google 的 Nexus 7 测试的，系统用的 Google 原生 4.4.4。</p>

<p>这里你可能还有个疑问：“我在测试我的 APP 时肯定会经常做一些修改，或要加断点 Debug，我总不能修改一次就发个 APK 包到 Google Play Developer Console 吧？”。这里你可以放心，你完全没必要用上传的 APK 来测试，你只要保证</p>

<blockquote><p>安装到真机上的测试 APP 签名和上传到 Google Play 的 APK 包的签名一致</p></blockquote>

<h3>搞定 Google Play</h3>

<p>好了，如果目前你手拿着安装好测试 APP 的真机设备，设备上安装有 Google Play ，Google Play 上登录了你的开发组或测试组人员帐号，你的应用已经成功发布了，而刚好你此时人不是在大陆，那么恭喜你，你已经可以开始测试你的支付了。</p>

<p>如果你上述工作都做好了，可是你人在大陆，那么你就“万事俱备，只欠东风”了。</p>

<p>先吐槽，在 Google Play Developer Console 的应用发布国家列表中是不允许选择“中国”的，Google Play 在大陆也是不允许支付的。如果你用你的设备打开 Google Play 应用商店看到的满眼都是免费应用，一个付费应用都没有，那么“恭喜”你，目前 Google Play 认为你是个大陆用户，你是不允许付费的，自然你就没办法测试你的支付流程了。</p>

<p>网上查一圈，发现不少人给出解决方案，都挺复杂的。什么又要先把设备给越狱拿到 root 权限啦，什么又要安装第三方破解 Google Play 的软件啦，还有什么需要插个国外的 SIM 卡了，据本人亲测根本没那么那么费劲，你只要有个 VPN 即可，你懂的。</p>

<p>根据我本人拿着手头的 Nexus 7 亲测，只要你在设备上连上 VPN（也有人说要 VPN 对应的国家要涵盖在你要测试应用对应发布的国家范围内，这点我没有亲测，我只知道当时我的 VPN 是加拿大，而加拿大也是在我测试的应用对应的发布国家内）。再打开 Google Play 应用商店，如果这时候你发现你能看到付费应用了，这说明你的“东风”也来了。</p>

<p>如果连上 VPN 后在 Google Play 应用商店还是看不到其他付费应用的话，先尝试去设置那里删除 Google Play 的缓存数据，如果还不行据说需要将你的设备恢复一下出厂设置再连上 VPN 就可以了。</p>

<p>打开你的测试 APP 点击支付，如果弹出 Google Play 的支付弹出框，说明流程都走通了。最后说一句，要想付费成功你的 Google Play 帐号必须绑定有海外支付能力的信用卡或者有海外支付能力的 Paypal 账户，这个只能你自己想办法了。</p>

<p>祝玩得愉快~</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-21T15:14:24+08:00" pubdate data-updated="true">2014年11月21日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/android/'>Android</a>


</div>
	
	<div class="comments"><a href="/blog/2014/11/21/google-play-in-app-billing-cai-guo-de-na-xie-keng/#disqus_thread">Comments</a></div>
	
	<div>
		<br/><div>如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</div>
		<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="post" target="_blank" accept-charset="GBK" id="alipayForm">
			<input name="optEmail" type="hidden" value="leenjewel@gmail.com" />
			<input name="payAmount" type="hidden" value="1.00" />
			<input id="title" name="title" type="hidden" value="捐赠给 leenjewel.github.io" />
			<input name="memo" type="hidden" value="文章写的不错，我来捐赠鼓励的！" />
			<input name="pay" type="image" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" width="150" height="40">
		</form>
	</div>
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/">
		
			【学习xv6】从实模式到保护模式</a>
	</h2>
	<div class="entry-content">
		<h2>前言</h2>

<p>这是一系列 xv6 代码学习的总结。对于还不知道 xv6 是什么的同学，我这里只简单说一下：xv6 是一个教学用的操作系统，基于 unix v6，再具体的请大家自行 Google 一下 wiki 什么的。</p>

<p>配合这个系列的文章，我在<a href="https://github.com/leenjewel/">我的 GitHub</a>上建立了一个叫<a href="https://github.com/leenjewel/xv6_learn">xv6_learn</a>的项目，这个项目就是在 clone 自 xv6 官方源代码的基础上在源码文件中加入了我学习过程中的大量注释。所以在大家看这一系列文章的同时结合着源代码文件中我加入的注释来看可能效果更好一些。下面言归正传讲 xv6 之前先预习一下用到的一些知识。</p>

<h2>预备知识</h2>

<h4>程序 = 数据 + 指令</h4>

<p>无论是操作系统还是运行在操作系统上的软件，对于计算机来说他们都是程序。而程序的组成我们可以简单的理解为：数据加上指令就是程序。当一个程序被从硬盘加载到内存后，CPU 从内存读取程序中的指令执行，执行过程中需要从内存中读取程序的数据，配合指令计算出结果之后还需要放回到内存中。这就是简化后的程序执行过程。</p>

<h4>如何从内存读取指令和数据</h4>

<p>x86 使用“段基址 + 偏移量”的方式来读写内存。这就好比问路，当你向一个人问路时，一般人们回这么回答你：“从前面那个路口开始，往前再走三个路口就到了”。x86 CPU 对内存的寻址也是这个思路，“前面那个路口”就指的是“段基址”，“往前再走三个路口”指的就是“偏移量”，有了这两个线索，CPU 也可以顺利到达内存中的目的地写入或取走数据或指令。</p>

<h4>为什么有个“段”字</h4>

<p>有人可能会问“段基址”里面的“段”代表什么呢？前面说了，程序是由数据和指令组成的，一个程序要运行就先要加载到内存中。而程序中的数据和指令是两个相互独立的部分，CPU 从内存读取他们的时候也是将他们看作是不同的“段”。这里还要插一句，程序中的数据还要分很多种类型，所以 CPU 针对一个程序的不同部分准备了 4 个寄存器来分别存储他们的“段基址”。这 4 个寄存器分别是用于程序指令的 CS 代码段寄存器、用于程序数据的 DS 数据段寄存器、用于程序堆栈（也是数据的一种）的 SS 堆栈段寄存器和 ES 附加段寄存器（也是数据的一种）。</p>

<p>有了这 4 个寄存器存储“基地址”（数据的存放起始点），再配合“偏移量” CPU 就可以从内存读写数据和指令了。例如 CPU 在从内存中读取一个程序的指令准备执行的时候就可以说：“从 CS 指向的地方开始向后读取 2 个位置”，内存收到 CPU 给的“指路信息”后就会把相应位置的指令发给 CPU，CPU 拿到指令就可以开始执行了。</p>

<h4>“段基址” + “偏移量” 寻址方式的由来</h4>

<p>了解了 x86 的内存寻址方式，不禁要问：“为什么要这么设计？”这得从英特尔的 8086 CPU 开始讲起。我们有时说起计算机硬件配置的时候经常会说：“我的电脑是 32 位的”。这里的 32 位起始指的是 CPU 内部的“数据总线”宽度，也叫<del> AUL</del> ALU（算数逻辑单元，感谢 Zongren Zhang 同学找到错误并指正）的宽度。说白了就是 CPU 一次性传递数据的宽度。</p>

<p>英特尔的 8086 CPU 是 16 位的，如果直接用来表示内存地址的话，16 位最大可以表示的内存地址是 2<sup>16</sup> = 65536 个地址，每个地址代表一字节的内存数据的话，16 位最多只能支持 64KB 内存，这显然是不够用的。于是英特尔在保持数据线宽为 16 位的同时将地址线的宽度增大到 20 位，也就是说内存地址是 20 位的，这样就可以拥有 2<sup>20</sup> = 1048576 个地址，最多支持 1MB 的内存，当时的人们认为这样就足够了。</p>

<p>现在问题来了，16 位的数据线宽（寄存器自然也是 16 位的）如何能表示 20 位的地址呢？答案是用两个 16 位的寄存器来表示。这就是“段基址” + “偏移量”寻址方式的由来。一个 16 位的寄存器来表示“段基址”（CS、DS、SS、ES四个寄存器），具体的做法是先将 16 位的“段基址”左移 4 位，然后加上 16 位的“偏移量”最终得到 20 位的内存地址送入地址线。</p>

<h4>地址卷绕</h4>

<p>用两个 16 位的寄存器左移相加来得到 20 位的内存地址这里还是有问题。那就是两个 16 位数相加所得的最大结果是超过 20 位的。例如段基址 0xffff 左移变成 0xffff0 和偏移量 0xffff 相加得到 0x10ffef 这个内存地址是“溢出”的，怎么办？这里 CPU 被设计出来一个“卷绕”机制，当内存地址超过 20 位则绕回来。举个例子你拿 0x100001 来寻址，我就拿你当作 0x00001 。你超出终点我就把你绕回起点。</p>

<h4>向下兼容的现代 x86 计算机</h4>

<p>8086 的年代已经远去。现在的 x86 已早经是 32 位的了（目前 32 位基本已经没有了，64 位是主流了）。但无论位数如何增加，寻址能力如何增大，x86 一直保持着向下兼容的良好传统。即便是当初为 8086 这种 16 位机器写的软件或操作系统（如 DOS）仍能够在现在的 x86 计算机上顺利运行。</p>

<p>那么这种良好的向下兼容性是如何实现的呢？答案是：“开关”。现代的 x86 计算机，无论你是 32 位的还是 64 位的，在开机的那一刻 CPU 都是以模拟 16 位模式运行的，地址卷绕机制也是有效的，所以无论你的电脑内存有多大，开机的时候 CPU 的寻址能力只有 1MB，就好像回到 8086 时代一样。</p>

<p>那么什么时候才结束 CPU 的 16 位模式运行呢？这由你（操作系统）说了算，现代的计算机都有个“开关”叫 A20 gate，开机的时候 A20 gate 是关闭的，CPU 以 16 位模式运行，当 A20 gate 打开的时候“卷绕”机制失效，内存寻址突破 1MB 限制，我们就可以切换到正常的模式下运行了。具体如何打开 A20 gate，下面分析 xv6 的源代码时我会详细说明。</p>

<h4>再说说把程序加载到内存</h4>

<p>我们编写程序代码，编译器将我们的程序代码变成 CPU 可以理解的指令（二进制可执行程序）。在运行我们写的程序前，需要将程序先加载进内存，而我们的程序应该加载到内存的什么位置这应该是由操作系统来负责的，我们程序本身是不能决定这一切的。</p>

<p>这里就产生了一个“矛盾”。在程序真正运行前我们是不知道我们会被放在内存的什么地方，但是我们的程序本身还有数据，代码也含有对数据的访问（例如我们的代码中使用的各种变量），我们不知道我们的数据会被操作系统放在哪，但我们还要在代码里写访问这些数据的逻辑，这是一个矛盾，要怎么办？</p>

<p>解决上述矛盾的办法就是使用相对地址访问。我们的程序在运行前不知道会被操作系统放在内存的什么地方，所以我们在编写程序的时候会做个假设，假设我们的程序会被放在从内存地址 N 开始向后的地方。这个时候我们的程序在访问我们的变量时都继续这个假设，加入我们想要读取我们的变量 a 时，我们就编写指令说我们要访问 N + X 的内存地址，那里存放着我们的变量 a，当然这些假设和生成每个数据的相对访问地址的工作都由编译器代劳了，对于我们程序的编写来说不用为这些事情而烦恼。</p>

<p>所以我们的每一个程序都会基于一个统一的假设：“我们会被从内存地址 N 开始放置”，至于到真正运行时这个 N 对应的内存地址具体是多少无所谓，因为我们对我们程序数据的访问都是相对于 N 的偏移。这就好比说：“我在距离你左边 20 米的地方”，无论你在哪，在火星上也罢，向左走 20 米，你总能找到我。</p>

<h4>程序是“假设”的，操作系统要动“真格”的</h4>

<p>上面说了，所有的程序都基于一个相同的“假设”，但是当程序真正运行的时候，操作系统将程序加载到内存时就不能对程序的这个“假设”听之任之了。当操作系统把程序放置到真正的内存位置后，程序运行起来，程序基于假设 N + X 计算出的内存地址就需要操作系统“翻译”成真正的内存地址后才能真的从内存中读取到想要的数据，而这个“翻译”的过程就需要操作系统和 CPU 来配合实现了。</p>

<p>程序基于“假设”计算出的地址叫做“虚拟地址”也叫做“逻辑地址”（他们是一样的，只是叫法不同），与之对应的内存的真实地址叫做“物理地址”，从“虚拟地址”到“物理地址”的转换是通过一个叫做 MMU（内存管理单元）的硬件实现的，当然这里还少不了操作系统的配合。</p>

<p>从“虚拟地址”到“物理地址”，计算机硬件与操作系统的配合为在操作系统上运行的各种程序提供了“智能”、“安全”、“高效”的运行环境，好处多多。比如程序通过这种假设，统一了虚拟的内存布局，从程序开发层面屏蔽了内存规划的复杂性，运行环境的差异性等，程序只需要关系自己的逻辑，内存布局的事情交给操作系统来负责。另一方面，每个程序运行在各自的内存空间上，彼此处于相互隔离的状态，程序之间无法操作自己内存空间以外的内存，这也增加了程序运行的安全性。</p>

<h4>实模式与保护模式</h4>

<p>罗马不是一天建成的。上面所说的系统硬件和操作系统配合建立的“智能”、“安全”、“高效”的运行环境也是后来才逐渐完善的。所以为了区分这两种环境，在“智能”、“安全”、“高效”的运行环境建立之前计算机是运行在“实模式”下的，在“实模式”下没有“虚拟地址”到“物理地址”的转换，“虚拟地址”就相当于是“物理地址”，而想要这些特性就需要对应的把计算机的运行环境切换到“保护模式”下。</p>

<p>就像之前我们讲到的 A20 gate 从 1MB 的内存寻址模式切换到更大的寻址能力一样。x86 架构的计算机为了向下兼容，开机的时候不仅运行在 1MB 内存寻址环境下，这时候也是运行在“实模式”环境下的。同样有一个开关控制着从“实模式”到“保护模式”的切换，这个开关叫“控制寄存器”。</p>

<h4>保护模式下的分段与分页</h4>

<p>前面说道“保护模式”是由硬件和操作系统配合来提供的。“保护模式”涉及的知识非常多，不仅仅只有对内存的管理，还有诸如进程管理、硬件管理等诸多方面，这里只简单介绍一下“保护模式”下的内存管理。“保护模式”实现的两种内存管理方式：“分段式和分页式”。分页式是目前主流操作系统（Windows、Linux、FreeBSD等）所采取的内存管理方式。</p>

<p>“分页式”技术的出现要比“分段式”晚一些，碰上 x86 这样历史悠久的硬件架构就不得不再提“向下兼容”了。所以 x86 的分页式的实现是继续分段式基础上的。所以想要在 x86 上建立起分页式的内存管理就先要建立分段式内存管理，分页式我们暂且不说，先说说分段式。</p>

<p>分段式简单来说就是将内存规划出不同的“片段”来分配给不同的程序（也包含操作系统自己）使用。分页式则是将内存规划成大小相同的“页”，再将这些页分配给各个程序使用。</p>

<p>这里有两个“段”字非常让人容易迷糊。分段式里的段与之前讲过的“段基址”完全是两码事儿。实模式下的段寄存器里的“段基址”实际上还可以算作内存物理地址，它指向的是内存中的一个位置，而在分段式的保护模式下段寄存器里的“段基址”的意义已经发生里改变，它不再是内存的物理地址，而是指向一个内存分段的段索引。在分段模式下，内存被划分为很多个“片段”，程序数据以及指令就放在这些片段中，当要读取内存中具体的数据时，首先要直到这个数据在哪个“片段”里，这时段寄存器里的“段基址”指向某一个内存片段的下标，而这时的“偏移量”则相应的表示为具体的数据在它所在的内存“片段”里的偏移量。</p>

<p>所以在分段模式下，内存里会有一个“表”，这个“表”里存放了每个内存“片段”的信息（如这个“片段”在内存中的地址，这个“片段”多长等），比如我们现在将内存分成 10 个片段，则这时我们有一个“表”，这个“表”有 10 项分别存放着对应这 10 个内存片段的描述信息。这时我有个数据存放在第 5 个片段中，在第 5 个片段的第 6 个位置上，所以当我们想要读取这个数据的时候，我们的数据段寄存器里存放的“段基址”是 5 这个数，代表要去第 5 个片段上找，对应的这时候的“偏移量”就是 6 这样我们就可以顺利的找到我们想要的数据里。</p>

<p>而要想实现在分段式保护模式下成功的寻址，操作系统需要做的就是在内存中建立这个“表”，“表”里放好内存分段的描述信息，然后把这个“表”在内存的什么位置，以及这个“表”里有多少个内存分段的描述信息告诉 CPU。这个“表”有个学名叫 GDT 全局描述符表，这个我们后面还会有介绍。</p>

<h4>分段式的“段基址” + “偏移量”寻址方式</h4>

<p>在“实模式”下我们讲到内存的寻址方式是“段基址” + “偏移量”，他们生成的结果就是直接可用的内存物理地址，但是到了分段式的保护模式下我们有了 GDT，GDT 里面有了段描述符，段描述符里存储的才是真正的内存物理地址，所以这里我们的“段基址”和“偏移量”的意义都发生了变化。</p>

<p>在分段式的保护模式下，16 位的“段基址”不再表示内存的物理地址，而是表示 GDT 表的下标，用来根据“段基址”从 GDT 表中取得对应下标的“段描述符”，从“段描述符”中取得真实的内存物理地址后在配合“偏移量”来计算出最终的内存地址。</p>

<h4>一个简单的比喻</h4>

<p>说了那么多内存寻址的事儿，说到底无论是程序还是操作系统（其实也是程序），最后到计算机那里都会变成 CPU 从内存通过寻址读取指令和数据执行而已。无论是实模式下的“段基址”+“偏移量”还是保护模式下的“段基址”+“偏移量”，寻址的过程都是十分类似的。为了不让大家脑子里那么乱，这里我在打一个比喻来帮助大家理解“内存寻址”的过程。</p>

<p>内存就好比一个大仓库，这个仓库里有好多好多货架用于存放货物（指令和数据）。我们的操作系统就是这个仓库的管理员，而 CPU 就是这个仓库的小工，这时我们送来一个货物（程序），这个货物有两个大箱子，一个箱子贴着“代码”的标签，另一个贴着“数据”的标签。贴着“代码”标签的箱子里按顺序放着一张一张写着字的纸条（指令），另一个贴着“数据”标签的箱子里放着我们自己按照自己想要的顺序码放好的物品（数据）。这时我们把这个货物（程序）交给仓库管理员（操作系统），看看会发生什么。</p>

<p>管理员（操作系统）拿到我们的货物（程序），先将贴着“代码”标签的箱子放到仓库的某一个货架上，比如放在了 3 号货架上，并在小本本上（代码段寄存器）记下这个箱子放在了 3 号货架上。然后又将贴着“数据”标签的箱子放到 5 号货架上，并在小本本上（数据段寄存器）记录下这个箱子放在了 5 号货架上。接下来就该仓库小工（CPU）工作了。</p>

<p>仓库小工按照小本本上（代码段寄存器）记录的地址跑到 3 号货架上找到那个贴着“代码”标签的箱子，
按顺序先抽出了箱子里的第一章小纸条（指令），上面写着“我要贴着数据箱子里的第 6 个物品”，这时仓库小工跑去看了一眼量外一个小本本（数据段寄存器），直到贴着“数据”标签的箱子是放在 5 号货柜的，于是仓库小工到了 5 号货柜找到了那个箱子，从箱子里数到第 6 个物品（偏移量）把它拿了出来。</p>

<p>这就是一次内存寻址的过程。我们在写程序的时候，也就是我们准备我们的货物时，我们可以按照我们想要的顺序来码放我们的物品到箱子里（只关心偏移量），当我们把我们的程序写好准备真正去执行的时候，也就是货物准备好交给仓库管理员的时候，仓库管理员按照他自己的想法把我们的货物放在货柜上，并记下我们的箱子都放在哪个货柜（只关心段寄存器里的段基址），等到仓库小工忙活起来的时候拿着货柜号和我们想要的物品在箱子里的相对位置就能够顺利找到我们想要的东西了，这就是“段基址”+“偏移量”的寻址方式。</p>

<p>而什么保护模式之流无非是仓库小工在按照“段基址”+“偏移量”取货的前额外的验证了一下要去的东西到底是不是你的（程序要读取的数据是否属于该程序），你说要箱子里的第 6 个物品，取货前在额外看看你箱子里到底是不是真的有 6 个以上的物品，而取货的流程本质上是没有发生变化的。</p>

<h4>物理地址、线性地址、逻辑地址（虚拟地址）、虚拟内存</h4>

<p>关于内存寻址和内存管理方式已经说了一大堆里，这里通过帮助大家彻底理清上面这四个概念来让大家对内存这块有个整体的认识。</p>

<ul>
<li>物理地址</li>
</ul>


<p>这个没什么可说的，非常好理解，物理地址就是内存从硬件角度上真正的地址。所有对内存的寻址最终都要转换到物理地址上才能被识别。</p>

<ul>
<li>逻辑地址（虚拟地址）</li>
</ul>


<p>这两种叫法说的是一种东西。就是我们上面讲的程序基于统一的“假设”通过 N + X 计算出的内存地址。</p>

<ul>
<li>线性地址</li>
</ul>


<p>线性地址的概念是保护模式下才有的，在实模式下逻辑地址就是物理地址，在保护模式下还要根据分段和分页分开说。在分段模式下逻辑地址通过 GDT 转换成线性地址，此时如果没有分页机制那么线性地址就是物理地址，如果有分页机制，那么线性地址要通过 MMU 再一次转换之后才能变成物理地址。</p>

<ul>
<li>虚拟内存</li>
</ul>


<p>我们以 32 位计算机为例，在 32 位计算机上支持的最大内存寻址是 4GB，但是每个计算机上真正有多少内存却是不一定的。同样的 32 位计算机，有的可能只有 1GB 内存，有的只有 2GB 内存，而对于程序来说不应该收到这种硬件配置的影响，无论有多少内存，程序都应该正常运行。这就提出里虚拟内存的概念，就像我们之前说的程序的统一假设一样，对于每个程序来说，我们都统一假设只要你的寻址位宽是 32 位，那我就假设我有 4GB 内存可以利用。而具体有多少内存，如何和逻辑地址对应，这是操作系统需要考虑的事情了。</p>

<p>这里多说两句。有的人会有疑问：“我的32位计算机确实只有 1BG 内存，而你说程序当我是 4GB 内存，多余的 3GB 从哪来？”。其实很简单，还是从你的 1GB 物理内存上来。首先要确定的是在你的程序运行的某一时刻你不可能把 1BG 内存完全占用，即便你的程序真的把 1BG 物理内存全部占用里，在某一时刻你需要再向内存写入数据的时候，CPU 会先去内存中找到一个你这一刻不会用到的数据，将这个数据从内存换出到硬盘上，然后将你要写入的数据放入内存中。等之后的某一个时刻你的程序又想从内存中读取刚刚传出到硬盘的那个数据时，CPU 会再次通过同样的办法把一个不用的数据换出到硬盘再把你要的数据换回到内存中来。</p>

<h4>大小端模式</h4>

<p>在准备往下看的时候你会发现我在下面放了几个表格用来表示数据在寄存器或内存中的存储结构，这些表格都是按位来排列的。看这些表格的时候你可能会奇怪这些表格的位序号为什么都是从高到低的，这是因为 x86 是“小端模式”。</p>

<p>我们直到计算机中的数据就按照“字节”位单位存放的，就好像我们写字，当你写一个字的时候没什么问题，但是当你要写一句话的时候就有是“从做往右”还是“从右往左”写的问题。而计算机也一样，当内存或寄存器存储的数据超过 1 字节的时候也会有一个数据摆放顺序的问题。这就是所谓的大小端模式。</p>

<ul>
<li>大端模式 : 地址的增长顺序与值的增长顺序相同</li>
<li>小端模式 : 地址的增长顺序与值的增长顺序相反</li>
</ul>


<p>比如我们有一个 16 位（两字节）的数据 0x2345，要存放在内存地址 0x00000010 这个位置上，如果按照大端模式存储就是下面这个样子</p>

<table class="my-table">
<thead><tr><td>内存地址</td><td>0x00000010</td><td>0x00000011</td></tr></thead>
<tr><td>数据</td><td>0x23</td><td>0x45</td></tr>   
</table>


<br/><br/>


<p>如果是小端模式则是</p>

<table class="my-table">
<thead><tr><td>内存地址</td><td>0x00000010</td><td>0x00000011</td></tr></thead>
<tr><td>数据</td><td>0x45</td><td>0x23</td></tr>   
</table>


<br/><br/>


<p>而我们书写代码的习惯是从左往右写，则 x86 的小端模式如果按照内存地址位从高到低的方式来看，数据就是从左往右的正常顺序，这样我们看上去比较直观。</p>

<h4>预备知识总结</h4>

<p>说了一大堆，该铺垫的知识基本准备的差不多里，接下来我们就要具体分析 xv6 的代码实现里。这里我们总结一下上面介绍的预备知识，来说说作为一个操作系统在计算机启动后到底应该做些什么：</p>

<ul>
<li>计算机开机，运行环境为 1MB 寻址限制带“卷绕”机制</li>
<li>打开 A20 gate 让计算机突破 1MB 寻址限制</li>
<li>在内存中建立 GDT 全局描述符表，并将建立好的 GDT 表的位置和大小告诉 CPU</li>
<li>设置控制寄存器，进入保护模式</li>
<li>按照保护模式的内存寻址方式继续执行</li>
</ul>


<p>好了，下面我们正式进入 xv6 启动阶段的代码学习。</p>

<h2>从 Makefile 开始</h2>

<p>从一个操作系统的角度来说，xv6 的代码量并不大，总共不到一万行，分散在众多的源文件中。一上来可能觉得很迷茫，这么多文件，该从哪个开始看起？Makefile 则是这些文件的“目录”，通过它可以很容易找到头绪。</p>

<p>什么是 Makefile？如果你问起这个，那你还不适合看这个系列的文章，还是那句话，多 Google 吧。继续言归正传。</p>

<p>上一篇<a href="http://leenjewel.github.io/blog/2014/07/24/%5B%28xue-xi-xv6-%29%5D-zai-mac-osx-xia-yun-xing-xv6/">《【学习 Xv6 】在 Mac OSX 下运行 Xv6》</a>中说道 xv6 编译成功后会生成两个文件：xv6.img 和 fs.img 我们从 xv6.img 开始。</p>

<p>从 Makefile 中可以看到 xv6.img 的生成条件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xv6.img: bootblock kernel fs.img
</span><span class='line'>  dd if=/dev/zero of=xv6.img count=10000
</span><span class='line'>  dd if=bootblock of=xv6.img conv=notrunc
</span><span class='line'>  dd if=kernel of=xv6.img seek=1 conv=notrunc</span></code></pre></td></tr></table></div></figure>


<p>fs.img 这里暂且不说，通过字面不难看出 bootblock 应该是系统一开始引导阶段的逻辑，kernel 当然就是内核了。所以第一步先研究 bootblock。我们接着在 Makefile 里找 bootblock 的生成条件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bootblock: bootasm.S bootmain.c
</span><span class='line'>  $(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
</span><span class='line'>  $(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
</span><span class='line'>  $(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
</span><span class='line'>  $(OBJDUMP) -S bootblock.o &gt; bootblock.asm
</span><span class='line'>  $(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
</span><span class='line'>  ./sign.pl bootblock</span></code></pre></td></tr></table></div></figure>


<p>bootblock 的生成只需要两个文件，一个汇编一个 C 源码。那我们就准备讲讲 bootasm.S 文件了。</p>

<h2>x86 的启动</h2>

<p>看具体的代码前先说说 x86 架构开机引导的相关知识。从给 x86 通电的一刻开始，CPU 执行的第一段指令是 BIOS 固化在 ROM 上的代码，这个过程是硬件定死的规矩，就是这样。</p>

<p>而 BIOS 在硬件自检完成后（你会听到“滴”的一声）会根据你在 BIOS 里设置的启动顺序（硬盘、光驱、USB）读取每个引导设备的第一个扇区 512字节的内容，并判断这段内容的最后 2 字节是否为 0xAA55，如果是说明这个设备是可引导的，于是就将这 512 字节的内容放到内存的 0x7C00 位置，然后告诉 CPU 去执行这个位置的指令。这个过程同样是硬件定死的规矩，就是这样。</p>

<p>有了上面的介绍我们再回到 xv6 如果你看一下编译生成的 bootblock 二进制文件，你会惊喜的发现它的文件大小刚好是 512 字节。用十六进制编辑器（我在 Mac OSX 下用的是 0xED 这个软件）打开 bootblock 这个二进制文件，你又会发现这个 512 字节的文件的最后两字节正好是 0xAA55。</p>

<p>再回过头看上面 Makefile 中 xv6.img 生成条件的代码中也可以看出 xv6.img 就是通过 dd 命令讲编译好的 bootblock 和 kernel 拼接而成，这也再一次印证了 bootblock 是负责引导逻辑的结论。</p>

<p>有了这个结论，我们可以开始“放心大胆”的开始看 bootasm.S 这个汇编源文件的代码了。</p>

<h2>bootasm.S 文件</h2>

<p>看 bootasm.S 文件需要你有一定的汇编基础。没有也没关系，我尽量解释的清楚一些。</p>

<p>还是再看一眼 Makefile 里 bootblock 生成那段有这么一句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</span></code></pre></td></tr></table></div></figure>


<p>这段说明 bootblock 的代码段加载到内存 0x7C00 处，代码从 start 处开始执行（可以理解为相当于 C 中的 main 这样的入口函数）。所以 bootasm.S 一上来就是入口 start</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.code16
</span><span class='line'>.global start
</span><span class='line'>start:
</span><span class='line'>    cli
</span><span class='line'>    xorw    %ax,%ax
</span><span class='line'>    movw    %ax,%ds
</span><span class='line'>    movw    %ax,%es
</span><span class='line'>    movw    %ax,%ss</span></code></pre></td></tr></table></div></figure>


<p>先讲 start：下面的这 5 行代码。</p>

<p>cli 指令关闭了中断响应，意味着从这一刻开始你的计算机将不再响应任何中断事件（比如这时候你敲个键盘点个鼠标啥的，CPU 就不再理你了）。之所以要关闭中断响应是因为要保证引导代码的顺利执行（总不能执行到一半被 CPU 给中断了吧，那直接就挂了）。</p>

<p>接下来的 4 行代码显示用异或将 %ax 寄存器的值置成 0，然后在用 %ax 寄存器的值将 %ds、%es、%ss 三个寄存器的值全部置 0，相当于初始化了。</p>

<p>然后我们再看 .code16 这句。这告诉 CPU 我们目前是在 16 位模式下执行代码，此时内存寻址能力只有 1MB，并且是“实模式”下。</p>

<h2>打开 A20 gate</h2>

<p>在预备知识那段我们讲里要想计算机突破 1MB 内存寻址的限制我们要把 A20 gate 打开，我们接着往下看 xv6 bootasm.S 的代码。在初始化好寄存器后，xv6 bootasm.S 接下来要做的事情就是打开 A20 gate 突破 1MB 内存寻址的限制。</p>

<p>控制 A20 gate 的方法有 3 种：</p>

<ul>
<li>804x 键盘控制器法</li>
<li>Fast A20 法</li>
<li>BIOS 中断法</li>
</ul>


<p>xv6 用了第一种 804x 键盘控制器法，这也是最古老且效率最慢的一种。当然因为硬件的不同，这三种方法可能不会被硬件都支持，正确的做法应该是这三种都尝试一下，每尝试一个就验证一下 A20 gate 是否被正确打开以保证兼容各种硬件。但是 xv6 作为一款教学用的操作系统就没必要做的这么复杂里。只用了一种最古老的方法（保证兼容大多数硬件）而且没有对打开成功与否做验证。像诸如 Linux 这样的操作系统就把三种方法的实现都做好里，并且加上了验证机制。</p>

<p>我们具体来看 xv6 的实现代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>seta20.1:  
</span><span class='line'>  inb     $0x64,%al
</span><span class='line'>  testb   $0x2,%al
</span><span class='line'>  jnz     seta20.1 
</span><span class='line'>
</span><span class='line'>  movb    $0xd1,%al
</span><span class='line'>  outb    %al,$0x64
</span><span class='line'>
</span><span class='line'>seta20.2:
</span><span class='line'>  inb     $0x64,%al
</span><span class='line'>  testb   $0x2,%al
</span><span class='line'>  jnz     seta20.2 
</span><span class='line'>
</span><span class='line'>  movb    $0xdf,%al
</span><span class='line'>  outb    %al,$0x60</span></code></pre></td></tr></table></div></figure>


<p>这里 bootasm.S 用了两个方法 seta20.1 和 seta20.2 来实现通过 804x 键盘控制器打开 A20 gate。 这个办法确实是分两步来搞的：</p>

<p>第一步是向 804x 键盘控制器的 0x64 端口发送命令。这里传送的命令是 0xd1，这个命令的意思是要向键盘控制器的 P2 写入数据。这就是 seta20.1 代码段所做的工作（具体的解释可以参看我在代码中写的注释）。</p>

<p>第二步就是向键盘控制器的 P2 端口写数据了。写数据的方法是把数据通过键盘控制器的 0x60 端口写进去。写入的数据是 0xdf，因为 A20 gate 就包含在键盘控制器的 P2 端口中，随着 0xdf 的写入，A20 gate 就被打开了。</p>

<p>接下来要做的就是进入“保护模式”了。</p>

<h2>xv6 准备 GDT</h2>

<p>在进入保护模式前需要将 GDT 准备好。什么是 GDT ？它的中文名称叫“全局描述符表”，前面的“预备知识”里已经做里介绍，想要在“保护模式”下对内存进行寻址就先要有 GDT，GDT 表里的每一项叫做“段描述符”，用来记录每个内存分段的一些属性信息，每个“段描述符”占 8 字节，我们先来看一眼这个段描述符的具体结构：</p>

<table class="my-table">
<thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td> 9</td><td> 8</td><td> 7</td><td> 6</td><td> 5</td><td> 4</td><td> 3</td><td> 2</td><td> 1</td><td> 0</td></tr></thead>
<tr><th colspan="8">基地址</th><td> G</td><td>DB</td><td>XX</td><td>AA</td><th colspan="4">Limit</th><td> P</td><th colspan="2">DPL</th><td> S</td><td> E</td><td>ED</td><td>RW</td><td>A</td><th colspan="8">基地址</th></tr>
<tr><th colspan="16">基地址</th><th colspan="16">Limit</th></tr>
</table>


<br/><br/>


<p>三块“基地址”组装起来正好就是 32 位的段起始内存地址，两块 Limit 组成该内存分段的长度，接下来依次解释一下其他位所代表的意义：</p>

<ul>
<li>P:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;0 本段不在内存中</li>
<li>DPL:&#8194;&#8194;&#8194;&#8194;&#8194;访问该段内存所需权限等级 00 &mdash; 11，0为最大权限级别</li>
<li>S:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;1 代表数据段、代码段或堆栈段，0 代表系统段如中断门或调用门</li>
<li>E:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;1 代表代码段，可执行标记，0 代表数据段</li>
<li>ED:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;0 代表忽略特权级，1 代表遵守特权级</li>
<li>RW:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;如果是数据段（E=0）则1 代表可写入，0 代表只读；<br/>
&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;如果是代码段（E=1）则1 代表可读取，0 代表不可读取</li>
<li>A:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;1 表示该段内存访问过，0 表示没有被访问过</li>
<li>G:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;1 表示 20 位段界限单位是 4KB，最大长度 4GB；<br/>
&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;0 表示 20 位段界限单位是 1 字节，最大长度 1MB</li>
<li>DB:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;1 表示地址和操作数是 32 位，0 表示地址和操作数是 16 位</li>
<li>XX:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;保留位永远是 0</li>
<li>AA:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;给系统提供的保留位</li>
</ul>


<p>有了上述的解释，我们再来看看 xv6 是怎样准备自己的 GDT 的，代码在 bootasm.S 文件最底部：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gdt:
</span><span class='line'>  SEG_NULLASM                             # 空
</span><span class='line'>  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # 代码段
</span><span class='line'>  SEG_ASM(STA_W, 0x0, 0xffffffff)         # 数据（堆栈）段
</span></code></pre></td></tr></table></div></figure>


<p>这里用到了几个宏，具体的宏定义在 asm.h 文件中，为了方便大家直观的感受一下 xv6 的 GDT 我把宏计算出来的值直接翻译过来，代码应该是下面这个样子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gdt:
</span><span class='line'>  .word 0, 0;
</span><span class='line'>  .byte 0, 0, 0, 0                             # 空
</span><span class='line'>  .word 0xffff, 0x0000;
</span><span class='line'>  .byte 0x00, 0x9a, 0xcf, 0x00                 # 代码段
</span><span class='line'>  .word 0xffff, 0x0000;
</span><span class='line'>  .byte 0x00, 0x92, 0xcf, 0x00                 # 数据段</span></code></pre></td></tr></table></div></figure>


<p>然后我们再把代码段和数据段的段描述符具体每一位的对应值表展示出来，首先是代码段：</p>

<table class="my-table">
<thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td> 9</td><td> 8</td><td> 7</td><td> 6</td><td> 5</td><td> 4</td><td> 3</td><td> 2</td><td> 1</td><td> 0</td></tr></thead>
<tr><th colspan="8">基地址</th><td> G</td><td>DB</td><td>XX</td><td>AA</td><th colspan="4">Limit</th><td> P</td><th colspan="2">DPL</th><td> S</td><td> E</td><td>ED</td><td>RW</td><td>A</td><th colspan="8">基地址</th></tr>
<tr><th colspan="8">0x00</th><td>1</td><td>1</td><td>0</td><td>0</td><th colspan="4">0xf</th><td>1</td><th colspan="2">00</th><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><th colspan="8">0x00</th></tr>
<tr><th colspan="16">基地址</th><th colspan="16">Limit</th></tr>
<tr><th colspan="16">0x0000</th><th colspan="16">0xffff</th></tr>
</table>


<br/><br/>


<p>然后是数据段：</p>

<table class="my-table">
<thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td> 9</td><td> 8</td><td> 7</td><td> 6</td><td> 5</td><td> 4</td><td> 3</td><td> 2</td><td> 1</td><td> 0</td></tr></thead>
<tr><th colspan="8">基地址</th><td> G</td><td>DB</td><td>XX</td><td>AA</td><th colspan="4">Limit</th><td> P</td><th colspan="2">DPL</th><td> S</td><td> E</td><td>ED</td><td>RW</td><td>A</td><th colspan="8">基地址</th></tr>
<tr><th colspan="8">0x00</th><td>1</td><td>1</td><td>0</td><td>0</td><th colspan="4">0xf</th><td>1</td><th colspan="2">00</th><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><th colspan="8">0x00</th></tr>
<tr><th colspan="16">基地址</th><th colspan="16">Limit</th></tr>
<tr><th colspan="16">0x0000</th><th colspan="16">0xffff</th></tr>
</table>


<br/><br/>


<p>我们来一步步解释一下。首先说说这两个内存段的共同点，DB = 1，G = 1，基地址都是 0x00000000，内存分段长度都是 0xfffff，这说明他们都是用于 32 位寻址，所使用的内存是从 0 开始到 4GB 结束（全部内存）。这里是这么算出来的，段长度是 0xfffff = 2<sup>20</sup>，G = 1 表示段界限单位是 4k，所以 4k * 2<sup>20</sup> = 4GB。</p>

<p>再说说他们的不同点，代码段的 E = 1 而数据段的 E = 0 这表名了他们的身份，身份不同 RW 的值虽然相同，但代表的意义也就不相同了，代码段的 RW = 1 代表可读取，数据段的 RW = 1 表示可读可写。这也和我们上面解释的保护模式所能够达到的目的相吻合。</p>

<p>当然作为一款教学为目的的操作系统，xv6 这里的 GDT 设置还是以简单容易理解为目的。诸如“权限位”这样的安全机制就直接被忽略了，而对内存的规划也没有做到真正的“分段”，而是代码段和数据段都启用了从 0 到 4GB 的全部内存寻址。其实这种内存规划方法叫做“平坦内存模型”，即便是 Linux 也是用的这样的方式规划内存的，并没有做到真正的“分段”。这是因为 x86 的分页机制是基于分段的，Linux 选用了更先进的分页机制来管理内存，所以在分段这里只是走一个必要的形式罢了。而 xv6 后面到底是否也启用了分页机制，我们目前还不得而知。</p>

<h2>xv6 正式进入保护模式</h2>

<p>GDT 也搞定了，接下来我们就要把我们刚刚在内存中设定好的 GDT 的位置告诉 CPU，然后就“万事俱备，只欠东风”了。CPU 单独为我们准备了一个寄存器叫做 GDTR 用来保存我们 GDT 在内存中的位置和我们 GDT 的长度。GDTR 寄存器一共 48 位，其中高 32 位用来存储我们的 GDT 在内存中的位置，其余的低 16 位用来存我们的 GDT 有多少个段描述符。 16 位最大可以表示 65536 个数，这里我们把单位换成字节，而一个段描述符是 8 字节，所以 GDT 最多可以有 8192 个段描述符。不仅 CPU 用了一个单独的寄存器 GDTR 来存储我们的 GDT，而且还专门提供了一个指令用来让我们把 GDT 的地址和长度传给 GDTR 寄存器，来看 xv6 的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lgdt   gdtdesc</span></code></pre></td></tr></table></div></figure>


<p>而这个 gdtdesc 和 gdt 一起放在了 bootasm.S 文件的最底部，我们看一眼：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gdtdesc:
</span><span class='line'>  .word   (gdtdesc - gdt - 1)             # 16 位的 gdt 大小sizeof(gdt) - 1
</span><span class='line'>  .long   gdt                             # 32 位的 gdt 所在物理地址</span></code></pre></td></tr></table></div></figure>


<p>不多不少，正好 48 位传给了 GDTR 寄存器，到此 GDT 就准备好了，接下来我们进入保护模式！</p>

<p>前面预备知识中讲到，就如同 A20 gate 这个开关负责打开 1MB 以上内存寻址一样，想要进入“保护模式”我们也需要打开一个开关，这个开关叫“控制寄存器”，x86 的控制寄存器一共有 4 个分别是 CR0、CR1、CR2、CR3，而控制进入“保护模式”的开关在 CR0 上，这四个寄存器都是 32 位的，我们看一下 CR0 上和保护模式有关的位</p>

<table class="my-table">
<thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td> 9</td><td> 8</td><td> 7</td><td> 6</td><td> 5</td><td> 4</td><td> 3</td><td> 2</td><td> 1</td><td> 0</td></tr></thead>
<tr><td>PG</td><th colspan="30">其他控制位</th><td>PE</td></tr>
</table>


<br/><br/><br/><br/>


<ul>
<li><p>PG&#8194;&#8194;&#8194;&#8194;为 0 时代表只使用分段式，不使用分页式<br/>
&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;为 1 是启用分页式</p></li>
<li><p>PE&#8194;&#8194;&#8194;&#8194;为 0 时代表关闭保护模式，运行在实模式下<br/>
&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;为 1 则开启保护模式</p></li>
</ul>


<p>然后我们继续看 xv6 打开保护模式的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>movl    %cr0, %eax
</span><span class='line'>orl     $CR0_PE, %eax
</span><span class='line'>movl    %eax, %cr0</span></code></pre></td></tr></table></div></figure>


<p>因为我们无法直接操作 CR0，所以我们首先要用一个通用寄存器来保存当前 CR0 寄存器的值，这里第一行就是用通用寄存器 eax 来保存 cr0 寄存器的值；然后 CR0_PE 这个宏的定义在 mmu.h 文件中，是个数值 0x00000001，将这个数值与 eax 中的 cr0 寄存器的值做“或”运算后，就保证将 cr0 的第 0 位设置成了 1 即 PE = 1 保证打开了保护模式的开关。而 cr0 的第 31 位 PG = 0 表示我们只使用分段式，不使用分页，这时再将新的计算后的 eax 寄存器中的值写回到 cr0 寄存器中就完成了到保护模式的切换。</p>

<h2>准备迎接 .code32</h2>

<p>到这里我们关于 xv6 从实模式到保护模式的讲解就接近尾声了。我们已经进入到保护模式了，接下来可以将代码彻底以 32 位的保护模式来运行了。所以这时我们的 xv6 也要准备跳转了，再来看一行代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ljmp  $(SEG_KCODE&lt;&lt;3) $start32</span></code></pre></td></tr></table></div></figure>


<p>这是一个跳转语句，通知 CPU 跳转到指定位置继续执行指令。 xv6 在这时就准备跳转到用 C 写成的代码处去继续运行了。这个跳转语句的两个参数就是我们之前一直再讲的典型的“基地址” + “偏移量”的方式告诉 CPU 要跳转到内存的什么位置去继续执行指令。</p>

<p>而这时我们已经在分段式的保护模式下了，所以我们通过这句跳转语句来直观的感受一下分段式保护模式下的内存寻址。</p>

<p>前面预备知识里说道在分段式保护模式下“段基址”（基地址）不再是内存地址，而是 GDT 表的下标。上面我们也说过 GDT 表最大可以有 8192 个表项（段描述符），2<sup>13</sup> = 8192，所以保存着“段基址”的 16 位段寄存器只需要其中的 13 位就可以表示一个 GDT 表的下标，其余的 3 位可用作他用。</p>

<p>按照这个思路我们看看这个 $(SEG_KCODE&lt;&lt;3) 生成的“段基址”是什么？SEG_KCODE 是个宏定义，具体的定义在 mmu.h 文件中，我们翻译过来就是 $(1&lt;&lt;3)，再将它运算出来得到</p>

<table class="my-table">
<thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td> 9</td><td> 8</td><td> 7</td><td> 6</td><td> 5</td><td> 4</td><td> 3</td><td> 2</td><td> 1</td><td> 0</td></tr></thread>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
</table>


<br/><br/>


<p>这里这个 16 位的“段基址”的高 13 位代表 GDT 表的下标（学名应该叫“段选择子”），这里高 13 位刚好是 1，而我们的 GDT 里下标位 1 的内存段正好是我们的“代码段”，而“代码段”我们在 GDT 的“段描述符”中设置了它的其实内存地址是 0x00000000 ，内存段长度是 0xfffff，这是完整的 4GB 内存。</p>

<p>所以这里的跳转语句选择了“代码段”，由于“代码段”的起始内存地址是 0x00000000 ，长度是完整的 4GB，所以后面的“偏移量”仍然相当于是实际的内存地址，所以这里“偏移量”直接用了 $start32，也就是 start32 直接对应的代码位置。通过这个跳转实际上 CPU 就会跳转到 bootasm.S 文件的 start32 标识符处继续执行了。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-07-29T13:27:25+08:00" pubdate data-updated="true">2014年7月29日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/cao-zuo-xi-tong/'>操作系统</a>


</div>
	
	<div class="comments"><a href="/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/#disqus_thread">Comments</a></div>
	
	<div>
		<br/><div>如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</div>
		<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="post" target="_blank" accept-charset="GBK" id="alipayForm">
			<input name="optEmail" type="hidden" value="leenjewel@gmail.com" />
			<input name="payAmount" type="hidden" value="1.00" />
			<input id="title" name="title" type="hidden" value="捐赠给 leenjewel.github.io" />
			<input name="memo" type="hidden" value="文章写的不错，我来捐赠鼓励的！" />
			<input name="pay" type="image" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" width="150" height="40">
		</form>
	</div>
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2014/07/24/%5B%28xue-xi-xv6-%29%5D-zai-mac-osx-xia-yun-xing-xv6/">
		
			【学习 Xv6 】在 Mac OSX 下运行 Xv6</a>
	</h2>
	<div class="entry-content">
		<h2>编译 xv6</h2>

<p>首先要用 git 把 xv6 的源码 clone 到本地</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://pdos.csail.mit.edu/xv6/xv6.git</span></code></pre></td></tr></table></div></figure>


<p>xv6 源代码中的 README 文件中 Building And Running xv6 章节有这么一段说明：“To build xv6 on an x86 ELF machine（like Linux or FreeBSD）, run &ldquo;make&rdquo;&hellip;&hellip;”</p>

<p>这里打算简单解释一下什么是 ELF machine 。按理说我们的计算机运行的程序（这里主要指二进制程序）例如 Windows 下的 exe 文件这样的其实无非都是计算机指令。如果试想一下，我们在同一台计算机上，相同架构下的 CPU 对应可识别的应该也是同一套指令，也就是说不管是 Windows 下的还是 Linux 亦或是 Mac OS 下的二进制程序所对应的 CPU 指令都应该是一样的。那为什么这几个操作系统间的二进制可执行程序不能通用呢？</p>

<p>答案简单的解释起来就是：“他们之间各自的二进制可执行程序的组织方式不同”，也即所谓的格式不统一。</p>

<p>一个二进制程序除了包含有给 CPU 去执行的指令外，还有一些其他的信息，比如数据段，版本信息，链接指示信息等，它们与代码指令一起组成了二进制的可执行程序。而到底以什么样的格式或者顺序将他们组织在一起，每个操作系统就各有不同了，这也是造成他们之间的二进制程序无法通用的主要原因。</p>

<p>言归正传，这里的 ELF 就指的是产生的二进制程序的组装方式。 ELF 是 Linux 和 FreeBSD 这种类 Unix 系统的二进制程序组装格式。 Windows 下的有 PE、COFF 格式，当然 Mac OSX 也有自己的格式。</p>

<p>说到这里对 ELF、PE、COFF 等二进制程序是如何编译链接组装的，强烈向大家推荐一本书<a href="http://product.china-pub.com/195439">《程序员的自我修养&mdash;链接、装载与库》</a>书中对这方面知识的介绍相当的详细和深入！</p>

<p>继续回到我们的 xv6 。前面说了这么多其实是想告诉大家在 Mac OSX 上编译 xv6 绝非容易的事。当然在 xv6 项目的 README 文件中也给了相关的解法。简单的说就是让你按照<a href="http://pdos.csail.mit.edu/6.828/2012/tools.html">这个页面的步骤</a>去安装相应的编译工具，可以理解为在 Mac OSX 上通过交叉编译来支持产生 ELF 格式的二进制程序（就好比通过 Xcode 可以交叉编译出在 ARM 架构的 iPhone 上运行的 APP 一样）。</p>

<p>但是我在尝试着按照<a href="http://pdos.csail.mit.edu/6.828/2012/tools.html">这个页面的步骤</a>去安装相应的编译工具时失败了。于是我放弃了这条道路转而“曲线救国”了。我们手头装个 <a href="http://www.virtualbox.org">VirtualBox</a> 虚拟机然后再在虚拟机上安装一个 Linux 发型版这件事相对容易多了。没错，就是这样，我是在我的 Linux 虚拟机上编译好 xv6 然后再存到 Mac OSX 的文件夹下的。</p>

<p>编译过程非常简单，直接在 xv6 项目文件夹下执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>make</span></code></pre></td></tr></table></div></figure>


<p>编译成功后我们会得到 xv6.img 和 fs.img 两个文件。接下来说说如何运行我们编译好的 xv6。</p>

<h2>运行 xv6</h2>

<p>按照官方的说法，xv6 支持在 qemu 虚拟机下运行。在 Linux 环境安装好 qemu 虚拟机后可以在命令行执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>qemu-system-i386 -serial mon:stdio -hdb fs.img xv6.img -smp 1 -m 512</span></code></pre></td></tr></table></div></figure>


<p>或者执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>qemu-system-x86_64 -smp 1 -parallel stdio -hdb fs.img xv6.img -m 512</span></code></pre></td></tr></table></div></figure>


<p>都可以成功的把 xv6 运行起来。但是在 Mac OSX 下这却是一件“头疼”的事儿。在 Mac OSX 下通过源码编译的方式安装 qemu 虚拟机本身就非常容易失败。xv6 本身又无法在 <a href="http://www.virtualbox.org">VirtualBox</a> 下运行。不过几经查找我发现了这么一款虚拟机，名字叫 <a href="http://www.kju-app.org/">Q</a> 是个基于 qemu 的 Mac OSX 下的虚拟机软件，免费而且开源，酷！</p>

<p>把 <a href="http://www.kju-app.org/">Q</a> 这款虚拟机下载下来安装好，打开之后我们就可以配置我们的 xv6 虚拟机了。</p>

<p>在 <a href="http://www.kju-app.org/">Q</a> 里点击 + 号新建一个虚拟机，在弹出的虚拟机配置对话框里 General 里给这个虚拟机起个名字，比如就叫“xv6”</p>

<p>在 Hardware 配置页里设置 Platform 为 x86 PC 1CPU</p>

<p>在 Hardware 配置页里设置 RAM 为 512 MB，这里默认的配置是 128 MB，但是 128 MB 启动 xv6 会报错。至于为什么 128 MB 内存无法正常运行 xv6 等我学习研究了 xv6 的代码后在告诉大家。</p>

<p>在 Hardware 配置页的 Hard disk 里把 xv6.img 载入进去。</p>

<p>在 Advanced 配置页的 Hard disk 2 里把 fs.img 载入进去。</p>

<p>大功告成，赶快运行你的虚拟机一睹 xv6 的芳容吧！</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-07-24T22:14:15+08:00" pubdate data-updated="true">2014年7月24日</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/os/'>os</a>


</div>
	
	<div class="comments"><a href="/blog/2014/07/24/%5B%28xue-xi-xv6-%29%5D-zai-mac-osx-xia-yun-xing-xv6/#disqus_thread">Comments</a></div>
	
	<div>
		<br/><div>如果你觉得这篇文章让你受益匪浅，欢迎捐赠以鼓励作者！</div>
		<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="post" target="_blank" accept-charset="GBK" id="alipayForm">
			<input name="optEmail" type="hidden" value="leenjewel@gmail.com" />
			<input name="payAmount" type="hidden" value="1.00" />
			<input id="title" name="title" type="hidden" value="捐赠给 leenjewel.github.io" />
			<input name="memo" type="hidden" value="文章写的不错，我来捐赠鼓励的！" />
			<input name="pay" type="image" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" width="150" height="40">
		</form>
	</div>
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/posts//blog/page/2/" class="next">下一页</a>
    
    <div class="center"><a href="/blog/archives">阅读全部日志</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    leenjewel

<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256882796'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1256882796%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'leenjewelgithubio';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-52061917-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- leenjewel.github.io -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-7743616000257723"
     data-ad-slot="4032598696"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</body>
</html>
---
layout: post
title: "【学习xv6】从实模式到保护模式"
date: 2014-07-29 13:27:25 +0800
comments: true
categories: [os]
---

###前言

这是一些列 xv6 代码学习的总结。对于还不知道 xv6 是什么的同学，我这里只简单说一下：xv6 是一个教学用的操作系统，基于 unix v6，再具体的请大家自行 Google 一下 wiki 什么的。

配合这个系列的文章，我在[我的 GitHub](https://github.com/leenjewel/)上建立了一个叫[xv6_learn](https://github.com/leenjewel/xv6_learn)的项目，这个项目就是在 clone 自 xv6 官方源代码的基础上在源码文件中加入了我学习过城中的大量注释。所以在大家看这一系列文章的同时结合着源代码文件来看可能效果更好一些。下面言归正传。

###从 Makefile 开始
从一个操作系统的角度来说，xv6 的代码量并不大，总共不到一万行，分散在众多的源文件中。一上来可能觉得很迷茫，这么多文件，该从哪个开始看起？Makefile 则是这些文件的“目录”，通过它可以很容易找到头绪。

什么是 Makefile？如果你问起这个，那你可能还不适合看这个系列的文章，还是那句话，多 Google 吧。继续言归正传。

上一篇[《【学习 Xv6 】在 Mac OSX 下运行 Xv6》](http://leenjewel.github.io/blog/2014/07/24/%5B%28xue-xi-xv6-%29%5D-zai-mac-osx-xia-yun-xing-xv6/)中说道 xv6 编译成功后会生成两个文件：xv6.img 和 fs.img 我们从 xv6.img 开始。

从 Makefile 中可以看到 xv6.img 的生成条件：

```
xv6.img: bootblock kernel fs.img
	dd if=/dev/zero of=xv6.img count=10000
	dd if=bootblock of=xv6.img conv=notrunc
	dd if=kernel of=xv6.img seek=1 conv=notrunc
```

fs.img 这里暂且不说，通过字面不难看出 bootblock 应该是系统一开始引导阶段的逻辑，kernel 当然就是内核了。所以第一步先研究 bootblock。我们接着在 Makefile 里找 bootblock 的生成条件：

```
bootblock: bootasm.S bootmain.c
	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
	$(OBJDUMP) -S bootblock.o > bootblock.asm
	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
	./sign.pl bootblock
```

bootblock 的生成只需要两个文件，一个汇编一个 C 源码。那我们就准备讲讲 bootasm.S 文件了。

###x86 的启动

看具体的代码前先说说 x86 架构开机引导的相关知识。这方面的知识如果详细的讲的话足够再开一个系列的了。因为我们这个系列主要还是讲 xv6 所以这里只尽量用通俗易懂且简单明了的方式介绍一下。对这方面感兴趣且想要深入的同学可以自行 google 一下，能找到很多很多资料，写得也非常的详实，所以这里我就不打算“造轮子”了。

x86 历史悠久这也早就了它的一部“血泪史”，各种向下兼容各种绕，所以对于想要了解 x86 的同学来说，特别容易被绕进去，说白了 x86 架构把很多简单的事情给复杂了，主要是为了保持向下兼容。

从给 x86 通电的一刻开始，CPU 执行的第一段指令是 BIOS 固化在 ROM 上的代码，这个过程是硬件定死的规矩，就是这样。

而 BIOS 在硬件自检完成后（你会听到“滴”的一声）会根据你在 BIOS 里设置的启动顺序（硬盘、光驱、USB）读取每个引导设备的第一个扇区 512字节的内容，并判断这段内容的最后 2 字节是否为 0xAA55，如果是说明这个设备是可引导的，于是就将这 512 字节的内容放到内存的 0x7C00 位置，然后告诉 CPU 去执行这个位置的指令。这个过程同样是硬件定死的规矩，就是这样。

有了上面的介绍我们再回到 xv6 如果你看一下编译生成的 bootblock 二进制文件，你会惊喜的发现它的文件大小刚好是 512 字节。用十六进制编辑器（我在 Mac OSX 下用的是 0xED 这个软件）打开 bootblock 这个二进制文件，你又会发现这个 512 字节的文件的最后两字节正好是 0xAA55。

再回过头看上面 Makefile 中 xv6.img 生成条件的代码中也可以看出 xv6.img 就是通过 dd 命令讲编译好的 bootblock 和 kernel 拼接而成，这也再一次印证了 bootblock 是负责引导逻辑的结论。

有了这个结论，我们可以开始“放心大胆”的开始看 bootasm.S 这个汇编源文件的代码了。

###bootasm.S 文件

看 bootasm.S 文件需要你有一定的汇编基础。没有也没关系，我尽量解释的清楚一些。

还是再看一眼 Makefile 里 bootblock 生成那段有这么一句

```
$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
```

这段说明 bootblock 的代码段加载到内存 0x7C00 处，代码从 start 处开始执行（可以理解为相当于 C 中的 main 这样的入口函数）。所以 bootasm.S 一上来就是入口 start

```
.code16
.global start
start:
    cli
    xorw    %ax,%ax
    movw    %ax,%ds
    movw    %ax,%es
    movw    %ax,%ss
```

先讲 start：下面的这 5 行代码。

cli 指令关闭了中断响应，意味着从这一刻开始你的计算机将不再响应任何中断事件（比如这时候你敲个键盘点个鼠标啥的，CPU 就不再理你了）。之所以要关闭中断响应是因为要保证引导代码的顺利执行（总不能执行到一半被 CPU 给中断了吧，那直接就挂了）。

接下来的 4 行代码显示用异或将 %ax 寄存器的值置成 0，然后在用 %ax 寄存器的值将 %ds、%es、%ss 三个寄存器的值全部置 0，相当于初始化了。

然后我们再看 .code16 这句。这告诉 CPU 我们目前是在 16 位模式下执行代码，也即所谓的“实模式”。

###实模式

什么是“实模式”？这其实就是 x86 向下兼容的一个“妥协”产物。要从 8086 那个时代讲起。8086 时代的 CPU 寄存器是 16 位的，内存地址线是 20 位的。当我们想要从内存读取或向内存写入数据的时候，我们要把内存地址告诉 CPU，CPU 将我们告诉的内存地址存到自己的寄存器里，再将这个地址发给内存地址线，内存地址线的数据发到内存时，内存就会根据这个地址找到自己存放的数据了。

这时问题就来了：16 位的寄存器要怎么表示 20 位的内存地址？答案是用两个 16 位的寄存器来搞！一个叫 segment（段基地址），一个叫 offset（偏移地址），segment 左移 4 位然后和 offset 相加就得到一个 20 位的内存地址了。

20 位的地址线最大寻址是 2^20 = 1MB 那时候大家都认为计算机有 1MB 内存就足够用了，呵呵~~~

这个时候有个小问题，按照上面的方式用两个 16 位寄存器左移后相加的方式能够得到的最大地址是超过 20 位的。比如我 segment 是 0xffff 然后 offset 也是 0xffff 左移相加之后得到的是 0x10ffef 已经超过 20 位地址线能够传输的位数了。当时的解决办法也简单：“取模”，通用的叫法是“卷绕”。就是如果你拿个 0x10ffef 来寻址，我就拿你当作 0x0ffef。你拿 0x100001 来寻址，我就拿你当作 0x00001 。你超出终点我就把你绕回起点。

1MB 内存寻址现在来看那是根本不够用的。所以后来的 80286 和 80386 的出现把内存地址线从 20 位扩充到 24 位，最后又扩充到 32 位，直到现在有了 64 位内存地址线更大的内存寻址能力。64 位的就不说了，32 位的我们都直到起内存寻址能力能够达到 2^32 = 4GB，这也就是为什么我们会说 32 位的操作系统最大只能使用 4GB 内存的原因（实际上如果淡淡指内存的话是到不了真正的 4GB 的使用率的）。

好吧，内存寻址位上去了，有更大的内存用了，挺好。但是英特尔说了，要向下兼容啊，要保证世界上当时为 8086 写的软件在 286、386 上也要能够运行啊。说白了就是要 286、386甚至现在的奔腾啊、酷睿啊什么的照样能装得跟 8086 一个样儿。

英特尔的工程师们说这好办啊，那就“装”一下吧。于是为了这个向下兼容的需求，即便到了现在，无论你的电脑有多NB的CPU，多大的内存，在你开机的时候它的最大内存寻址就是 1MB，超过 1MB 就“卷绕”。这就是所谓的“实模式”

这个时候问题又来了。我开机就进入“装逼”模式，那我总不能一直“装”下去啊，得有个办法告诉我啥时候就“不装”了。工程师们说这也好办啊，弄个开关吧，开关关着你就“装”，开关开开就“别装”了。可是这开关放在哪呢？单独为了这个功能在硬件上新搞一个开关有点“多余”啊，于是工程师们发现在 804x 键盘控制器上还有多余的地方能放这个开关，所以就有了 A20 gate，又叫 A20 门。

如果 A20 gate 关闭的时候 CPU 就通过“卷绕”保证最大寻址为 1MB 以兼容 8086 ，当 A20 gate 打开，CPU 就突破 1MB 的寻址限制可以寻址更大的内存了。

###打开 A20 gate

有了上面“实模式”和 A20 gate 的介绍，我们接着往下看 xv6 bootasm.S 的代码。在实模式下初始化好寄存器后，xv6 bootasm.S 接下来要做的事情就是打开 A20 gate 突破 1MB 内存寻址的限制。

```
seta20.1:
  inb     $0x64,%al
  testb   $0x2,%al
  jnz     seta20.1 

  movb    $0xd1,%al
  outb    %al,$0x64

seta20.2:
  inb     $0x64,%al
  testb   $0x2,%al
  jnz     seta20.2 

  movb    $0xdf,%al
  outb    %al,$0x60
```

这里 bootasm.S 用了两个方法 seta20.1 和 seta20.2 来实现打开 A20 gate。 使用的方法就是上面讲的通过 804x 键盘控制器来操作 A20 gate。这个办法确实是分两步来搞的：

第一步是向 804x 键盘控制器的 0x64 端口发送命令。这里传送的命令是 0xd1，这个命令的意思是要向键盘控制器的 P2 写入数据。这就是 seta20.1 代码段所做的工作（具体的解释可以参看我在代码中写的注释）。

第二布就是向键盘控制器的 P2 端口写数据了。写数据的方法是把数据通过键盘控制器的 0x60 端口写进去。写入的数据是 0xdf，因为 A20 gate 就包含在键盘控制器的 P2 端口中，随着 0xdf 的写入，A20 gate 就被打开了。

接下来要做的就是进入“保护模式”了。

###保护模式

实模式下对于内存的访问是很直接的，你有内存地址就可以访问内存。这对于单任务系统来说没有问题，对于多任务系统就不够安全了。

举个例子：你有个程序计算 1 + 1，在单任务系统（DOS）下你的程序运行的时候整个内存都是你的，你想怎么用就怎么用，没什么问题。

但是现在的操作系统都是多任务的（一边QQ一边听歌一边看电影的系统~），在你运行你的 1 + 1 程序时，还有可能有个计算 2 + 2 的程序也在运行，你们俩共用一台计算机的内存，那到底谁应该用哪块儿内存呢？你也不希望你的程序好不容易算出来的 1 + 1 = 2 的结果放入内存后就被另一个 2 + 2 的程序把它的计算结果 4 覆盖进去吧~

于是保护模式的概念就被提了出来。保护模式从硬件层面给操作系统提供了更为细致的规划内存的支持。

目前保护模式下主流的内存管理模式有“分段式”和“分页式”，两个模式的目的都是一样的就是把内存分出不同的区来分配给不同的运行中的程序，让大家不要相互影响。

那“分段式”和“分页式”到底谁更好一些呢？其实大家各有千秋吧，不过目前主流的操作系统（Windows、Linux、FreeBSD等）都一置的使用了“分页式”，可见“分页式”还是更好一些吧。

###x86的分段和分页

x86 是个历史悠久的架构，悠久到保护模式还只有“分段式”一家的时候就有 x86 了，于是当“分页式”大红大紫的时候，x86 也想要“分页式”，于是这时候又有人出来大喊一声：“向下兼容！”，然后工程师们又说：“好办！”。

为了向下兼容，x86 的分页式内存管理是建立在分段式内存管理之上的。我们今天只说分段，分页放在以后讲。

一个程序基本是由数据和指令组成的，所以运行一个程序至少需要两段内存：数据段（包含堆栈段） + 代码段。

还是拿 1 + 1 这个程序举例，假如你真的有个程序就是用来计算 1 + 1 等于几的。这个时候 1 和计算出的结果都是数据，数据有什么特点？数据是可读可写的，CPU 要能读取你的数据 1 还要把计算结果 2 写入到内存中去。而 + 号就是所谓的代码，代码有什么特点？代码应该式只读的，CPU 可以读取你的代码并且可以执行，但是你肯定不希望你的代码能被别的什么改写，要不 1 + 1 变成了 1 - 1 那就都乱了。

所以在保护模式下运行一个程序，分配给这个程序一段可读可写不可执行的内存来存放数据，一段可读可执行不可写的内存来存放代码就达到了保护程序正常运行的目的。

接下来接着讲 xv6 向保护模式前进的代码

### xv6 准备进入保护模式
---
layout: post
title: "【学习xv6】从实模式到保护模式"
date: 2014-07-29 13:27:25 +0800
comments: true
categories: [os]
---

###前言

这是一些列 xv6 代码学习的总结。对于还不知道 xv6 是什么的同学，我这里只简单说一下：xv6 是一个教学用的操作系统，基于 unix v6，再具体的请大家自行 Google 一下 wiki 什么的。

配合这个系列的文章，我在[我的 GitHub](https://github.com/leenjewel/)上建立了一个叫[xv6_learn](https://github.com/leenjewel/xv6_learn)的项目，这个项目就是在 clone 自 xv6 官方源代码的基础上在源码文件中加入了我学习过城中的大量注释。所以在大家看这一系列文章的同时结合着源代码文件来看可能效果更好一些。下面言归正传。

###从 Makefile 开始
从一个操作系统的角度来说，xv6 的代码量并不大，总共不到一万行，分散在众多的源文件中。一上来可能觉得很迷茫，这么多文件，该从哪个开始看起？Makefile 则是这些文件的“目录”，通过它可以很容易找到头绪。

什么是 Makefile？如果你问起这个，那你可能还不适合看这个系列的文章，还是那句话，多 Google 吧。继续言归正传。

上一篇[《【学习 Xv6 】在 Mac OSX 下运行 Xv6》](http://leenjewel.github.io/blog/2014/07/24/%5B%28xue-xi-xv6-%29%5D-zai-mac-osx-xia-yun-xing-xv6/)中说道 xv6 编译成功后会生成两个文件：xv6.img 和 fs.img 我们从 xv6.img 开始。

从 Makefile 中可以看到 xv6.img 的生成条件：

```
xv6.img: bootblock kernel fs.img
	dd if=/dev/zero of=xv6.img count=10000
	dd if=bootblock of=xv6.img conv=notrunc
	dd if=kernel of=xv6.img seek=1 conv=notrunc
```

fs.img 这里暂且不说，通过字面不难看出 bootblock 应该是系统一开始引导阶段的逻辑，kernel 当然就是内核了。所以第一步先研究 bootblock。我们接着在 Makefile 里找 bootblock 的生成条件：

```
bootblock: bootasm.S bootmain.c
	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
	$(OBJDUMP) -S bootblock.o > bootblock.asm
	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
	./sign.pl bootblock
```

bootblock 的生成只需要两个文件，一个汇编一个 C 源码。那我们就准备讲讲 bootasm.S 文件了。

###x86 的启动

看具体的代码前先说说 x86 架构开机引导的相关知识。这方面的知识如果详细的讲的话足够再开一个系列的了。因为我们这个系列主要还是讲 xv6 所以这里只尽量用通俗易懂且简单明了的方式介绍一下。对这方面感兴趣且想要深入的同学可以自行 google 一下，能找到很多很多资料，写得也非常的详实，所以这里我就不打算“造轮子”了。

x86 历史悠久这也早就了它的一部“血泪史”，各种向下兼容各种绕，所以对于想要了解 x86 的同学来说，特别容易被绕进去，说白了 x86 架构把很多简单的事情给复杂了，主要是为了保持向下兼容。

从给 x86 通电的一刻开始，CPU 执行的第一段指令是 BIOS 固化在 ROM 上的代码，这个过程是硬件定死的规矩，就是这样。

而 BIOS 在硬件自检完成后（你会听到“滴”的一声）会根据你在 BIOS 里设置的启动顺序（硬盘、光驱、USB）读取每个引导设备的第一个扇区 512字节的内容，并判断这段内容的最后 2 字节是否为 0xAA55，如果是说明这个设备是可引导的，于是就将这 512 字节的内容放到内存的 0x7C00 位置，然后告诉 CPU 去执行这个位置的指令。这个过程同样是硬件定死的规矩，就是这样。

有了上面的介绍我们再回到 xv6 如果你看一下编译生成的 bootblock 二进制文件，你会惊喜的发现它的文件大小刚好是 512 字节。用十六进制编辑器（我在 Mac OSX 下用的是 0xED 这个软件）打开 bootblock 这个二进制文件，你又会发现这个 512 字节的文件的最后两字节正好是 0xAA55。

再回过头看上面 Makefile 中 xv6.img 生成条件的代码中也可以看出 xv6.img 就是通过 dd 命令讲编译好的 bootblock 和 kernel 拼接而成，这也再一次印证了 bootblock 是负责引导逻辑的结论。

有了这个结论，我们可以开始“放心大胆”的开始看 bootasm.S 这个汇编源文件的代码了。

###bootasm.S 文件

看 bootasm.S 文件需要你有一定的汇编基础。没有也没关系，我尽量解释的清楚一些。

还是再看一眼 Makefile 里 bootblock 生成那段有这么一句

```
$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
```

这段说明 bootblock 的代码段加载到内存 0x7C00 处，代码从 start 处开始执行（可以理解为相当于 C 中的 main 这样的入口函数）。所以 bootasm.S 一上来就是入口 start

```
.code16
.global start
start:
    cli
    xorw    %ax,%ax
    movw    %ax,%ds
    movw    %ax,%es
    movw    %ax,%ss
```

先讲 start：下面的这 5 行代码。

cli 指令关闭了中断响应，意味着从这一刻开始你的计算机将不再响应任何中断事件（比如这时候你敲个键盘点个鼠标啥的，CPU 就不再理你了）。之所以要关闭中断响应是因为要保证引导代码的顺利执行（总不能执行到一半被 CPU 给中断了吧，那直接就挂了）。

接下来的 4 行代码显示用异或将 %ax 寄存器的值置成 0，然后在用 %ax 寄存器的值将 %ds、%es、%ss 三个寄存器的值全部置 0，相当于初始化了。

然后我们再看 .code16 这句。这告诉 CPU 我们目前是在 16 位模式下执行代码，也即所谓的“实模式”。

###实模式

什么是“实模式”？这其实就是 x86 向下兼容的一个“妥协”产物。要从 8086 那个时代讲起。8086 时代的 CPU 寄存器是 16 位的，内存地址线是 20 位的。当我们想要从内存读取或向内存写入数据的时候，我们要把内存地址告诉 CPU，CPU 将我们告诉的内存地址存到自己的寄存器里，再将这个地址发给内存地址线，内存地址线的数据发到内存时，内存就会根据这个地址找到自己存放的数据了。

这时问题就来了：16 位的寄存器要怎么表示 20 位的内存地址？答案是用两个 16 位的寄存器来搞！一个叫 segment（段基地址），一个叫 offset（偏移地址），segment 左移 4 位然后和 offset 相加就得到一个 20 位的内存地址了。

20 位的地址线最大寻址是 2^20 = 1MB 那时候大家都认为计算机有 1MB 内存就足够用了，呵呵~~~

这个时候有个小问题，按照上面的方式用两个 16 位寄存器左移后相加的方式能够得到的最大地址是超过 20 位的。比如我 segment 是 0xffff 然后 offset 也是 0xffff 左移相加之后得到的是 0x10ffef 已经超过 20 位地址线能够传输的位数了。当时的解决办法也简单：“取模”，通用的叫法是“卷绕”。就是如果你拿个 0x10ffef 来寻址，我就拿你当作 0x0ffef。你拿 0x100001 来寻址，我就拿你当作 0x00001 。你超出终点我就把你绕回起点。

1MB 内存寻址现在来看那是根本不够用的。所以后来的 80286 和 80386 的出现把内存地址线从 20 位扩充到 24 位，最后又扩充到 32 位，直到现在有了 64 位内存地址线更大的内存寻址能力。64 位的就不说了，32 位的我们都直到起内存寻址能力能够达到 2^32 = 4GB，这也就是为什么我们会说 32 位的操作系统最大只能使用 4GB 内存的原因（实际上如果淡淡指内存的话是到不了真正的 4GB 的使用率的）。

好吧，内存寻址位上去了，有更大的内存用了，挺好。但是英特尔说了，要向下兼容啊，要保证世界上当时为 8086 写的软件在 286、386 上也要能够运行啊。说白了就是要 286、386甚至现在的奔腾啊、酷睿啊什么的照样能装得跟 8086 一个样儿。

英特尔的工程师们说这好办啊，那就“装”一下吧。于是为了这个向下兼容的需求，即便到了现在，无论你的电脑有多NB的CPU，多大的内存，在你开机的时候它的最大内存寻址就是 1MB，超过 1MB 就“卷绕”。这就是所谓的“实模式”

这个时候问题又来了。我开机就进入“装逼”模式，那我总不能一直“装”下去啊，得有个办法告诉我啥时候就“不装”了。工程师们说这也好办啊，弄个开关吧，开关关着你就“装”，开关开开就“别装”了。可是这开关放在哪呢？单独为了这个功能在硬件上新搞一个开关有点“多余”啊，于是工程师们发现在 804x 键盘控制器上还有多余的地方能放这个开关，所以就有了 A20 gate，又叫 A20 门。

如果 A20 gate 关闭的时候 CPU 就通过“卷绕”保证最大寻址为 1MB 以兼容 8086 ，当 A20 gate 打开，CPU 就突破 1MB 的寻址限制可以寻址更大的内存了。

###打开 A20 gate

有了上面“实模式”和 A20 gate 的介绍，我们接着往下看 xv6 bootasm.S 的代码。在实模式下初始化好寄存器后，xv6 bootasm.S 接下来要做的事情就是打开 A20 gate 突破 1MB 内存寻址的限制。

```
seta20.1:
  inb     $0x64,%al
  testb   $0x2,%al
  jnz     seta20.1 

  movb    $0xd1,%al
  outb    %al,$0x64

seta20.2:
  inb     $0x64,%al
  testb   $0x2,%al
  jnz     seta20.2 

  movb    $0xdf,%al
  outb    %al,$0x60
```

这里 bootasm.S 用了两个方法 seta20.1 和 seta20.2 来实现打开 A20 gate。 使用的方法就是上面讲的通过 804x 键盘控制器来操作 A20 gate。这个办法确实是分两步来搞的：

第一步是向 804x 键盘控制器的 0x64 端口发送命令。这里传送的命令是 0xd1，这个命令的意思是要向键盘控制器的 P2 写入数据。这就是 seta20.1 代码段所做的工作（具体的解释可以参看我在代码中写的注释）。

第二布就是向键盘控制器的 P2 端口写数据了。写数据的方法是把数据通过键盘控制器的 0x60 端口写进去。写入的数据是 0xdf，因为 A20 gate 就包含在键盘控制器的 P2 端口中，随着 0xdf 的写入，A20 gate 就被打开了。

接下来要做的就是进入“保护模式”了。

###保护模式

实模式下对于内存的访问是很直接的，你有内存地址就可以访问内存。这对于单任务系统来说没有问题，对于多任务系统就不够安全了。

举个例子：你有个程序计算 1 + 1，在单任务系统（DOS）下你的程序运行的时候整个内存都是你的，你想怎么用就怎么用，没什么问题。

但是现在的操作系统都是多任务的（一边QQ一边听歌一边看电影的系统~），在你运行你的 1 + 1 程序时，还有可能有个计算 2 + 2 的程序也在运行，你们俩共用一台计算机的内存，那到底谁应该用哪块儿内存呢？你也不希望你的程序好不容易算出来的 1 + 1 = 2 的结果放入内存后就被另一个 2 + 2 的程序把它的计算结果 4 覆盖进去吧~

于是保护模式的概念就被提了出来。保护模式从硬件层面给操作系统提供了更为细致的规划内存的支持。

目前保护模式下主流的内存管理模式有“分段式”和“分页式”，两个模式的目的都是一样的就是把内存分出不同的区来分配给不同的运行中的程序，让大家不要相互影响。

那“分段式”和“分页式”到底谁更好一些呢？其实大家各有千秋吧，不过目前主流的操作系统（Windows、Linux、FreeBSD等）都一置的使用了“分页式”，可见“分页式”还是更好一些吧。

###x86的分段和分页

x86 是个历史悠久的架构，悠久到保护模式还只有“分段式”一家的时候就有 x86 了，于是当“分页式”大红大紫的时候，x86 也想要“分页式”，于是这时候又有人出来大喊一声：“向下兼容！”，然后工程师们又说：“好办！”。

为了向下兼容，x86 的分页式内存管理是建立在分段式内存管理之上的。我们今天只说分段，分页放在以后讲。

一个程序基本是由数据和指令组成的，所以运行一个程序至少需要两段内存：数据段（包含堆栈段） + 代码段。

还是拿 1 + 1 这个程序举例，假如你真的有个程序就是用来计算 1 + 1 等于几的。这个时候 1 和计算出的结果都是数据，数据有什么特点？数据是可读可写的，CPU 要能读取你的数据 1 还要把计算结果 2 写入到内存中去。而 + 号就是所谓的代码，代码有什么特点？代码应该式只读的，CPU 可以读取你的代码并且可以执行，但是你肯定不希望你的代码能被别的什么改写，要不 1 + 1 变成了 1 - 1 那就都乱了。

所以在保护模式下运行一个程序，分配给这个程序一段可读可写不可执行的内存来存放数据，一段可读可执行不可写的内存来存放代码就达到了保护程序正常运行的目的。

接下来接着讲 xv6 向保护模式前进的代码

### xv6 准备 GDT

在进入保护模式前需要将 GDT 准备好。什么是 GDT ？它的中文名称叫“全局描述符表”，保护模式下的内存寻址需要用到它。我们先说一下保护模式下的内存寻址。

为了向下兼容（还是万恶的向下兼容~），前面我们讲实模式下的内存寻址的时候讲到用两个 16 位寄存器通过 segment + offset 的方式进行寻址，于是为了兼容这种寻址模式，在保护模式下 segment 寄存器还是保持了 16 位（即便新的 CPU segment 寄存器都是 32 位的，但还只是使用其中的 16 位），但是 16 位要如何做 32 位地址线的寻址呢？

分段机制的做法是把每个内存分段的 32 位段基址先存在内存上，就像一个 list 一样排列好，然后拿 16 位的 segment 当作这个 list 的索引来对应找到 list 上真正的 32 位地址。而这个 GDT 就是这个 list。所以在正式进入保护模式前我们要先建立 GDT，把内存按段规划好。

而这个 GDT 中的每一项叫做一个“段描述符”，每一项对应一个内存分段。我们先来看一眼这个段描述符的具体结构：

<table>
<thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td> 9</td><td> 8</td><td> 7</td><td> 6</td><td> 5</td><td> 4</td><td> 3</td><td> 2</td><td> 1</td><td> 0</td></tr></thead>
<tr><th colspan="8">基地址</th><td> G</td><td>DB</td><td>XX</td><td>AA</td><th colspan="4">Limit</th><td> P</td><th colspan="2">DPL</th><td> S</td><td> E</td><td>ED</td><td>RW</td><td>A</td><th colspan="8">基地址</th></tr>
<tr><th colspan="16">基地址</th><th colspan="16">Limit</th></tr>
</table>

三块“基地址”组装起来正好就是 32 位的段其实内存地址，两块 Limit 组成该内存分段的长度，接下来依次解释一下其他位所代表的意义：

* P:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;0 本段不在内存中
* DPL:&#8194;&#8194;&#8194;访问该段内存所需权限等级 00 -- 11，0为最大权限级别
* S:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;1 代表数据段、代码段或堆栈段，0 代表系统段如中断门或调用门
* E:&#8194;&#8194; &#8194; &#8194; 1 代表代码段，可执行标记，0 代表数据段
* ED:&#8194;&#8194; &#8194; 0 代表忽略特权级，1 代表遵守特权级
* RW:&#8194;&#8194;&#8194; 如果是数据段（E=0）则1 代表可写入，0 代表只读；<br/>
&#8194; &#8194; &#8194; &#8194; &#8194; &#8194;如果是代码段（E=1）则1 代表可读取，0 代表不可读取
* A:&#8194; &#8194; &#8194; &#8194; 1 表示该段内存访问过，0 表示没有被访问过
* G:&#8194; &#8194; &#8194; &#8194; 1 表示 20 位段界限单位是 4KB，最大长度 4GB；<br/>
&#8194; &#8194; &#8194; &#8194; &#8194; &#8194; 0 表示 20 位段界限单位是 1 字节，最大长度 1MB
* DB:&#8194; &#8194; &#8194; 1 表示地址和操作数是 32 位，0 表示地址和操作数是 16 位
* XX:&#8194; &#8194; &#8194; 保留位永远是 0
* AA:&#8194;&#8194;&#8194;&#8194;&#8194;&#8194;给系统提供的保留位

有了上述的解释，我们再来看看 xv6 是怎样准备自己的 GDT 的，代码在 bootasm.S 文件最底部：

```
gdt:
  SEG_NULLASM                             # 空
  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # 代码段
  SEG_ASM(STA_W, 0x0, 0xffffffff)         # 数据（堆栈）段

```

这里用到了几个宏，具体的宏定义在 asm.h 文件中，为了方便大家直观的感受一下 xv6 的 GDT 我把宏计算出来的值直接翻译过来，代码应该是下面这个样子：

```
gdt:
  .word 0, 0;
  .byte 0, 0, 0, 0                             # 空
  .word 0xffff, 0x0000;
  .byte 0x00, 0x9a, 0xcf, 0x00                 # 代码段
  .word 0xffff, 0x0000;
  .byte 0x00, 0x92, 0xcf, 0x00                 # 数据段
```

然后我们再把代码段和数据段的段描述符具体每一位的对应值表展示出来，首先是代码段：

<table>
<thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td> 9</td><td> 8</td><td> 7</td><td> 6</td><td> 5</td><td> 4</td><td> 3</td><td> 2</td><td> 1</td><td> 0</td></tr></thead>
<tr><th colspan="8">基地址</th><td> G</td><td>DB</td><td>XX</td><td>AA</td><th colspan="4">Limit</th><td> P</td><th colspan="2">DPL</th><td> S</td><td> E</td><td>ED</td><td>RW</td><td>A</td><th colspan="8">基地址</th></tr>
<tr><th colspan="8">0x00</th><td>1</td><td>1</td><td>0</td><td>0</td><th colspan="4">0xf</th><td>1</td><th colspan="2">00</th><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><th colspan="8">0x00</th></tr>
<tr><th colspan="16">基地址</th><th colspan="16">Limit</th></tr>
<tr><th colspan="16">0x0000</th><th colspan="16">0xffff</th></tr>
</table>

然后是数据段：

<table>
<thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td> 9</td><td> 8</td><td> 7</td><td> 6</td><td> 5</td><td> 4</td><td> 3</td><td> 2</td><td> 1</td><td> 0</td></tr></thead>
<tr><th colspan="8">基地址</th><td> G</td><td>DB</td><td>XX</td><td>AA</td><th colspan="4">Limit</th><td> P</td><th colspan="2">DPL</th><td> S</td><td> E</td><td>ED</td><td>RW</td><td>A</td><th colspan="8">基地址</th></tr>
<tr><th colspan="8">0x00</th><td>1</td><td>1</td><td>0</td><td>0</td><th colspan="4">0xf</th><td>1</td><th colspan="2">00</th><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><th colspan="8">0x00</th></tr>
<tr><th colspan="16">基地址</th><th colspan="16">Limit</th></tr>
<tr><th colspan="16">0x0000</th><th colspan="16">0xffff</th></tr>
</table>

我们来一步步解释一下。首先说说这两个内存段的共同点，DB = 1，G = 1，基地址都是 0x00000000，内存分段长度都是 0xfffff，这说明他们都是用于 32 位寻址，所使用的内存是从 0 开始到 4GB 结束（全部内存）。这里是这么算出来的，段长度是 0xfffff = 2^20，G = 1 表示段界限单位是 4k，所以 4k * 2^20 = 4GB。

再说说他们的不同点，代码段的 E = 1 而数据段的 E = 0 这表名了他们的身份，身份不同 RW 的值虽然相同，但代表的意义也就不相同了，代码段的 RW = 1 代表可读取，数据段的 RW = 1 表示可读可写。这也和我们上面解释的保护模式所能够达到的目的相吻合。

当然作为一款教学为目的的操作系统，xv6 这里的 GDT 设置还是以简单容易理解为目的。诸如“权限位”这样的安全机制就直接被忽略了，而对内存的规划也没有做到真正的“分段”，而是代码段和数据段都启用了从 0 到 4GB 的全部内存寻址。其实这种内存规划方法叫做“平坦内存模型”，即便是 Linux 也是用的这样的方式规划内存的，并没有做到真正的“分段”。这是因为 x86 的分页机制是基于分段的，Linux 选用了更先进的分页机制来管理内存，所以在分段这里只是走一个必要的形式罢了。而 xv6 后面到底是否也启用了分页机制，我们目前还不得而知。

###xv6 正式进入保护模式

GDT 也搞定了，接下来我们就要把我们刚刚在内存中设定好的 GDT 的位置告诉 CPU，然后就“万事俱备，只欠东风”了。CPU 单独为我们准备了一个寄存器叫做 GDTR 用来保存我们 GDT 在内存中的位置和我们 GDT 的长度。GDTR 寄存器一共 48 位，其中高 32 位用来存储我们的 GDT 在内存中的位置，其余的低 16 位用来存我们的 GDT 有多少个段描述符。 16 位最大可以表示 65536 个数，这里我们把单位换成字节，而一个段描述符是 8 字节，所以 GDT 最多可以有 8192 个段描述符。不仅 CPU 用了一个单独的寄存器 GDTR 来存储我们的 GDT，而且还专门提供了一个指令用来让我们把 GDT 的地址和长度传给 GDTR 寄存器，来看 xv6 的代码：

```
lgdt   gdtdesc
```

而这个 gdtdesc 和 gdt 一起放在了 bootasm.S 文件的最底部，我们看一眼：

```
gdtdesc:
  .word   (gdtdesc - gdt - 1)             # 16 位的 gdt 大小sizeof(gdt) - 1
  .long   gdt                             # 32 位的 gdt 所在物理地址
```

不多不少，正好 48 位传给了 GDTR 寄存器，到此 GDT 就准备好了，接下来我们进入保护模式！